// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'app_database.dart';

// ignore_for_file: type=lint
class $CompaniesTable extends Companies
    with TableInfo<$CompaniesTable, Company> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CompaniesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _companyIdMeta = const VerificationMeta(
    'companyId',
  );
  @override
  late final GeneratedColumn<String> companyId = GeneratedColumn<String>(
    'company_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _companyNameMeta = const VerificationMeta(
    'companyName',
  );
  @override
  late final GeneratedColumn<String> companyName = GeneratedColumn<String>(
    'company_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _taxIdMeta = const VerificationMeta('taxId');
  @override
  late final GeneratedColumn<String> taxId = GeneratedColumn<String>(
    'tax_id',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _addressMeta = const VerificationMeta(
    'address',
  );
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _logoUrlMeta = const VerificationMeta(
    'logoUrl',
  );
  @override
  late final GeneratedColumn<String> logoUrl = GeneratedColumn<String>(
    'logo_url',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 500),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    companyId,
    companyName,
    taxId,
    address,
    phone,
    logoUrl,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'companies';
  @override
  VerificationContext validateIntegrity(
    Insertable<Company> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('company_id')) {
      context.handle(
        _companyIdMeta,
        companyId.isAcceptableOrUnknown(data['company_id']!, _companyIdMeta),
      );
    } else if (isInserting) {
      context.missing(_companyIdMeta);
    }
    if (data.containsKey('company_name')) {
      context.handle(
        _companyNameMeta,
        companyName.isAcceptableOrUnknown(
          data['company_name']!,
          _companyNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_companyNameMeta);
    }
    if (data.containsKey('tax_id')) {
      context.handle(
        _taxIdMeta,
        taxId.isAcceptableOrUnknown(data['tax_id']!, _taxIdMeta),
      );
    }
    if (data.containsKey('address')) {
      context.handle(
        _addressMeta,
        address.isAcceptableOrUnknown(data['address']!, _addressMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('logo_url')) {
      context.handle(
        _logoUrlMeta,
        logoUrl.isAcceptableOrUnknown(data['logo_url']!, _logoUrlMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {companyId};
  @override
  Company map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Company(
      companyId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}company_id'],
      )!,
      companyName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}company_name'],
      )!,
      taxId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tax_id'],
      ),
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      logoUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}logo_url'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $CompaniesTable createAlias(String alias) {
    return $CompaniesTable(attachedDatabase, alias);
  }
}

class Company extends DataClass implements Insertable<Company> {
  final String companyId;
  final String companyName;
  final String? taxId;
  final String? address;
  final String? phone;
  final String? logoUrl;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Company({
    required this.companyId,
    required this.companyName,
    this.taxId,
    this.address,
    this.phone,
    this.logoUrl,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['company_id'] = Variable<String>(companyId);
    map['company_name'] = Variable<String>(companyName);
    if (!nullToAbsent || taxId != null) {
      map['tax_id'] = Variable<String>(taxId);
    }
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || logoUrl != null) {
      map['logo_url'] = Variable<String>(logoUrl);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  CompaniesCompanion toCompanion(bool nullToAbsent) {
    return CompaniesCompanion(
      companyId: Value(companyId),
      companyName: Value(companyName),
      taxId: taxId == null && nullToAbsent
          ? const Value.absent()
          : Value(taxId),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      logoUrl: logoUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(logoUrl),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Company.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Company(
      companyId: serializer.fromJson<String>(json['companyId']),
      companyName: serializer.fromJson<String>(json['companyName']),
      taxId: serializer.fromJson<String?>(json['taxId']),
      address: serializer.fromJson<String?>(json['address']),
      phone: serializer.fromJson<String?>(json['phone']),
      logoUrl: serializer.fromJson<String?>(json['logoUrl']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'companyId': serializer.toJson<String>(companyId),
      'companyName': serializer.toJson<String>(companyName),
      'taxId': serializer.toJson<String?>(taxId),
      'address': serializer.toJson<String?>(address),
      'phone': serializer.toJson<String?>(phone),
      'logoUrl': serializer.toJson<String?>(logoUrl),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Company copyWith({
    String? companyId,
    String? companyName,
    Value<String?> taxId = const Value.absent(),
    Value<String?> address = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    Value<String?> logoUrl = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Company(
    companyId: companyId ?? this.companyId,
    companyName: companyName ?? this.companyName,
    taxId: taxId.present ? taxId.value : this.taxId,
    address: address.present ? address.value : this.address,
    phone: phone.present ? phone.value : this.phone,
    logoUrl: logoUrl.present ? logoUrl.value : this.logoUrl,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Company copyWithCompanion(CompaniesCompanion data) {
    return Company(
      companyId: data.companyId.present ? data.companyId.value : this.companyId,
      companyName: data.companyName.present
          ? data.companyName.value
          : this.companyName,
      taxId: data.taxId.present ? data.taxId.value : this.taxId,
      address: data.address.present ? data.address.value : this.address,
      phone: data.phone.present ? data.phone.value : this.phone,
      logoUrl: data.logoUrl.present ? data.logoUrl.value : this.logoUrl,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Company(')
          ..write('companyId: $companyId, ')
          ..write('companyName: $companyName, ')
          ..write('taxId: $taxId, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('logoUrl: $logoUrl, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    companyId,
    companyName,
    taxId,
    address,
    phone,
    logoUrl,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Company &&
          other.companyId == this.companyId &&
          other.companyName == this.companyName &&
          other.taxId == this.taxId &&
          other.address == this.address &&
          other.phone == this.phone &&
          other.logoUrl == this.logoUrl &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class CompaniesCompanion extends UpdateCompanion<Company> {
  final Value<String> companyId;
  final Value<String> companyName;
  final Value<String?> taxId;
  final Value<String?> address;
  final Value<String?> phone;
  final Value<String?> logoUrl;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const CompaniesCompanion({
    this.companyId = const Value.absent(),
    this.companyName = const Value.absent(),
    this.taxId = const Value.absent(),
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.logoUrl = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CompaniesCompanion.insert({
    required String companyId,
    required String companyName,
    this.taxId = const Value.absent(),
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.logoUrl = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : companyId = Value(companyId),
       companyName = Value(companyName);
  static Insertable<Company> custom({
    Expression<String>? companyId,
    Expression<String>? companyName,
    Expression<String>? taxId,
    Expression<String>? address,
    Expression<String>? phone,
    Expression<String>? logoUrl,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (companyId != null) 'company_id': companyId,
      if (companyName != null) 'company_name': companyName,
      if (taxId != null) 'tax_id': taxId,
      if (address != null) 'address': address,
      if (phone != null) 'phone': phone,
      if (logoUrl != null) 'logo_url': logoUrl,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CompaniesCompanion copyWith({
    Value<String>? companyId,
    Value<String>? companyName,
    Value<String?>? taxId,
    Value<String?>? address,
    Value<String?>? phone,
    Value<String?>? logoUrl,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return CompaniesCompanion(
      companyId: companyId ?? this.companyId,
      companyName: companyName ?? this.companyName,
      taxId: taxId ?? this.taxId,
      address: address ?? this.address,
      phone: phone ?? this.phone,
      logoUrl: logoUrl ?? this.logoUrl,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (companyId.present) {
      map['company_id'] = Variable<String>(companyId.value);
    }
    if (companyName.present) {
      map['company_name'] = Variable<String>(companyName.value);
    }
    if (taxId.present) {
      map['tax_id'] = Variable<String>(taxId.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (logoUrl.present) {
      map['logo_url'] = Variable<String>(logoUrl.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CompaniesCompanion(')
          ..write('companyId: $companyId, ')
          ..write('companyName: $companyName, ')
          ..write('taxId: $taxId, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('logoUrl: $logoUrl, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BranchesTable extends Branches with TableInfo<$BranchesTable, Branch> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BranchesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _companyIdMeta = const VerificationMeta(
    'companyId',
  );
  @override
  late final GeneratedColumn<String> companyId = GeneratedColumn<String>(
    'company_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES companies (company_id)',
    ),
  );
  static const VerificationMeta _branchCodeMeta = const VerificationMeta(
    'branchCode',
  );
  @override
  late final GeneratedColumn<String> branchCode = GeneratedColumn<String>(
    'branch_code',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 10),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _branchNameMeta = const VerificationMeta(
    'branchName',
  );
  @override
  late final GeneratedColumn<String> branchName = GeneratedColumn<String>(
    'branch_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _addressMeta = const VerificationMeta(
    'address',
  );
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    branchId,
    companyId,
    branchCode,
    branchName,
    address,
    phone,
    isActive,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'branches';
  @override
  VerificationContext validateIntegrity(
    Insertable<Branch> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    } else if (isInserting) {
      context.missing(_branchIdMeta);
    }
    if (data.containsKey('company_id')) {
      context.handle(
        _companyIdMeta,
        companyId.isAcceptableOrUnknown(data['company_id']!, _companyIdMeta),
      );
    } else if (isInserting) {
      context.missing(_companyIdMeta);
    }
    if (data.containsKey('branch_code')) {
      context.handle(
        _branchCodeMeta,
        branchCode.isAcceptableOrUnknown(data['branch_code']!, _branchCodeMeta),
      );
    } else if (isInserting) {
      context.missing(_branchCodeMeta);
    }
    if (data.containsKey('branch_name')) {
      context.handle(
        _branchNameMeta,
        branchName.isAcceptableOrUnknown(data['branch_name']!, _branchNameMeta),
      );
    } else if (isInserting) {
      context.missing(_branchNameMeta);
    }
    if (data.containsKey('address')) {
      context.handle(
        _addressMeta,
        address.isAcceptableOrUnknown(data['address']!, _addressMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {branchId};
  @override
  Branch map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Branch(
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      )!,
      companyId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}company_id'],
      )!,
      branchCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_code'],
      )!,
      branchName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_name'],
      )!,
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $BranchesTable createAlias(String alias) {
    return $BranchesTable(attachedDatabase, alias);
  }
}

class Branch extends DataClass implements Insertable<Branch> {
  final String branchId;
  final String companyId;
  final String branchCode;
  final String branchName;
  final String? address;
  final String? phone;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Branch({
    required this.branchId,
    required this.companyId,
    required this.branchCode,
    required this.branchName,
    this.address,
    this.phone,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['branch_id'] = Variable<String>(branchId);
    map['company_id'] = Variable<String>(companyId);
    map['branch_code'] = Variable<String>(branchCode);
    map['branch_name'] = Variable<String>(branchName);
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  BranchesCompanion toCompanion(bool nullToAbsent) {
    return BranchesCompanion(
      branchId: Value(branchId),
      companyId: Value(companyId),
      branchCode: Value(branchCode),
      branchName: Value(branchName),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Branch.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Branch(
      branchId: serializer.fromJson<String>(json['branchId']),
      companyId: serializer.fromJson<String>(json['companyId']),
      branchCode: serializer.fromJson<String>(json['branchCode']),
      branchName: serializer.fromJson<String>(json['branchName']),
      address: serializer.fromJson<String?>(json['address']),
      phone: serializer.fromJson<String?>(json['phone']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'branchId': serializer.toJson<String>(branchId),
      'companyId': serializer.toJson<String>(companyId),
      'branchCode': serializer.toJson<String>(branchCode),
      'branchName': serializer.toJson<String>(branchName),
      'address': serializer.toJson<String?>(address),
      'phone': serializer.toJson<String?>(phone),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Branch copyWith({
    String? branchId,
    String? companyId,
    String? branchCode,
    String? branchName,
    Value<String?> address = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Branch(
    branchId: branchId ?? this.branchId,
    companyId: companyId ?? this.companyId,
    branchCode: branchCode ?? this.branchCode,
    branchName: branchName ?? this.branchName,
    address: address.present ? address.value : this.address,
    phone: phone.present ? phone.value : this.phone,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Branch copyWithCompanion(BranchesCompanion data) {
    return Branch(
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      companyId: data.companyId.present ? data.companyId.value : this.companyId,
      branchCode: data.branchCode.present
          ? data.branchCode.value
          : this.branchCode,
      branchName: data.branchName.present
          ? data.branchName.value
          : this.branchName,
      address: data.address.present ? data.address.value : this.address,
      phone: data.phone.present ? data.phone.value : this.phone,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Branch(')
          ..write('branchId: $branchId, ')
          ..write('companyId: $companyId, ')
          ..write('branchCode: $branchCode, ')
          ..write('branchName: $branchName, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    branchId,
    companyId,
    branchCode,
    branchName,
    address,
    phone,
    isActive,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Branch &&
          other.branchId == this.branchId &&
          other.companyId == this.companyId &&
          other.branchCode == this.branchCode &&
          other.branchName == this.branchName &&
          other.address == this.address &&
          other.phone == this.phone &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class BranchesCompanion extends UpdateCompanion<Branch> {
  final Value<String> branchId;
  final Value<String> companyId;
  final Value<String> branchCode;
  final Value<String> branchName;
  final Value<String?> address;
  final Value<String?> phone;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const BranchesCompanion({
    this.branchId = const Value.absent(),
    this.companyId = const Value.absent(),
    this.branchCode = const Value.absent(),
    this.branchName = const Value.absent(),
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BranchesCompanion.insert({
    required String branchId,
    required String companyId,
    required String branchCode,
    required String branchName,
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : branchId = Value(branchId),
       companyId = Value(companyId),
       branchCode = Value(branchCode),
       branchName = Value(branchName);
  static Insertable<Branch> custom({
    Expression<String>? branchId,
    Expression<String>? companyId,
    Expression<String>? branchCode,
    Expression<String>? branchName,
    Expression<String>? address,
    Expression<String>? phone,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (branchId != null) 'branch_id': branchId,
      if (companyId != null) 'company_id': companyId,
      if (branchCode != null) 'branch_code': branchCode,
      if (branchName != null) 'branch_name': branchName,
      if (address != null) 'address': address,
      if (phone != null) 'phone': phone,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BranchesCompanion copyWith({
    Value<String>? branchId,
    Value<String>? companyId,
    Value<String>? branchCode,
    Value<String>? branchName,
    Value<String?>? address,
    Value<String?>? phone,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return BranchesCompanion(
      branchId: branchId ?? this.branchId,
      companyId: companyId ?? this.companyId,
      branchCode: branchCode ?? this.branchCode,
      branchName: branchName ?? this.branchName,
      address: address ?? this.address,
      phone: phone ?? this.phone,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (companyId.present) {
      map['company_id'] = Variable<String>(companyId.value);
    }
    if (branchCode.present) {
      map['branch_code'] = Variable<String>(branchCode.value);
    }
    if (branchName.present) {
      map['branch_name'] = Variable<String>(branchName.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BranchesCompanion(')
          ..write('branchId: $branchId, ')
          ..write('companyId: $companyId, ')
          ..write('branchCode: $branchCode, ')
          ..write('branchName: $branchName, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $RolesTable extends Roles with TableInfo<$RolesTable, Role> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RolesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _roleIdMeta = const VerificationMeta('roleId');
  @override
  late final GeneratedColumn<String> roleId = GeneratedColumn<String>(
    'role_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _roleNameMeta = const VerificationMeta(
    'roleName',
  );
  @override
  late final GeneratedColumn<String> roleName = GeneratedColumn<String>(
    'role_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>, String>
  permissions = GeneratedColumn<String>(
    'permissions',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  ).withConverter<Map<String, dynamic>>($RolesTable.$converterpermissions);
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    roleId,
    roleName,
    permissions,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'roles';
  @override
  VerificationContext validateIntegrity(
    Insertable<Role> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('role_id')) {
      context.handle(
        _roleIdMeta,
        roleId.isAcceptableOrUnknown(data['role_id']!, _roleIdMeta),
      );
    } else if (isInserting) {
      context.missing(_roleIdMeta);
    }
    if (data.containsKey('role_name')) {
      context.handle(
        _roleNameMeta,
        roleName.isAcceptableOrUnknown(data['role_name']!, _roleNameMeta),
      );
    } else if (isInserting) {
      context.missing(_roleNameMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {roleId};
  @override
  Role map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Role(
      roleId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}role_id'],
      )!,
      roleName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}role_name'],
      )!,
      permissions: $RolesTable.$converterpermissions.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}permissions'],
        )!,
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $RolesTable createAlias(String alias) {
    return $RolesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $converterpermissions =
      const JsonConverter();
}

class Role extends DataClass implements Insertable<Role> {
  final String roleId;
  final String roleName;
  final Map<String, dynamic> permissions;
  final DateTime createdAt;
  const Role({
    required this.roleId,
    required this.roleName,
    required this.permissions,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['role_id'] = Variable<String>(roleId);
    map['role_name'] = Variable<String>(roleName);
    {
      map['permissions'] = Variable<String>(
        $RolesTable.$converterpermissions.toSql(permissions),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  RolesCompanion toCompanion(bool nullToAbsent) {
    return RolesCompanion(
      roleId: Value(roleId),
      roleName: Value(roleName),
      permissions: Value(permissions),
      createdAt: Value(createdAt),
    );
  }

  factory Role.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Role(
      roleId: serializer.fromJson<String>(json['roleId']),
      roleName: serializer.fromJson<String>(json['roleName']),
      permissions: serializer.fromJson<Map<String, dynamic>>(
        json['permissions'],
      ),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'roleId': serializer.toJson<String>(roleId),
      'roleName': serializer.toJson<String>(roleName),
      'permissions': serializer.toJson<Map<String, dynamic>>(permissions),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Role copyWith({
    String? roleId,
    String? roleName,
    Map<String, dynamic>? permissions,
    DateTime? createdAt,
  }) => Role(
    roleId: roleId ?? this.roleId,
    roleName: roleName ?? this.roleName,
    permissions: permissions ?? this.permissions,
    createdAt: createdAt ?? this.createdAt,
  );
  Role copyWithCompanion(RolesCompanion data) {
    return Role(
      roleId: data.roleId.present ? data.roleId.value : this.roleId,
      roleName: data.roleName.present ? data.roleName.value : this.roleName,
      permissions: data.permissions.present
          ? data.permissions.value
          : this.permissions,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Role(')
          ..write('roleId: $roleId, ')
          ..write('roleName: $roleName, ')
          ..write('permissions: $permissions, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(roleId, roleName, permissions, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Role &&
          other.roleId == this.roleId &&
          other.roleName == this.roleName &&
          other.permissions == this.permissions &&
          other.createdAt == this.createdAt);
}

class RolesCompanion extends UpdateCompanion<Role> {
  final Value<String> roleId;
  final Value<String> roleName;
  final Value<Map<String, dynamic>> permissions;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const RolesCompanion({
    this.roleId = const Value.absent(),
    this.roleName = const Value.absent(),
    this.permissions = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  RolesCompanion.insert({
    required String roleId,
    required String roleName,
    required Map<String, dynamic> permissions,
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : roleId = Value(roleId),
       roleName = Value(roleName),
       permissions = Value(permissions);
  static Insertable<Role> custom({
    Expression<String>? roleId,
    Expression<String>? roleName,
    Expression<String>? permissions,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (roleId != null) 'role_id': roleId,
      if (roleName != null) 'role_name': roleName,
      if (permissions != null) 'permissions': permissions,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  RolesCompanion copyWith({
    Value<String>? roleId,
    Value<String>? roleName,
    Value<Map<String, dynamic>>? permissions,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return RolesCompanion(
      roleId: roleId ?? this.roleId,
      roleName: roleName ?? this.roleName,
      permissions: permissions ?? this.permissions,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (roleId.present) {
      map['role_id'] = Variable<String>(roleId.value);
    }
    if (roleName.present) {
      map['role_name'] = Variable<String>(roleName.value);
    }
    if (permissions.present) {
      map['permissions'] = Variable<String>(
        $RolesTable.$converterpermissions.toSql(permissions.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RolesCompanion(')
          ..write('roleId: $roleId, ')
          ..write('roleName: $roleName, ')
          ..write('permissions: $permissions, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UsersTable extends Users with TableInfo<$UsersTable, User> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UsersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _usernameMeta = const VerificationMeta(
    'username',
  );
  @override
  late final GeneratedColumn<String> username = GeneratedColumn<String>(
    'username',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _passwordHashMeta = const VerificationMeta(
    'passwordHash',
  );
  @override
  late final GeneratedColumn<String> passwordHash = GeneratedColumn<String>(
    'password_hash',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 255),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _fullNameMeta = const VerificationMeta(
    'fullName',
  );
  @override
  late final GeneratedColumn<String> fullName = GeneratedColumn<String>(
    'full_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
    'email',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _roleIdMeta = const VerificationMeta('roleId');
  @override
  late final GeneratedColumn<String> roleId = GeneratedColumn<String>(
    'role_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES roles (role_id)',
    ),
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES branches (branch_id)',
    ),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _lastLoginMeta = const VerificationMeta(
    'lastLogin',
  );
  @override
  late final GeneratedColumn<DateTime> lastLogin = GeneratedColumn<DateTime>(
    'last_login',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    userId,
    username,
    passwordHash,
    fullName,
    email,
    phone,
    roleId,
    branchId,
    isActive,
    lastLogin,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'users';
  @override
  VerificationContext validateIntegrity(
    Insertable<User> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('username')) {
      context.handle(
        _usernameMeta,
        username.isAcceptableOrUnknown(data['username']!, _usernameMeta),
      );
    } else if (isInserting) {
      context.missing(_usernameMeta);
    }
    if (data.containsKey('password_hash')) {
      context.handle(
        _passwordHashMeta,
        passwordHash.isAcceptableOrUnknown(
          data['password_hash']!,
          _passwordHashMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_passwordHashMeta);
    }
    if (data.containsKey('full_name')) {
      context.handle(
        _fullNameMeta,
        fullName.isAcceptableOrUnknown(data['full_name']!, _fullNameMeta),
      );
    } else if (isInserting) {
      context.missing(_fullNameMeta);
    }
    if (data.containsKey('email')) {
      context.handle(
        _emailMeta,
        email.isAcceptableOrUnknown(data['email']!, _emailMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('role_id')) {
      context.handle(
        _roleIdMeta,
        roleId.isAcceptableOrUnknown(data['role_id']!, _roleIdMeta),
      );
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('last_login')) {
      context.handle(
        _lastLoginMeta,
        lastLogin.isAcceptableOrUnknown(data['last_login']!, _lastLoginMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {userId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {username},
  ];
  @override
  User map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return User(
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      username: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}username'],
      )!,
      passwordHash: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}password_hash'],
      )!,
      fullName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}full_name'],
      )!,
      email: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}email'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      roleId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}role_id'],
      ),
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      lastLogin: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_login'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $UsersTable createAlias(String alias) {
    return $UsersTable(attachedDatabase, alias);
  }
}

class User extends DataClass implements Insertable<User> {
  final String userId;
  final String username;
  final String passwordHash;
  final String fullName;
  final String? email;
  final String? phone;
  final String? roleId;
  final String? branchId;
  final bool isActive;
  final DateTime? lastLogin;
  final DateTime createdAt;
  final DateTime updatedAt;
  const User({
    required this.userId,
    required this.username,
    required this.passwordHash,
    required this.fullName,
    this.email,
    this.phone,
    this.roleId,
    this.branchId,
    required this.isActive,
    this.lastLogin,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['user_id'] = Variable<String>(userId);
    map['username'] = Variable<String>(username);
    map['password_hash'] = Variable<String>(passwordHash);
    map['full_name'] = Variable<String>(fullName);
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || roleId != null) {
      map['role_id'] = Variable<String>(roleId);
    }
    if (!nullToAbsent || branchId != null) {
      map['branch_id'] = Variable<String>(branchId);
    }
    map['is_active'] = Variable<bool>(isActive);
    if (!nullToAbsent || lastLogin != null) {
      map['last_login'] = Variable<DateTime>(lastLogin);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  UsersCompanion toCompanion(bool nullToAbsent) {
    return UsersCompanion(
      userId: Value(userId),
      username: Value(username),
      passwordHash: Value(passwordHash),
      fullName: Value(fullName),
      email: email == null && nullToAbsent
          ? const Value.absent()
          : Value(email),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      roleId: roleId == null && nullToAbsent
          ? const Value.absent()
          : Value(roleId),
      branchId: branchId == null && nullToAbsent
          ? const Value.absent()
          : Value(branchId),
      isActive: Value(isActive),
      lastLogin: lastLogin == null && nullToAbsent
          ? const Value.absent()
          : Value(lastLogin),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory User.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return User(
      userId: serializer.fromJson<String>(json['userId']),
      username: serializer.fromJson<String>(json['username']),
      passwordHash: serializer.fromJson<String>(json['passwordHash']),
      fullName: serializer.fromJson<String>(json['fullName']),
      email: serializer.fromJson<String?>(json['email']),
      phone: serializer.fromJson<String?>(json['phone']),
      roleId: serializer.fromJson<String?>(json['roleId']),
      branchId: serializer.fromJson<String?>(json['branchId']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      lastLogin: serializer.fromJson<DateTime?>(json['lastLogin']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'userId': serializer.toJson<String>(userId),
      'username': serializer.toJson<String>(username),
      'passwordHash': serializer.toJson<String>(passwordHash),
      'fullName': serializer.toJson<String>(fullName),
      'email': serializer.toJson<String?>(email),
      'phone': serializer.toJson<String?>(phone),
      'roleId': serializer.toJson<String?>(roleId),
      'branchId': serializer.toJson<String?>(branchId),
      'isActive': serializer.toJson<bool>(isActive),
      'lastLogin': serializer.toJson<DateTime?>(lastLogin),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  User copyWith({
    String? userId,
    String? username,
    String? passwordHash,
    String? fullName,
    Value<String?> email = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    Value<String?> roleId = const Value.absent(),
    Value<String?> branchId = const Value.absent(),
    bool? isActive,
    Value<DateTime?> lastLogin = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => User(
    userId: userId ?? this.userId,
    username: username ?? this.username,
    passwordHash: passwordHash ?? this.passwordHash,
    fullName: fullName ?? this.fullName,
    email: email.present ? email.value : this.email,
    phone: phone.present ? phone.value : this.phone,
    roleId: roleId.present ? roleId.value : this.roleId,
    branchId: branchId.present ? branchId.value : this.branchId,
    isActive: isActive ?? this.isActive,
    lastLogin: lastLogin.present ? lastLogin.value : this.lastLogin,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  User copyWithCompanion(UsersCompanion data) {
    return User(
      userId: data.userId.present ? data.userId.value : this.userId,
      username: data.username.present ? data.username.value : this.username,
      passwordHash: data.passwordHash.present
          ? data.passwordHash.value
          : this.passwordHash,
      fullName: data.fullName.present ? data.fullName.value : this.fullName,
      email: data.email.present ? data.email.value : this.email,
      phone: data.phone.present ? data.phone.value : this.phone,
      roleId: data.roleId.present ? data.roleId.value : this.roleId,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      lastLogin: data.lastLogin.present ? data.lastLogin.value : this.lastLogin,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('User(')
          ..write('userId: $userId, ')
          ..write('username: $username, ')
          ..write('passwordHash: $passwordHash, ')
          ..write('fullName: $fullName, ')
          ..write('email: $email, ')
          ..write('phone: $phone, ')
          ..write('roleId: $roleId, ')
          ..write('branchId: $branchId, ')
          ..write('isActive: $isActive, ')
          ..write('lastLogin: $lastLogin, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    userId,
    username,
    passwordHash,
    fullName,
    email,
    phone,
    roleId,
    branchId,
    isActive,
    lastLogin,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User &&
          other.userId == this.userId &&
          other.username == this.username &&
          other.passwordHash == this.passwordHash &&
          other.fullName == this.fullName &&
          other.email == this.email &&
          other.phone == this.phone &&
          other.roleId == this.roleId &&
          other.branchId == this.branchId &&
          other.isActive == this.isActive &&
          other.lastLogin == this.lastLogin &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class UsersCompanion extends UpdateCompanion<User> {
  final Value<String> userId;
  final Value<String> username;
  final Value<String> passwordHash;
  final Value<String> fullName;
  final Value<String?> email;
  final Value<String?> phone;
  final Value<String?> roleId;
  final Value<String?> branchId;
  final Value<bool> isActive;
  final Value<DateTime?> lastLogin;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const UsersCompanion({
    this.userId = const Value.absent(),
    this.username = const Value.absent(),
    this.passwordHash = const Value.absent(),
    this.fullName = const Value.absent(),
    this.email = const Value.absent(),
    this.phone = const Value.absent(),
    this.roleId = const Value.absent(),
    this.branchId = const Value.absent(),
    this.isActive = const Value.absent(),
    this.lastLogin = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UsersCompanion.insert({
    required String userId,
    required String username,
    required String passwordHash,
    required String fullName,
    this.email = const Value.absent(),
    this.phone = const Value.absent(),
    this.roleId = const Value.absent(),
    this.branchId = const Value.absent(),
    this.isActive = const Value.absent(),
    this.lastLogin = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : userId = Value(userId),
       username = Value(username),
       passwordHash = Value(passwordHash),
       fullName = Value(fullName);
  static Insertable<User> custom({
    Expression<String>? userId,
    Expression<String>? username,
    Expression<String>? passwordHash,
    Expression<String>? fullName,
    Expression<String>? email,
    Expression<String>? phone,
    Expression<String>? roleId,
    Expression<String>? branchId,
    Expression<bool>? isActive,
    Expression<DateTime>? lastLogin,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (userId != null) 'user_id': userId,
      if (username != null) 'username': username,
      if (passwordHash != null) 'password_hash': passwordHash,
      if (fullName != null) 'full_name': fullName,
      if (email != null) 'email': email,
      if (phone != null) 'phone': phone,
      if (roleId != null) 'role_id': roleId,
      if (branchId != null) 'branch_id': branchId,
      if (isActive != null) 'is_active': isActive,
      if (lastLogin != null) 'last_login': lastLogin,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UsersCompanion copyWith({
    Value<String>? userId,
    Value<String>? username,
    Value<String>? passwordHash,
    Value<String>? fullName,
    Value<String?>? email,
    Value<String?>? phone,
    Value<String?>? roleId,
    Value<String?>? branchId,
    Value<bool>? isActive,
    Value<DateTime?>? lastLogin,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return UsersCompanion(
      userId: userId ?? this.userId,
      username: username ?? this.username,
      passwordHash: passwordHash ?? this.passwordHash,
      fullName: fullName ?? this.fullName,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      roleId: roleId ?? this.roleId,
      branchId: branchId ?? this.branchId,
      isActive: isActive ?? this.isActive,
      lastLogin: lastLogin ?? this.lastLogin,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (username.present) {
      map['username'] = Variable<String>(username.value);
    }
    if (passwordHash.present) {
      map['password_hash'] = Variable<String>(passwordHash.value);
    }
    if (fullName.present) {
      map['full_name'] = Variable<String>(fullName.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (roleId.present) {
      map['role_id'] = Variable<String>(roleId.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (lastLogin.present) {
      map['last_login'] = Variable<DateTime>(lastLogin.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UsersCompanion(')
          ..write('userId: $userId, ')
          ..write('username: $username, ')
          ..write('passwordHash: $passwordHash, ')
          ..write('fullName: $fullName, ')
          ..write('email: $email, ')
          ..write('phone: $phone, ')
          ..write('roleId: $roleId, ')
          ..write('branchId: $branchId, ')
          ..write('isActive: $isActive, ')
          ..write('lastLogin: $lastLogin, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProductGroupsTable extends ProductGroups
    with TableInfo<$ProductGroupsTable, ProductGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _groupIdMeta = const VerificationMeta(
    'groupId',
  );
  @override
  late final GeneratedColumn<String> groupId = GeneratedColumn<String>(
    'group_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _groupCodeMeta = const VerificationMeta(
    'groupCode',
  );
  @override
  late final GeneratedColumn<String> groupCode = GeneratedColumn<String>(
    'group_code',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _groupNameMeta = const VerificationMeta(
    'groupName',
  );
  @override
  late final GeneratedColumn<String> groupName = GeneratedColumn<String>(
    'group_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentGroupIdMeta = const VerificationMeta(
    'parentGroupId',
  );
  @override
  late final GeneratedColumn<String> parentGroupId = GeneratedColumn<String>(
    'parent_group_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _groupTypeMeta = const VerificationMeta(
    'groupType',
  );
  @override
  late final GeneratedColumn<String> groupType = GeneratedColumn<String>(
    'group_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('GENERAL'),
  );
  static const VerificationMeta _imageUrlMeta = const VerificationMeta(
    'imageUrl',
  );
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
    'image_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _displayOrderMeta = const VerificationMeta(
    'displayOrder',
  );
  @override
  late final GeneratedColumn<int> displayOrder = GeneratedColumn<int>(
    'display_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    groupId,
    groupCode,
    groupName,
    parentGroupId,
    groupType,
    imageUrl,
    displayOrder,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'product_groups';
  @override
  VerificationContext validateIntegrity(
    Insertable<ProductGroup> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('group_id')) {
      context.handle(
        _groupIdMeta,
        groupId.isAcceptableOrUnknown(data['group_id']!, _groupIdMeta),
      );
    } else if (isInserting) {
      context.missing(_groupIdMeta);
    }
    if (data.containsKey('group_code')) {
      context.handle(
        _groupCodeMeta,
        groupCode.isAcceptableOrUnknown(data['group_code']!, _groupCodeMeta),
      );
    } else if (isInserting) {
      context.missing(_groupCodeMeta);
    }
    if (data.containsKey('group_name')) {
      context.handle(
        _groupNameMeta,
        groupName.isAcceptableOrUnknown(data['group_name']!, _groupNameMeta),
      );
    } else if (isInserting) {
      context.missing(_groupNameMeta);
    }
    if (data.containsKey('parent_group_id')) {
      context.handle(
        _parentGroupIdMeta,
        parentGroupId.isAcceptableOrUnknown(
          data['parent_group_id']!,
          _parentGroupIdMeta,
        ),
      );
    }
    if (data.containsKey('group_type')) {
      context.handle(
        _groupTypeMeta,
        groupType.isAcceptableOrUnknown(data['group_type']!, _groupTypeMeta),
      );
    }
    if (data.containsKey('image_url')) {
      context.handle(
        _imageUrlMeta,
        imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta),
      );
    }
    if (data.containsKey('display_order')) {
      context.handle(
        _displayOrderMeta,
        displayOrder.isAcceptableOrUnknown(
          data['display_order']!,
          _displayOrderMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {groupId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {groupCode},
  ];
  @override
  ProductGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProductGroup(
      groupId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}group_id'],
      )!,
      groupCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}group_code'],
      )!,
      groupName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}group_name'],
      )!,
      parentGroupId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_group_id'],
      ),
      groupType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}group_type'],
      )!,
      imageUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_url'],
      ),
      displayOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}display_order'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ProductGroupsTable createAlias(String alias) {
    return $ProductGroupsTable(attachedDatabase, alias);
  }
}

class ProductGroup extends DataClass implements Insertable<ProductGroup> {
  final String groupId;
  final String groupCode;
  final String groupName;
  final String? parentGroupId;
  final String groupType;
  final String? imageUrl;
  final int displayOrder;
  final DateTime createdAt;
  const ProductGroup({
    required this.groupId,
    required this.groupCode,
    required this.groupName,
    this.parentGroupId,
    required this.groupType,
    this.imageUrl,
    required this.displayOrder,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['group_id'] = Variable<String>(groupId);
    map['group_code'] = Variable<String>(groupCode);
    map['group_name'] = Variable<String>(groupName);
    if (!nullToAbsent || parentGroupId != null) {
      map['parent_group_id'] = Variable<String>(parentGroupId);
    }
    map['group_type'] = Variable<String>(groupType);
    if (!nullToAbsent || imageUrl != null) {
      map['image_url'] = Variable<String>(imageUrl);
    }
    map['display_order'] = Variable<int>(displayOrder);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ProductGroupsCompanion toCompanion(bool nullToAbsent) {
    return ProductGroupsCompanion(
      groupId: Value(groupId),
      groupCode: Value(groupCode),
      groupName: Value(groupName),
      parentGroupId: parentGroupId == null && nullToAbsent
          ? const Value.absent()
          : Value(parentGroupId),
      groupType: Value(groupType),
      imageUrl: imageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(imageUrl),
      displayOrder: Value(displayOrder),
      createdAt: Value(createdAt),
    );
  }

  factory ProductGroup.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProductGroup(
      groupId: serializer.fromJson<String>(json['groupId']),
      groupCode: serializer.fromJson<String>(json['groupCode']),
      groupName: serializer.fromJson<String>(json['groupName']),
      parentGroupId: serializer.fromJson<String?>(json['parentGroupId']),
      groupType: serializer.fromJson<String>(json['groupType']),
      imageUrl: serializer.fromJson<String?>(json['imageUrl']),
      displayOrder: serializer.fromJson<int>(json['displayOrder']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'groupId': serializer.toJson<String>(groupId),
      'groupCode': serializer.toJson<String>(groupCode),
      'groupName': serializer.toJson<String>(groupName),
      'parentGroupId': serializer.toJson<String?>(parentGroupId),
      'groupType': serializer.toJson<String>(groupType),
      'imageUrl': serializer.toJson<String?>(imageUrl),
      'displayOrder': serializer.toJson<int>(displayOrder),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  ProductGroup copyWith({
    String? groupId,
    String? groupCode,
    String? groupName,
    Value<String?> parentGroupId = const Value.absent(),
    String? groupType,
    Value<String?> imageUrl = const Value.absent(),
    int? displayOrder,
    DateTime? createdAt,
  }) => ProductGroup(
    groupId: groupId ?? this.groupId,
    groupCode: groupCode ?? this.groupCode,
    groupName: groupName ?? this.groupName,
    parentGroupId: parentGroupId.present
        ? parentGroupId.value
        : this.parentGroupId,
    groupType: groupType ?? this.groupType,
    imageUrl: imageUrl.present ? imageUrl.value : this.imageUrl,
    displayOrder: displayOrder ?? this.displayOrder,
    createdAt: createdAt ?? this.createdAt,
  );
  ProductGroup copyWithCompanion(ProductGroupsCompanion data) {
    return ProductGroup(
      groupId: data.groupId.present ? data.groupId.value : this.groupId,
      groupCode: data.groupCode.present ? data.groupCode.value : this.groupCode,
      groupName: data.groupName.present ? data.groupName.value : this.groupName,
      parentGroupId: data.parentGroupId.present
          ? data.parentGroupId.value
          : this.parentGroupId,
      groupType: data.groupType.present ? data.groupType.value : this.groupType,
      imageUrl: data.imageUrl.present ? data.imageUrl.value : this.imageUrl,
      displayOrder: data.displayOrder.present
          ? data.displayOrder.value
          : this.displayOrder,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ProductGroup(')
          ..write('groupId: $groupId, ')
          ..write('groupCode: $groupCode, ')
          ..write('groupName: $groupName, ')
          ..write('parentGroupId: $parentGroupId, ')
          ..write('groupType: $groupType, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    groupId,
    groupCode,
    groupName,
    parentGroupId,
    groupType,
    imageUrl,
    displayOrder,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProductGroup &&
          other.groupId == this.groupId &&
          other.groupCode == this.groupCode &&
          other.groupName == this.groupName &&
          other.parentGroupId == this.parentGroupId &&
          other.groupType == this.groupType &&
          other.imageUrl == this.imageUrl &&
          other.displayOrder == this.displayOrder &&
          other.createdAt == this.createdAt);
}

class ProductGroupsCompanion extends UpdateCompanion<ProductGroup> {
  final Value<String> groupId;
  final Value<String> groupCode;
  final Value<String> groupName;
  final Value<String?> parentGroupId;
  final Value<String> groupType;
  final Value<String?> imageUrl;
  final Value<int> displayOrder;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ProductGroupsCompanion({
    this.groupId = const Value.absent(),
    this.groupCode = const Value.absent(),
    this.groupName = const Value.absent(),
    this.parentGroupId = const Value.absent(),
    this.groupType = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.displayOrder = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProductGroupsCompanion.insert({
    required String groupId,
    required String groupCode,
    required String groupName,
    this.parentGroupId = const Value.absent(),
    this.groupType = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.displayOrder = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : groupId = Value(groupId),
       groupCode = Value(groupCode),
       groupName = Value(groupName);
  static Insertable<ProductGroup> custom({
    Expression<String>? groupId,
    Expression<String>? groupCode,
    Expression<String>? groupName,
    Expression<String>? parentGroupId,
    Expression<String>? groupType,
    Expression<String>? imageUrl,
    Expression<int>? displayOrder,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (groupId != null) 'group_id': groupId,
      if (groupCode != null) 'group_code': groupCode,
      if (groupName != null) 'group_name': groupName,
      if (parentGroupId != null) 'parent_group_id': parentGroupId,
      if (groupType != null) 'group_type': groupType,
      if (imageUrl != null) 'image_url': imageUrl,
      if (displayOrder != null) 'display_order': displayOrder,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProductGroupsCompanion copyWith({
    Value<String>? groupId,
    Value<String>? groupCode,
    Value<String>? groupName,
    Value<String?>? parentGroupId,
    Value<String>? groupType,
    Value<String?>? imageUrl,
    Value<int>? displayOrder,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ProductGroupsCompanion(
      groupId: groupId ?? this.groupId,
      groupCode: groupCode ?? this.groupCode,
      groupName: groupName ?? this.groupName,
      parentGroupId: parentGroupId ?? this.parentGroupId,
      groupType: groupType ?? this.groupType,
      imageUrl: imageUrl ?? this.imageUrl,
      displayOrder: displayOrder ?? this.displayOrder,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (groupId.present) {
      map['group_id'] = Variable<String>(groupId.value);
    }
    if (groupCode.present) {
      map['group_code'] = Variable<String>(groupCode.value);
    }
    if (groupName.present) {
      map['group_name'] = Variable<String>(groupName.value);
    }
    if (parentGroupId.present) {
      map['parent_group_id'] = Variable<String>(parentGroupId.value);
    }
    if (groupType.present) {
      map['group_type'] = Variable<String>(groupType.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (displayOrder.present) {
      map['display_order'] = Variable<int>(displayOrder.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductGroupsCompanion(')
          ..write('groupId: $groupId, ')
          ..write('groupCode: $groupCode, ')
          ..write('groupName: $groupName, ')
          ..write('parentGroupId: $parentGroupId, ')
          ..write('groupType: $groupType, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProductsTable extends Products with TableInfo<$ProductsTable, Product> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productCodeMeta = const VerificationMeta(
    'productCode',
  );
  @override
  late final GeneratedColumn<String> productCode = GeneratedColumn<String>(
    'product_code',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _barcodeMeta = const VerificationMeta(
    'barcode',
  );
  @override
  late final GeneratedColumn<String> barcode = GeneratedColumn<String>(
    'barcode',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _productNameMeta = const VerificationMeta(
    'productName',
  );
  @override
  late final GeneratedColumn<String> productName = GeneratedColumn<String>(
    'product_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 500),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productNameEnMeta = const VerificationMeta(
    'productNameEn',
  );
  @override
  late final GeneratedColumn<String> productNameEn = GeneratedColumn<String>(
    'product_name_en',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 500),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _groupIdMeta = const VerificationMeta(
    'groupId',
  );
  @override
  late final GeneratedColumn<String> groupId = GeneratedColumn<String>(
    'group_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES product_groups (group_id)',
    ),
  );
  static const VerificationMeta _brandMeta = const VerificationMeta('brand');
  @override
  late final GeneratedColumn<String> brand = GeneratedColumn<String>(
    'brand',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _modelMeta = const VerificationMeta('model');
  @override
  late final GeneratedColumn<String> model = GeneratedColumn<String>(
    'model',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _colorMeta = const VerificationMeta('color');
  @override
  late final GeneratedColumn<String> color = GeneratedColumn<String>(
    'color',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _baseUnitMeta = const VerificationMeta(
    'baseUnit',
  );
  @override
  late final GeneratedColumn<String> baseUnit = GeneratedColumn<String>(
    'base_unit',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  unitConversion =
      GeneratedColumn<String>(
        'unit_conversion',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Map<String, dynamic>?>(
        $ProductsTable.$converterunitConversionn,
      );
  static const VerificationMeta _priceLevel1Meta = const VerificationMeta(
    'priceLevel1',
  );
  @override
  late final GeneratedColumn<double> priceLevel1 = GeneratedColumn<double>(
    'price_level1',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _priceLevel2Meta = const VerificationMeta(
    'priceLevel2',
  );
  @override
  late final GeneratedColumn<double> priceLevel2 = GeneratedColumn<double>(
    'price_level2',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _priceLevel3Meta = const VerificationMeta(
    'priceLevel3',
  );
  @override
  late final GeneratedColumn<double> priceLevel3 = GeneratedColumn<double>(
    'price_level3',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _priceLevel4Meta = const VerificationMeta(
    'priceLevel4',
  );
  @override
  late final GeneratedColumn<double> priceLevel4 = GeneratedColumn<double>(
    'price_level4',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _priceLevel5Meta = const VerificationMeta(
    'priceLevel5',
  );
  @override
  late final GeneratedColumn<double> priceLevel5 = GeneratedColumn<double>(
    'price_level5',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _costMethodMeta = const VerificationMeta(
    'costMethod',
  );
  @override
  late final GeneratedColumn<String> costMethod = GeneratedColumn<String>(
    'cost_method',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('AVG'),
  );
  static const VerificationMeta _standardCostMeta = const VerificationMeta(
    'standardCost',
  );
  @override
  late final GeneratedColumn<double> standardCost = GeneratedColumn<double>(
    'standard_cost',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isStockControlMeta = const VerificationMeta(
    'isStockControl',
  );
  @override
  late final GeneratedColumn<bool> isStockControl = GeneratedColumn<bool>(
    'is_stock_control',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_stock_control" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _isSerialControlMeta = const VerificationMeta(
    'isSerialControl',
  );
  @override
  late final GeneratedColumn<bool> isSerialControl = GeneratedColumn<bool>(
    'is_serial_control',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_serial_control" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _allowNegativeStockMeta =
      const VerificationMeta('allowNegativeStock');
  @override
  late final GeneratedColumn<bool> allowNegativeStock = GeneratedColumn<bool>(
    'allow_negative_stock',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("allow_negative_stock" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _reorderPointMeta = const VerificationMeta(
    'reorderPoint',
  );
  @override
  late final GeneratedColumn<double> reorderPoint = GeneratedColumn<double>(
    'reorder_point',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _vatTypeMeta = const VerificationMeta(
    'vatType',
  );
  @override
  late final GeneratedColumn<String> vatType = GeneratedColumn<String>(
    'vat_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('I'),
  );
  static const VerificationMeta _vatRateMeta = const VerificationMeta(
    'vatRate',
  );
  @override
  late final GeneratedColumn<double> vatRate = GeneratedColumn<double>(
    'vat_rate',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(7.00),
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  imageUrls = GeneratedColumn<String>(
    'image_urls',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($ProductsTable.$converterimageUrlsn);
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    productId,
    productCode,
    barcode,
    productName,
    productNameEn,
    groupId,
    brand,
    model,
    color,
    baseUnit,
    unitConversion,
    priceLevel1,
    priceLevel2,
    priceLevel3,
    priceLevel4,
    priceLevel5,
    costMethod,
    standardCost,
    isStockControl,
    isSerialControl,
    allowNegativeStock,
    reorderPoint,
    vatType,
    vatRate,
    imageUrls,
    isActive,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'products';
  @override
  VerificationContext validateIntegrity(
    Insertable<Product> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('product_code')) {
      context.handle(
        _productCodeMeta,
        productCode.isAcceptableOrUnknown(
          data['product_code']!,
          _productCodeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_productCodeMeta);
    }
    if (data.containsKey('barcode')) {
      context.handle(
        _barcodeMeta,
        barcode.isAcceptableOrUnknown(data['barcode']!, _barcodeMeta),
      );
    }
    if (data.containsKey('product_name')) {
      context.handle(
        _productNameMeta,
        productName.isAcceptableOrUnknown(
          data['product_name']!,
          _productNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_productNameMeta);
    }
    if (data.containsKey('product_name_en')) {
      context.handle(
        _productNameEnMeta,
        productNameEn.isAcceptableOrUnknown(
          data['product_name_en']!,
          _productNameEnMeta,
        ),
      );
    }
    if (data.containsKey('group_id')) {
      context.handle(
        _groupIdMeta,
        groupId.isAcceptableOrUnknown(data['group_id']!, _groupIdMeta),
      );
    }
    if (data.containsKey('brand')) {
      context.handle(
        _brandMeta,
        brand.isAcceptableOrUnknown(data['brand']!, _brandMeta),
      );
    }
    if (data.containsKey('model')) {
      context.handle(
        _modelMeta,
        model.isAcceptableOrUnknown(data['model']!, _modelMeta),
      );
    }
    if (data.containsKey('color')) {
      context.handle(
        _colorMeta,
        color.isAcceptableOrUnknown(data['color']!, _colorMeta),
      );
    }
    if (data.containsKey('base_unit')) {
      context.handle(
        _baseUnitMeta,
        baseUnit.isAcceptableOrUnknown(data['base_unit']!, _baseUnitMeta),
      );
    } else if (isInserting) {
      context.missing(_baseUnitMeta);
    }
    if (data.containsKey('price_level1')) {
      context.handle(
        _priceLevel1Meta,
        priceLevel1.isAcceptableOrUnknown(
          data['price_level1']!,
          _priceLevel1Meta,
        ),
      );
    }
    if (data.containsKey('price_level2')) {
      context.handle(
        _priceLevel2Meta,
        priceLevel2.isAcceptableOrUnknown(
          data['price_level2']!,
          _priceLevel2Meta,
        ),
      );
    }
    if (data.containsKey('price_level3')) {
      context.handle(
        _priceLevel3Meta,
        priceLevel3.isAcceptableOrUnknown(
          data['price_level3']!,
          _priceLevel3Meta,
        ),
      );
    }
    if (data.containsKey('price_level4')) {
      context.handle(
        _priceLevel4Meta,
        priceLevel4.isAcceptableOrUnknown(
          data['price_level4']!,
          _priceLevel4Meta,
        ),
      );
    }
    if (data.containsKey('price_level5')) {
      context.handle(
        _priceLevel5Meta,
        priceLevel5.isAcceptableOrUnknown(
          data['price_level5']!,
          _priceLevel5Meta,
        ),
      );
    }
    if (data.containsKey('cost_method')) {
      context.handle(
        _costMethodMeta,
        costMethod.isAcceptableOrUnknown(data['cost_method']!, _costMethodMeta),
      );
    }
    if (data.containsKey('standard_cost')) {
      context.handle(
        _standardCostMeta,
        standardCost.isAcceptableOrUnknown(
          data['standard_cost']!,
          _standardCostMeta,
        ),
      );
    }
    if (data.containsKey('is_stock_control')) {
      context.handle(
        _isStockControlMeta,
        isStockControl.isAcceptableOrUnknown(
          data['is_stock_control']!,
          _isStockControlMeta,
        ),
      );
    }
    if (data.containsKey('is_serial_control')) {
      context.handle(
        _isSerialControlMeta,
        isSerialControl.isAcceptableOrUnknown(
          data['is_serial_control']!,
          _isSerialControlMeta,
        ),
      );
    }
    if (data.containsKey('allow_negative_stock')) {
      context.handle(
        _allowNegativeStockMeta,
        allowNegativeStock.isAcceptableOrUnknown(
          data['allow_negative_stock']!,
          _allowNegativeStockMeta,
        ),
      );
    }
    if (data.containsKey('reorder_point')) {
      context.handle(
        _reorderPointMeta,
        reorderPoint.isAcceptableOrUnknown(
          data['reorder_point']!,
          _reorderPointMeta,
        ),
      );
    }
    if (data.containsKey('vat_type')) {
      context.handle(
        _vatTypeMeta,
        vatType.isAcceptableOrUnknown(data['vat_type']!, _vatTypeMeta),
      );
    }
    if (data.containsKey('vat_rate')) {
      context.handle(
        _vatRateMeta,
        vatRate.isAcceptableOrUnknown(data['vat_rate']!, _vatRateMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {productId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {productCode},
  ];
  @override
  Product map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Product(
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_id'],
      )!,
      productCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_code'],
      )!,
      barcode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}barcode'],
      ),
      productName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_name'],
      )!,
      productNameEn: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_name_en'],
      ),
      groupId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}group_id'],
      ),
      brand: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}brand'],
      ),
      model: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}model'],
      ),
      color: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color'],
      ),
      baseUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}base_unit'],
      )!,
      unitConversion: $ProductsTable.$converterunitConversionn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}unit_conversion'],
        ),
      ),
      priceLevel1: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_level1'],
      )!,
      priceLevel2: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_level2'],
      )!,
      priceLevel3: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_level3'],
      )!,
      priceLevel4: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_level4'],
      )!,
      priceLevel5: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_level5'],
      )!,
      costMethod: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cost_method'],
      )!,
      standardCost: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}standard_cost'],
      )!,
      isStockControl: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_stock_control'],
      )!,
      isSerialControl: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_serial_control'],
      )!,
      allowNegativeStock: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}allow_negative_stock'],
      )!,
      reorderPoint: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}reorder_point'],
      )!,
      vatType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}vat_type'],
      )!,
      vatRate: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}vat_rate'],
      )!,
      imageUrls: $ProductsTable.$converterimageUrlsn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}image_urls'],
        ),
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ProductsTable createAlias(String alias) {
    return $ProductsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $converterunitConversion =
      const JsonConverter();
  static TypeConverter<Map<String, dynamic>?, String?>
  $converterunitConversionn = NullAwareTypeConverter.wrap(
    $converterunitConversion,
  );
  static TypeConverter<Map<String, dynamic>, String> $converterimageUrls =
      const JsonConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $converterimageUrlsn =
      NullAwareTypeConverter.wrap($converterimageUrls);
}

class Product extends DataClass implements Insertable<Product> {
  final String productId;
  final String productCode;
  final String? barcode;
  final String productName;
  final String? productNameEn;
  final String? groupId;
  final String? brand;
  final String? model;
  final String? color;
  final String baseUnit;
  final Map<String, dynamic>? unitConversion;
  final double priceLevel1;
  final double priceLevel2;
  final double priceLevel3;
  final double priceLevel4;
  final double priceLevel5;
  final String costMethod;
  final double standardCost;
  final bool isStockControl;
  final bool isSerialControl;
  final bool allowNegativeStock;
  final double reorderPoint;
  final String vatType;
  final double vatRate;
  final Map<String, dynamic>? imageUrls;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Product({
    required this.productId,
    required this.productCode,
    this.barcode,
    required this.productName,
    this.productNameEn,
    this.groupId,
    this.brand,
    this.model,
    this.color,
    required this.baseUnit,
    this.unitConversion,
    required this.priceLevel1,
    required this.priceLevel2,
    required this.priceLevel3,
    required this.priceLevel4,
    required this.priceLevel5,
    required this.costMethod,
    required this.standardCost,
    required this.isStockControl,
    required this.isSerialControl,
    required this.allowNegativeStock,
    required this.reorderPoint,
    required this.vatType,
    required this.vatRate,
    this.imageUrls,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['product_id'] = Variable<String>(productId);
    map['product_code'] = Variable<String>(productCode);
    if (!nullToAbsent || barcode != null) {
      map['barcode'] = Variable<String>(barcode);
    }
    map['product_name'] = Variable<String>(productName);
    if (!nullToAbsent || productNameEn != null) {
      map['product_name_en'] = Variable<String>(productNameEn);
    }
    if (!nullToAbsent || groupId != null) {
      map['group_id'] = Variable<String>(groupId);
    }
    if (!nullToAbsent || brand != null) {
      map['brand'] = Variable<String>(brand);
    }
    if (!nullToAbsent || model != null) {
      map['model'] = Variable<String>(model);
    }
    if (!nullToAbsent || color != null) {
      map['color'] = Variable<String>(color);
    }
    map['base_unit'] = Variable<String>(baseUnit);
    if (!nullToAbsent || unitConversion != null) {
      map['unit_conversion'] = Variable<String>(
        $ProductsTable.$converterunitConversionn.toSql(unitConversion),
      );
    }
    map['price_level1'] = Variable<double>(priceLevel1);
    map['price_level2'] = Variable<double>(priceLevel2);
    map['price_level3'] = Variable<double>(priceLevel3);
    map['price_level4'] = Variable<double>(priceLevel4);
    map['price_level5'] = Variable<double>(priceLevel5);
    map['cost_method'] = Variable<String>(costMethod);
    map['standard_cost'] = Variable<double>(standardCost);
    map['is_stock_control'] = Variable<bool>(isStockControl);
    map['is_serial_control'] = Variable<bool>(isSerialControl);
    map['allow_negative_stock'] = Variable<bool>(allowNegativeStock);
    map['reorder_point'] = Variable<double>(reorderPoint);
    map['vat_type'] = Variable<String>(vatType);
    map['vat_rate'] = Variable<double>(vatRate);
    if (!nullToAbsent || imageUrls != null) {
      map['image_urls'] = Variable<String>(
        $ProductsTable.$converterimageUrlsn.toSql(imageUrls),
      );
    }
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ProductsCompanion toCompanion(bool nullToAbsent) {
    return ProductsCompanion(
      productId: Value(productId),
      productCode: Value(productCode),
      barcode: barcode == null && nullToAbsent
          ? const Value.absent()
          : Value(barcode),
      productName: Value(productName),
      productNameEn: productNameEn == null && nullToAbsent
          ? const Value.absent()
          : Value(productNameEn),
      groupId: groupId == null && nullToAbsent
          ? const Value.absent()
          : Value(groupId),
      brand: brand == null && nullToAbsent
          ? const Value.absent()
          : Value(brand),
      model: model == null && nullToAbsent
          ? const Value.absent()
          : Value(model),
      color: color == null && nullToAbsent
          ? const Value.absent()
          : Value(color),
      baseUnit: Value(baseUnit),
      unitConversion: unitConversion == null && nullToAbsent
          ? const Value.absent()
          : Value(unitConversion),
      priceLevel1: Value(priceLevel1),
      priceLevel2: Value(priceLevel2),
      priceLevel3: Value(priceLevel3),
      priceLevel4: Value(priceLevel4),
      priceLevel5: Value(priceLevel5),
      costMethod: Value(costMethod),
      standardCost: Value(standardCost),
      isStockControl: Value(isStockControl),
      isSerialControl: Value(isSerialControl),
      allowNegativeStock: Value(allowNegativeStock),
      reorderPoint: Value(reorderPoint),
      vatType: Value(vatType),
      vatRate: Value(vatRate),
      imageUrls: imageUrls == null && nullToAbsent
          ? const Value.absent()
          : Value(imageUrls),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Product.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Product(
      productId: serializer.fromJson<String>(json['productId']),
      productCode: serializer.fromJson<String>(json['productCode']),
      barcode: serializer.fromJson<String?>(json['barcode']),
      productName: serializer.fromJson<String>(json['productName']),
      productNameEn: serializer.fromJson<String?>(json['productNameEn']),
      groupId: serializer.fromJson<String?>(json['groupId']),
      brand: serializer.fromJson<String?>(json['brand']),
      model: serializer.fromJson<String?>(json['model']),
      color: serializer.fromJson<String?>(json['color']),
      baseUnit: serializer.fromJson<String>(json['baseUnit']),
      unitConversion: serializer.fromJson<Map<String, dynamic>?>(
        json['unitConversion'],
      ),
      priceLevel1: serializer.fromJson<double>(json['priceLevel1']),
      priceLevel2: serializer.fromJson<double>(json['priceLevel2']),
      priceLevel3: serializer.fromJson<double>(json['priceLevel3']),
      priceLevel4: serializer.fromJson<double>(json['priceLevel4']),
      priceLevel5: serializer.fromJson<double>(json['priceLevel5']),
      costMethod: serializer.fromJson<String>(json['costMethod']),
      standardCost: serializer.fromJson<double>(json['standardCost']),
      isStockControl: serializer.fromJson<bool>(json['isStockControl']),
      isSerialControl: serializer.fromJson<bool>(json['isSerialControl']),
      allowNegativeStock: serializer.fromJson<bool>(json['allowNegativeStock']),
      reorderPoint: serializer.fromJson<double>(json['reorderPoint']),
      vatType: serializer.fromJson<String>(json['vatType']),
      vatRate: serializer.fromJson<double>(json['vatRate']),
      imageUrls: serializer.fromJson<Map<String, dynamic>?>(json['imageUrls']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'productId': serializer.toJson<String>(productId),
      'productCode': serializer.toJson<String>(productCode),
      'barcode': serializer.toJson<String?>(barcode),
      'productName': serializer.toJson<String>(productName),
      'productNameEn': serializer.toJson<String?>(productNameEn),
      'groupId': serializer.toJson<String?>(groupId),
      'brand': serializer.toJson<String?>(brand),
      'model': serializer.toJson<String?>(model),
      'color': serializer.toJson<String?>(color),
      'baseUnit': serializer.toJson<String>(baseUnit),
      'unitConversion': serializer.toJson<Map<String, dynamic>?>(
        unitConversion,
      ),
      'priceLevel1': serializer.toJson<double>(priceLevel1),
      'priceLevel2': serializer.toJson<double>(priceLevel2),
      'priceLevel3': serializer.toJson<double>(priceLevel3),
      'priceLevel4': serializer.toJson<double>(priceLevel4),
      'priceLevel5': serializer.toJson<double>(priceLevel5),
      'costMethod': serializer.toJson<String>(costMethod),
      'standardCost': serializer.toJson<double>(standardCost),
      'isStockControl': serializer.toJson<bool>(isStockControl),
      'isSerialControl': serializer.toJson<bool>(isSerialControl),
      'allowNegativeStock': serializer.toJson<bool>(allowNegativeStock),
      'reorderPoint': serializer.toJson<double>(reorderPoint),
      'vatType': serializer.toJson<String>(vatType),
      'vatRate': serializer.toJson<double>(vatRate),
      'imageUrls': serializer.toJson<Map<String, dynamic>?>(imageUrls),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Product copyWith({
    String? productId,
    String? productCode,
    Value<String?> barcode = const Value.absent(),
    String? productName,
    Value<String?> productNameEn = const Value.absent(),
    Value<String?> groupId = const Value.absent(),
    Value<String?> brand = const Value.absent(),
    Value<String?> model = const Value.absent(),
    Value<String?> color = const Value.absent(),
    String? baseUnit,
    Value<Map<String, dynamic>?> unitConversion = const Value.absent(),
    double? priceLevel1,
    double? priceLevel2,
    double? priceLevel3,
    double? priceLevel4,
    double? priceLevel5,
    String? costMethod,
    double? standardCost,
    bool? isStockControl,
    bool? isSerialControl,
    bool? allowNegativeStock,
    double? reorderPoint,
    String? vatType,
    double? vatRate,
    Value<Map<String, dynamic>?> imageUrls = const Value.absent(),
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Product(
    productId: productId ?? this.productId,
    productCode: productCode ?? this.productCode,
    barcode: barcode.present ? barcode.value : this.barcode,
    productName: productName ?? this.productName,
    productNameEn: productNameEn.present
        ? productNameEn.value
        : this.productNameEn,
    groupId: groupId.present ? groupId.value : this.groupId,
    brand: brand.present ? brand.value : this.brand,
    model: model.present ? model.value : this.model,
    color: color.present ? color.value : this.color,
    baseUnit: baseUnit ?? this.baseUnit,
    unitConversion: unitConversion.present
        ? unitConversion.value
        : this.unitConversion,
    priceLevel1: priceLevel1 ?? this.priceLevel1,
    priceLevel2: priceLevel2 ?? this.priceLevel2,
    priceLevel3: priceLevel3 ?? this.priceLevel3,
    priceLevel4: priceLevel4 ?? this.priceLevel4,
    priceLevel5: priceLevel5 ?? this.priceLevel5,
    costMethod: costMethod ?? this.costMethod,
    standardCost: standardCost ?? this.standardCost,
    isStockControl: isStockControl ?? this.isStockControl,
    isSerialControl: isSerialControl ?? this.isSerialControl,
    allowNegativeStock: allowNegativeStock ?? this.allowNegativeStock,
    reorderPoint: reorderPoint ?? this.reorderPoint,
    vatType: vatType ?? this.vatType,
    vatRate: vatRate ?? this.vatRate,
    imageUrls: imageUrls.present ? imageUrls.value : this.imageUrls,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Product copyWithCompanion(ProductsCompanion data) {
    return Product(
      productId: data.productId.present ? data.productId.value : this.productId,
      productCode: data.productCode.present
          ? data.productCode.value
          : this.productCode,
      barcode: data.barcode.present ? data.barcode.value : this.barcode,
      productName: data.productName.present
          ? data.productName.value
          : this.productName,
      productNameEn: data.productNameEn.present
          ? data.productNameEn.value
          : this.productNameEn,
      groupId: data.groupId.present ? data.groupId.value : this.groupId,
      brand: data.brand.present ? data.brand.value : this.brand,
      model: data.model.present ? data.model.value : this.model,
      color: data.color.present ? data.color.value : this.color,
      baseUnit: data.baseUnit.present ? data.baseUnit.value : this.baseUnit,
      unitConversion: data.unitConversion.present
          ? data.unitConversion.value
          : this.unitConversion,
      priceLevel1: data.priceLevel1.present
          ? data.priceLevel1.value
          : this.priceLevel1,
      priceLevel2: data.priceLevel2.present
          ? data.priceLevel2.value
          : this.priceLevel2,
      priceLevel3: data.priceLevel3.present
          ? data.priceLevel3.value
          : this.priceLevel3,
      priceLevel4: data.priceLevel4.present
          ? data.priceLevel4.value
          : this.priceLevel4,
      priceLevel5: data.priceLevel5.present
          ? data.priceLevel5.value
          : this.priceLevel5,
      costMethod: data.costMethod.present
          ? data.costMethod.value
          : this.costMethod,
      standardCost: data.standardCost.present
          ? data.standardCost.value
          : this.standardCost,
      isStockControl: data.isStockControl.present
          ? data.isStockControl.value
          : this.isStockControl,
      isSerialControl: data.isSerialControl.present
          ? data.isSerialControl.value
          : this.isSerialControl,
      allowNegativeStock: data.allowNegativeStock.present
          ? data.allowNegativeStock.value
          : this.allowNegativeStock,
      reorderPoint: data.reorderPoint.present
          ? data.reorderPoint.value
          : this.reorderPoint,
      vatType: data.vatType.present ? data.vatType.value : this.vatType,
      vatRate: data.vatRate.present ? data.vatRate.value : this.vatRate,
      imageUrls: data.imageUrls.present ? data.imageUrls.value : this.imageUrls,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Product(')
          ..write('productId: $productId, ')
          ..write('productCode: $productCode, ')
          ..write('barcode: $barcode, ')
          ..write('productName: $productName, ')
          ..write('productNameEn: $productNameEn, ')
          ..write('groupId: $groupId, ')
          ..write('brand: $brand, ')
          ..write('model: $model, ')
          ..write('color: $color, ')
          ..write('baseUnit: $baseUnit, ')
          ..write('unitConversion: $unitConversion, ')
          ..write('priceLevel1: $priceLevel1, ')
          ..write('priceLevel2: $priceLevel2, ')
          ..write('priceLevel3: $priceLevel3, ')
          ..write('priceLevel4: $priceLevel4, ')
          ..write('priceLevel5: $priceLevel5, ')
          ..write('costMethod: $costMethod, ')
          ..write('standardCost: $standardCost, ')
          ..write('isStockControl: $isStockControl, ')
          ..write('isSerialControl: $isSerialControl, ')
          ..write('allowNegativeStock: $allowNegativeStock, ')
          ..write('reorderPoint: $reorderPoint, ')
          ..write('vatType: $vatType, ')
          ..write('vatRate: $vatRate, ')
          ..write('imageUrls: $imageUrls, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    productId,
    productCode,
    barcode,
    productName,
    productNameEn,
    groupId,
    brand,
    model,
    color,
    baseUnit,
    unitConversion,
    priceLevel1,
    priceLevel2,
    priceLevel3,
    priceLevel4,
    priceLevel5,
    costMethod,
    standardCost,
    isStockControl,
    isSerialControl,
    allowNegativeStock,
    reorderPoint,
    vatType,
    vatRate,
    imageUrls,
    isActive,
    createdAt,
    updatedAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Product &&
          other.productId == this.productId &&
          other.productCode == this.productCode &&
          other.barcode == this.barcode &&
          other.productName == this.productName &&
          other.productNameEn == this.productNameEn &&
          other.groupId == this.groupId &&
          other.brand == this.brand &&
          other.model == this.model &&
          other.color == this.color &&
          other.baseUnit == this.baseUnit &&
          other.unitConversion == this.unitConversion &&
          other.priceLevel1 == this.priceLevel1 &&
          other.priceLevel2 == this.priceLevel2 &&
          other.priceLevel3 == this.priceLevel3 &&
          other.priceLevel4 == this.priceLevel4 &&
          other.priceLevel5 == this.priceLevel5 &&
          other.costMethod == this.costMethod &&
          other.standardCost == this.standardCost &&
          other.isStockControl == this.isStockControl &&
          other.isSerialControl == this.isSerialControl &&
          other.allowNegativeStock == this.allowNegativeStock &&
          other.reorderPoint == this.reorderPoint &&
          other.vatType == this.vatType &&
          other.vatRate == this.vatRate &&
          other.imageUrls == this.imageUrls &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ProductsCompanion extends UpdateCompanion<Product> {
  final Value<String> productId;
  final Value<String> productCode;
  final Value<String?> barcode;
  final Value<String> productName;
  final Value<String?> productNameEn;
  final Value<String?> groupId;
  final Value<String?> brand;
  final Value<String?> model;
  final Value<String?> color;
  final Value<String> baseUnit;
  final Value<Map<String, dynamic>?> unitConversion;
  final Value<double> priceLevel1;
  final Value<double> priceLevel2;
  final Value<double> priceLevel3;
  final Value<double> priceLevel4;
  final Value<double> priceLevel5;
  final Value<String> costMethod;
  final Value<double> standardCost;
  final Value<bool> isStockControl;
  final Value<bool> isSerialControl;
  final Value<bool> allowNegativeStock;
  final Value<double> reorderPoint;
  final Value<String> vatType;
  final Value<double> vatRate;
  final Value<Map<String, dynamic>?> imageUrls;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const ProductsCompanion({
    this.productId = const Value.absent(),
    this.productCode = const Value.absent(),
    this.barcode = const Value.absent(),
    this.productName = const Value.absent(),
    this.productNameEn = const Value.absent(),
    this.groupId = const Value.absent(),
    this.brand = const Value.absent(),
    this.model = const Value.absent(),
    this.color = const Value.absent(),
    this.baseUnit = const Value.absent(),
    this.unitConversion = const Value.absent(),
    this.priceLevel1 = const Value.absent(),
    this.priceLevel2 = const Value.absent(),
    this.priceLevel3 = const Value.absent(),
    this.priceLevel4 = const Value.absent(),
    this.priceLevel5 = const Value.absent(),
    this.costMethod = const Value.absent(),
    this.standardCost = const Value.absent(),
    this.isStockControl = const Value.absent(),
    this.isSerialControl = const Value.absent(),
    this.allowNegativeStock = const Value.absent(),
    this.reorderPoint = const Value.absent(),
    this.vatType = const Value.absent(),
    this.vatRate = const Value.absent(),
    this.imageUrls = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProductsCompanion.insert({
    required String productId,
    required String productCode,
    this.barcode = const Value.absent(),
    required String productName,
    this.productNameEn = const Value.absent(),
    this.groupId = const Value.absent(),
    this.brand = const Value.absent(),
    this.model = const Value.absent(),
    this.color = const Value.absent(),
    required String baseUnit,
    this.unitConversion = const Value.absent(),
    this.priceLevel1 = const Value.absent(),
    this.priceLevel2 = const Value.absent(),
    this.priceLevel3 = const Value.absent(),
    this.priceLevel4 = const Value.absent(),
    this.priceLevel5 = const Value.absent(),
    this.costMethod = const Value.absent(),
    this.standardCost = const Value.absent(),
    this.isStockControl = const Value.absent(),
    this.isSerialControl = const Value.absent(),
    this.allowNegativeStock = const Value.absent(),
    this.reorderPoint = const Value.absent(),
    this.vatType = const Value.absent(),
    this.vatRate = const Value.absent(),
    this.imageUrls = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : productId = Value(productId),
       productCode = Value(productCode),
       productName = Value(productName),
       baseUnit = Value(baseUnit);
  static Insertable<Product> custom({
    Expression<String>? productId,
    Expression<String>? productCode,
    Expression<String>? barcode,
    Expression<String>? productName,
    Expression<String>? productNameEn,
    Expression<String>? groupId,
    Expression<String>? brand,
    Expression<String>? model,
    Expression<String>? color,
    Expression<String>? baseUnit,
    Expression<String>? unitConversion,
    Expression<double>? priceLevel1,
    Expression<double>? priceLevel2,
    Expression<double>? priceLevel3,
    Expression<double>? priceLevel4,
    Expression<double>? priceLevel5,
    Expression<String>? costMethod,
    Expression<double>? standardCost,
    Expression<bool>? isStockControl,
    Expression<bool>? isSerialControl,
    Expression<bool>? allowNegativeStock,
    Expression<double>? reorderPoint,
    Expression<String>? vatType,
    Expression<double>? vatRate,
    Expression<String>? imageUrls,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (productId != null) 'product_id': productId,
      if (productCode != null) 'product_code': productCode,
      if (barcode != null) 'barcode': barcode,
      if (productName != null) 'product_name': productName,
      if (productNameEn != null) 'product_name_en': productNameEn,
      if (groupId != null) 'group_id': groupId,
      if (brand != null) 'brand': brand,
      if (model != null) 'model': model,
      if (color != null) 'color': color,
      if (baseUnit != null) 'base_unit': baseUnit,
      if (unitConversion != null) 'unit_conversion': unitConversion,
      if (priceLevel1 != null) 'price_level1': priceLevel1,
      if (priceLevel2 != null) 'price_level2': priceLevel2,
      if (priceLevel3 != null) 'price_level3': priceLevel3,
      if (priceLevel4 != null) 'price_level4': priceLevel4,
      if (priceLevel5 != null) 'price_level5': priceLevel5,
      if (costMethod != null) 'cost_method': costMethod,
      if (standardCost != null) 'standard_cost': standardCost,
      if (isStockControl != null) 'is_stock_control': isStockControl,
      if (isSerialControl != null) 'is_serial_control': isSerialControl,
      if (allowNegativeStock != null)
        'allow_negative_stock': allowNegativeStock,
      if (reorderPoint != null) 'reorder_point': reorderPoint,
      if (vatType != null) 'vat_type': vatType,
      if (vatRate != null) 'vat_rate': vatRate,
      if (imageUrls != null) 'image_urls': imageUrls,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProductsCompanion copyWith({
    Value<String>? productId,
    Value<String>? productCode,
    Value<String?>? barcode,
    Value<String>? productName,
    Value<String?>? productNameEn,
    Value<String?>? groupId,
    Value<String?>? brand,
    Value<String?>? model,
    Value<String?>? color,
    Value<String>? baseUnit,
    Value<Map<String, dynamic>?>? unitConversion,
    Value<double>? priceLevel1,
    Value<double>? priceLevel2,
    Value<double>? priceLevel3,
    Value<double>? priceLevel4,
    Value<double>? priceLevel5,
    Value<String>? costMethod,
    Value<double>? standardCost,
    Value<bool>? isStockControl,
    Value<bool>? isSerialControl,
    Value<bool>? allowNegativeStock,
    Value<double>? reorderPoint,
    Value<String>? vatType,
    Value<double>? vatRate,
    Value<Map<String, dynamic>?>? imageUrls,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return ProductsCompanion(
      productId: productId ?? this.productId,
      productCode: productCode ?? this.productCode,
      barcode: barcode ?? this.barcode,
      productName: productName ?? this.productName,
      productNameEn: productNameEn ?? this.productNameEn,
      groupId: groupId ?? this.groupId,
      brand: brand ?? this.brand,
      model: model ?? this.model,
      color: color ?? this.color,
      baseUnit: baseUnit ?? this.baseUnit,
      unitConversion: unitConversion ?? this.unitConversion,
      priceLevel1: priceLevel1 ?? this.priceLevel1,
      priceLevel2: priceLevel2 ?? this.priceLevel2,
      priceLevel3: priceLevel3 ?? this.priceLevel3,
      priceLevel4: priceLevel4 ?? this.priceLevel4,
      priceLevel5: priceLevel5 ?? this.priceLevel5,
      costMethod: costMethod ?? this.costMethod,
      standardCost: standardCost ?? this.standardCost,
      isStockControl: isStockControl ?? this.isStockControl,
      isSerialControl: isSerialControl ?? this.isSerialControl,
      allowNegativeStock: allowNegativeStock ?? this.allowNegativeStock,
      reorderPoint: reorderPoint ?? this.reorderPoint,
      vatType: vatType ?? this.vatType,
      vatRate: vatRate ?? this.vatRate,
      imageUrls: imageUrls ?? this.imageUrls,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (productCode.present) {
      map['product_code'] = Variable<String>(productCode.value);
    }
    if (barcode.present) {
      map['barcode'] = Variable<String>(barcode.value);
    }
    if (productName.present) {
      map['product_name'] = Variable<String>(productName.value);
    }
    if (productNameEn.present) {
      map['product_name_en'] = Variable<String>(productNameEn.value);
    }
    if (groupId.present) {
      map['group_id'] = Variable<String>(groupId.value);
    }
    if (brand.present) {
      map['brand'] = Variable<String>(brand.value);
    }
    if (model.present) {
      map['model'] = Variable<String>(model.value);
    }
    if (color.present) {
      map['color'] = Variable<String>(color.value);
    }
    if (baseUnit.present) {
      map['base_unit'] = Variable<String>(baseUnit.value);
    }
    if (unitConversion.present) {
      map['unit_conversion'] = Variable<String>(
        $ProductsTable.$converterunitConversionn.toSql(unitConversion.value),
      );
    }
    if (priceLevel1.present) {
      map['price_level1'] = Variable<double>(priceLevel1.value);
    }
    if (priceLevel2.present) {
      map['price_level2'] = Variable<double>(priceLevel2.value);
    }
    if (priceLevel3.present) {
      map['price_level3'] = Variable<double>(priceLevel3.value);
    }
    if (priceLevel4.present) {
      map['price_level4'] = Variable<double>(priceLevel4.value);
    }
    if (priceLevel5.present) {
      map['price_level5'] = Variable<double>(priceLevel5.value);
    }
    if (costMethod.present) {
      map['cost_method'] = Variable<String>(costMethod.value);
    }
    if (standardCost.present) {
      map['standard_cost'] = Variable<double>(standardCost.value);
    }
    if (isStockControl.present) {
      map['is_stock_control'] = Variable<bool>(isStockControl.value);
    }
    if (isSerialControl.present) {
      map['is_serial_control'] = Variable<bool>(isSerialControl.value);
    }
    if (allowNegativeStock.present) {
      map['allow_negative_stock'] = Variable<bool>(allowNegativeStock.value);
    }
    if (reorderPoint.present) {
      map['reorder_point'] = Variable<double>(reorderPoint.value);
    }
    if (vatType.present) {
      map['vat_type'] = Variable<String>(vatType.value);
    }
    if (vatRate.present) {
      map['vat_rate'] = Variable<double>(vatRate.value);
    }
    if (imageUrls.present) {
      map['image_urls'] = Variable<String>(
        $ProductsTable.$converterimageUrlsn.toSql(imageUrls.value),
      );
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductsCompanion(')
          ..write('productId: $productId, ')
          ..write('productCode: $productCode, ')
          ..write('barcode: $barcode, ')
          ..write('productName: $productName, ')
          ..write('productNameEn: $productNameEn, ')
          ..write('groupId: $groupId, ')
          ..write('brand: $brand, ')
          ..write('model: $model, ')
          ..write('color: $color, ')
          ..write('baseUnit: $baseUnit, ')
          ..write('unitConversion: $unitConversion, ')
          ..write('priceLevel1: $priceLevel1, ')
          ..write('priceLevel2: $priceLevel2, ')
          ..write('priceLevel3: $priceLevel3, ')
          ..write('priceLevel4: $priceLevel4, ')
          ..write('priceLevel5: $priceLevel5, ')
          ..write('costMethod: $costMethod, ')
          ..write('standardCost: $standardCost, ')
          ..write('isStockControl: $isStockControl, ')
          ..write('isSerialControl: $isSerialControl, ')
          ..write('allowNegativeStock: $allowNegativeStock, ')
          ..write('reorderPoint: $reorderPoint, ')
          ..write('vatType: $vatType, ')
          ..write('vatRate: $vatRate, ')
          ..write('imageUrls: $imageUrls, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $WarehousesTable extends Warehouses
    with TableInfo<$WarehousesTable, Warehouse> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WarehousesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _warehouseIdMeta = const VerificationMeta(
    'warehouseId',
  );
  @override
  late final GeneratedColumn<String> warehouseId = GeneratedColumn<String>(
    'warehouse_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _warehouseCodeMeta = const VerificationMeta(
    'warehouseCode',
  );
  @override
  late final GeneratedColumn<String> warehouseCode = GeneratedColumn<String>(
    'warehouse_code',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _warehouseNameMeta = const VerificationMeta(
    'warehouseName',
  );
  @override
  late final GeneratedColumn<String> warehouseName = GeneratedColumn<String>(
    'warehouse_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES branches (branch_id)',
    ),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    warehouseId,
    warehouseCode,
    warehouseName,
    branchId,
    isActive,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'warehouses';
  @override
  VerificationContext validateIntegrity(
    Insertable<Warehouse> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('warehouse_id')) {
      context.handle(
        _warehouseIdMeta,
        warehouseId.isAcceptableOrUnknown(
          data['warehouse_id']!,
          _warehouseIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('warehouse_code')) {
      context.handle(
        _warehouseCodeMeta,
        warehouseCode.isAcceptableOrUnknown(
          data['warehouse_code']!,
          _warehouseCodeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_warehouseCodeMeta);
    }
    if (data.containsKey('warehouse_name')) {
      context.handle(
        _warehouseNameMeta,
        warehouseName.isAcceptableOrUnknown(
          data['warehouse_name']!,
          _warehouseNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_warehouseNameMeta);
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    } else if (isInserting) {
      context.missing(_branchIdMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {warehouseId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {warehouseCode},
  ];
  @override
  Warehouse map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Warehouse(
      warehouseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}warehouse_id'],
      )!,
      warehouseCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}warehouse_code'],
      )!,
      warehouseName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}warehouse_name'],
      )!,
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $WarehousesTable createAlias(String alias) {
    return $WarehousesTable(attachedDatabase, alias);
  }
}

class Warehouse extends DataClass implements Insertable<Warehouse> {
  final String warehouseId;
  final String warehouseCode;
  final String warehouseName;
  final String branchId;
  final bool isActive;
  final DateTime createdAt;
  const Warehouse({
    required this.warehouseId,
    required this.warehouseCode,
    required this.warehouseName,
    required this.branchId,
    required this.isActive,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['warehouse_id'] = Variable<String>(warehouseId);
    map['warehouse_code'] = Variable<String>(warehouseCode);
    map['warehouse_name'] = Variable<String>(warehouseName);
    map['branch_id'] = Variable<String>(branchId);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  WarehousesCompanion toCompanion(bool nullToAbsent) {
    return WarehousesCompanion(
      warehouseId: Value(warehouseId),
      warehouseCode: Value(warehouseCode),
      warehouseName: Value(warehouseName),
      branchId: Value(branchId),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
    );
  }

  factory Warehouse.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Warehouse(
      warehouseId: serializer.fromJson<String>(json['warehouseId']),
      warehouseCode: serializer.fromJson<String>(json['warehouseCode']),
      warehouseName: serializer.fromJson<String>(json['warehouseName']),
      branchId: serializer.fromJson<String>(json['branchId']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'warehouseId': serializer.toJson<String>(warehouseId),
      'warehouseCode': serializer.toJson<String>(warehouseCode),
      'warehouseName': serializer.toJson<String>(warehouseName),
      'branchId': serializer.toJson<String>(branchId),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Warehouse copyWith({
    String? warehouseId,
    String? warehouseCode,
    String? warehouseName,
    String? branchId,
    bool? isActive,
    DateTime? createdAt,
  }) => Warehouse(
    warehouseId: warehouseId ?? this.warehouseId,
    warehouseCode: warehouseCode ?? this.warehouseCode,
    warehouseName: warehouseName ?? this.warehouseName,
    branchId: branchId ?? this.branchId,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
  );
  Warehouse copyWithCompanion(WarehousesCompanion data) {
    return Warehouse(
      warehouseId: data.warehouseId.present
          ? data.warehouseId.value
          : this.warehouseId,
      warehouseCode: data.warehouseCode.present
          ? data.warehouseCode.value
          : this.warehouseCode,
      warehouseName: data.warehouseName.present
          ? data.warehouseName.value
          : this.warehouseName,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Warehouse(')
          ..write('warehouseId: $warehouseId, ')
          ..write('warehouseCode: $warehouseCode, ')
          ..write('warehouseName: $warehouseName, ')
          ..write('branchId: $branchId, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    warehouseId,
    warehouseCode,
    warehouseName,
    branchId,
    isActive,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Warehouse &&
          other.warehouseId == this.warehouseId &&
          other.warehouseCode == this.warehouseCode &&
          other.warehouseName == this.warehouseName &&
          other.branchId == this.branchId &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt);
}

class WarehousesCompanion extends UpdateCompanion<Warehouse> {
  final Value<String> warehouseId;
  final Value<String> warehouseCode;
  final Value<String> warehouseName;
  final Value<String> branchId;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const WarehousesCompanion({
    this.warehouseId = const Value.absent(),
    this.warehouseCode = const Value.absent(),
    this.warehouseName = const Value.absent(),
    this.branchId = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  WarehousesCompanion.insert({
    required String warehouseId,
    required String warehouseCode,
    required String warehouseName,
    required String branchId,
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : warehouseId = Value(warehouseId),
       warehouseCode = Value(warehouseCode),
       warehouseName = Value(warehouseName),
       branchId = Value(branchId);
  static Insertable<Warehouse> custom({
    Expression<String>? warehouseId,
    Expression<String>? warehouseCode,
    Expression<String>? warehouseName,
    Expression<String>? branchId,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (warehouseCode != null) 'warehouse_code': warehouseCode,
      if (warehouseName != null) 'warehouse_name': warehouseName,
      if (branchId != null) 'branch_id': branchId,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  WarehousesCompanion copyWith({
    Value<String>? warehouseId,
    Value<String>? warehouseCode,
    Value<String>? warehouseName,
    Value<String>? branchId,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return WarehousesCompanion(
      warehouseId: warehouseId ?? this.warehouseId,
      warehouseCode: warehouseCode ?? this.warehouseCode,
      warehouseName: warehouseName ?? this.warehouseName,
      branchId: branchId ?? this.branchId,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<String>(warehouseId.value);
    }
    if (warehouseCode.present) {
      map['warehouse_code'] = Variable<String>(warehouseCode.value);
    }
    if (warehouseName.present) {
      map['warehouse_name'] = Variable<String>(warehouseName.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WarehousesCompanion(')
          ..write('warehouseId: $warehouseId, ')
          ..write('warehouseCode: $warehouseCode, ')
          ..write('warehouseName: $warehouseName, ')
          ..write('branchId: $branchId, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StockBalancesTable extends StockBalances
    with TableInfo<$StockBalancesTable, StockBalance> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockBalancesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _stockIdMeta = const VerificationMeta(
    'stockId',
  );
  @override
  late final GeneratedColumn<String> stockId = GeneratedColumn<String>(
    'stock_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES products (product_id)',
    ),
  );
  static const VerificationMeta _warehouseIdMeta = const VerificationMeta(
    'warehouseId',
  );
  @override
  late final GeneratedColumn<String> warehouseId = GeneratedColumn<String>(
    'warehouse_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES warehouses (warehouse_id)',
    ),
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _reservedQtyMeta = const VerificationMeta(
    'reservedQty',
  );
  @override
  late final GeneratedColumn<double> reservedQty = GeneratedColumn<double>(
    'reserved_qty',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _avgCostMeta = const VerificationMeta(
    'avgCost',
  );
  @override
  late final GeneratedColumn<double> avgCost = GeneratedColumn<double>(
    'avg_cost',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _lastCostMeta = const VerificationMeta(
    'lastCost',
  );
  @override
  late final GeneratedColumn<double> lastCost = GeneratedColumn<double>(
    'last_cost',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    stockId,
    productId,
    warehouseId,
    quantity,
    reservedQty,
    avgCost,
    lastCost,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_balances';
  @override
  VerificationContext validateIntegrity(
    Insertable<StockBalance> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('stock_id')) {
      context.handle(
        _stockIdMeta,
        stockId.isAcceptableOrUnknown(data['stock_id']!, _stockIdMeta),
      );
    } else if (isInserting) {
      context.missing(_stockIdMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
        _warehouseIdMeta,
        warehouseId.isAcceptableOrUnknown(
          data['warehouse_id']!,
          _warehouseIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    }
    if (data.containsKey('reserved_qty')) {
      context.handle(
        _reservedQtyMeta,
        reservedQty.isAcceptableOrUnknown(
          data['reserved_qty']!,
          _reservedQtyMeta,
        ),
      );
    }
    if (data.containsKey('avg_cost')) {
      context.handle(
        _avgCostMeta,
        avgCost.isAcceptableOrUnknown(data['avg_cost']!, _avgCostMeta),
      );
    }
    if (data.containsKey('last_cost')) {
      context.handle(
        _lastCostMeta,
        lastCost.isAcceptableOrUnknown(data['last_cost']!, _lastCostMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {stockId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {productId, warehouseId},
  ];
  @override
  StockBalance map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockBalance(
      stockId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stock_id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_id'],
      )!,
      warehouseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}warehouse_id'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}quantity'],
      )!,
      reservedQty: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}reserved_qty'],
      )!,
      avgCost: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}avg_cost'],
      )!,
      lastCost: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}last_cost'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $StockBalancesTable createAlias(String alias) {
    return $StockBalancesTable(attachedDatabase, alias);
  }
}

class StockBalance extends DataClass implements Insertable<StockBalance> {
  final String stockId;
  final String productId;
  final String warehouseId;
  final double quantity;
  final double reservedQty;
  final double avgCost;
  final double lastCost;
  final DateTime updatedAt;
  const StockBalance({
    required this.stockId,
    required this.productId,
    required this.warehouseId,
    required this.quantity,
    required this.reservedQty,
    required this.avgCost,
    required this.lastCost,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['stock_id'] = Variable<String>(stockId);
    map['product_id'] = Variable<String>(productId);
    map['warehouse_id'] = Variable<String>(warehouseId);
    map['quantity'] = Variable<double>(quantity);
    map['reserved_qty'] = Variable<double>(reservedQty);
    map['avg_cost'] = Variable<double>(avgCost);
    map['last_cost'] = Variable<double>(lastCost);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  StockBalancesCompanion toCompanion(bool nullToAbsent) {
    return StockBalancesCompanion(
      stockId: Value(stockId),
      productId: Value(productId),
      warehouseId: Value(warehouseId),
      quantity: Value(quantity),
      reservedQty: Value(reservedQty),
      avgCost: Value(avgCost),
      lastCost: Value(lastCost),
      updatedAt: Value(updatedAt),
    );
  }

  factory StockBalance.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockBalance(
      stockId: serializer.fromJson<String>(json['stockId']),
      productId: serializer.fromJson<String>(json['productId']),
      warehouseId: serializer.fromJson<String>(json['warehouseId']),
      quantity: serializer.fromJson<double>(json['quantity']),
      reservedQty: serializer.fromJson<double>(json['reservedQty']),
      avgCost: serializer.fromJson<double>(json['avgCost']),
      lastCost: serializer.fromJson<double>(json['lastCost']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'stockId': serializer.toJson<String>(stockId),
      'productId': serializer.toJson<String>(productId),
      'warehouseId': serializer.toJson<String>(warehouseId),
      'quantity': serializer.toJson<double>(quantity),
      'reservedQty': serializer.toJson<double>(reservedQty),
      'avgCost': serializer.toJson<double>(avgCost),
      'lastCost': serializer.toJson<double>(lastCost),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  StockBalance copyWith({
    String? stockId,
    String? productId,
    String? warehouseId,
    double? quantity,
    double? reservedQty,
    double? avgCost,
    double? lastCost,
    DateTime? updatedAt,
  }) => StockBalance(
    stockId: stockId ?? this.stockId,
    productId: productId ?? this.productId,
    warehouseId: warehouseId ?? this.warehouseId,
    quantity: quantity ?? this.quantity,
    reservedQty: reservedQty ?? this.reservedQty,
    avgCost: avgCost ?? this.avgCost,
    lastCost: lastCost ?? this.lastCost,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  StockBalance copyWithCompanion(StockBalancesCompanion data) {
    return StockBalance(
      stockId: data.stockId.present ? data.stockId.value : this.stockId,
      productId: data.productId.present ? data.productId.value : this.productId,
      warehouseId: data.warehouseId.present
          ? data.warehouseId.value
          : this.warehouseId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      reservedQty: data.reservedQty.present
          ? data.reservedQty.value
          : this.reservedQty,
      avgCost: data.avgCost.present ? data.avgCost.value : this.avgCost,
      lastCost: data.lastCost.present ? data.lastCost.value : this.lastCost,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockBalance(')
          ..write('stockId: $stockId, ')
          ..write('productId: $productId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('quantity: $quantity, ')
          ..write('reservedQty: $reservedQty, ')
          ..write('avgCost: $avgCost, ')
          ..write('lastCost: $lastCost, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    stockId,
    productId,
    warehouseId,
    quantity,
    reservedQty,
    avgCost,
    lastCost,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockBalance &&
          other.stockId == this.stockId &&
          other.productId == this.productId &&
          other.warehouseId == this.warehouseId &&
          other.quantity == this.quantity &&
          other.reservedQty == this.reservedQty &&
          other.avgCost == this.avgCost &&
          other.lastCost == this.lastCost &&
          other.updatedAt == this.updatedAt);
}

class StockBalancesCompanion extends UpdateCompanion<StockBalance> {
  final Value<String> stockId;
  final Value<String> productId;
  final Value<String> warehouseId;
  final Value<double> quantity;
  final Value<double> reservedQty;
  final Value<double> avgCost;
  final Value<double> lastCost;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const StockBalancesCompanion({
    this.stockId = const Value.absent(),
    this.productId = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.reservedQty = const Value.absent(),
    this.avgCost = const Value.absent(),
    this.lastCost = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StockBalancesCompanion.insert({
    required String stockId,
    required String productId,
    required String warehouseId,
    this.quantity = const Value.absent(),
    this.reservedQty = const Value.absent(),
    this.avgCost = const Value.absent(),
    this.lastCost = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : stockId = Value(stockId),
       productId = Value(productId),
       warehouseId = Value(warehouseId);
  static Insertable<StockBalance> custom({
    Expression<String>? stockId,
    Expression<String>? productId,
    Expression<String>? warehouseId,
    Expression<double>? quantity,
    Expression<double>? reservedQty,
    Expression<double>? avgCost,
    Expression<double>? lastCost,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (stockId != null) 'stock_id': stockId,
      if (productId != null) 'product_id': productId,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (quantity != null) 'quantity': quantity,
      if (reservedQty != null) 'reserved_qty': reservedQty,
      if (avgCost != null) 'avg_cost': avgCost,
      if (lastCost != null) 'last_cost': lastCost,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StockBalancesCompanion copyWith({
    Value<String>? stockId,
    Value<String>? productId,
    Value<String>? warehouseId,
    Value<double>? quantity,
    Value<double>? reservedQty,
    Value<double>? avgCost,
    Value<double>? lastCost,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return StockBalancesCompanion(
      stockId: stockId ?? this.stockId,
      productId: productId ?? this.productId,
      warehouseId: warehouseId ?? this.warehouseId,
      quantity: quantity ?? this.quantity,
      reservedQty: reservedQty ?? this.reservedQty,
      avgCost: avgCost ?? this.avgCost,
      lastCost: lastCost ?? this.lastCost,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (stockId.present) {
      map['stock_id'] = Variable<String>(stockId.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<String>(warehouseId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (reservedQty.present) {
      map['reserved_qty'] = Variable<double>(reservedQty.value);
    }
    if (avgCost.present) {
      map['avg_cost'] = Variable<double>(avgCost.value);
    }
    if (lastCost.present) {
      map['last_cost'] = Variable<double>(lastCost.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockBalancesCompanion(')
          ..write('stockId: $stockId, ')
          ..write('productId: $productId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('quantity: $quantity, ')
          ..write('reservedQty: $reservedQty, ')
          ..write('avgCost: $avgCost, ')
          ..write('lastCost: $lastCost, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SerialNumbersTable extends SerialNumbers
    with TableInfo<$SerialNumbersTable, SerialNumber> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SerialNumbersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _serialIdMeta = const VerificationMeta(
    'serialId',
  );
  @override
  late final GeneratedColumn<String> serialId = GeneratedColumn<String>(
    'serial_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES products (product_id)',
    ),
  );
  static const VerificationMeta _serialNoMeta = const VerificationMeta(
    'serialNo',
  );
  @override
  late final GeneratedColumn<String> serialNo = GeneratedColumn<String>(
    'serial_no',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _warehouseIdMeta = const VerificationMeta(
    'warehouseId',
  );
  @override
  late final GeneratedColumn<String> warehouseId = GeneratedColumn<String>(
    'warehouse_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES warehouses (warehouse_id)',
    ),
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('AVAILABLE'),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    serialId,
    productId,
    serialNo,
    warehouseId,
    status,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'serial_numbers';
  @override
  VerificationContext validateIntegrity(
    Insertable<SerialNumber> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('serial_id')) {
      context.handle(
        _serialIdMeta,
        serialId.isAcceptableOrUnknown(data['serial_id']!, _serialIdMeta),
      );
    } else if (isInserting) {
      context.missing(_serialIdMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('serial_no')) {
      context.handle(
        _serialNoMeta,
        serialNo.isAcceptableOrUnknown(data['serial_no']!, _serialNoMeta),
      );
    } else if (isInserting) {
      context.missing(_serialNoMeta);
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
        _warehouseIdMeta,
        warehouseId.isAcceptableOrUnknown(
          data['warehouse_id']!,
          _warehouseIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {serialId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {serialNo},
  ];
  @override
  SerialNumber map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SerialNumber(
      serialId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}serial_id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_id'],
      )!,
      serialNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}serial_no'],
      )!,
      warehouseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}warehouse_id'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $SerialNumbersTable createAlias(String alias) {
    return $SerialNumbersTable(attachedDatabase, alias);
  }
}

class SerialNumber extends DataClass implements Insertable<SerialNumber> {
  final String serialId;
  final String productId;
  final String serialNo;
  final String warehouseId;
  final String status;
  final DateTime createdAt;
  const SerialNumber({
    required this.serialId,
    required this.productId,
    required this.serialNo,
    required this.warehouseId,
    required this.status,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['serial_id'] = Variable<String>(serialId);
    map['product_id'] = Variable<String>(productId);
    map['serial_no'] = Variable<String>(serialNo);
    map['warehouse_id'] = Variable<String>(warehouseId);
    map['status'] = Variable<String>(status);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  SerialNumbersCompanion toCompanion(bool nullToAbsent) {
    return SerialNumbersCompanion(
      serialId: Value(serialId),
      productId: Value(productId),
      serialNo: Value(serialNo),
      warehouseId: Value(warehouseId),
      status: Value(status),
      createdAt: Value(createdAt),
    );
  }

  factory SerialNumber.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SerialNumber(
      serialId: serializer.fromJson<String>(json['serialId']),
      productId: serializer.fromJson<String>(json['productId']),
      serialNo: serializer.fromJson<String>(json['serialNo']),
      warehouseId: serializer.fromJson<String>(json['warehouseId']),
      status: serializer.fromJson<String>(json['status']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'serialId': serializer.toJson<String>(serialId),
      'productId': serializer.toJson<String>(productId),
      'serialNo': serializer.toJson<String>(serialNo),
      'warehouseId': serializer.toJson<String>(warehouseId),
      'status': serializer.toJson<String>(status),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  SerialNumber copyWith({
    String? serialId,
    String? productId,
    String? serialNo,
    String? warehouseId,
    String? status,
    DateTime? createdAt,
  }) => SerialNumber(
    serialId: serialId ?? this.serialId,
    productId: productId ?? this.productId,
    serialNo: serialNo ?? this.serialNo,
    warehouseId: warehouseId ?? this.warehouseId,
    status: status ?? this.status,
    createdAt: createdAt ?? this.createdAt,
  );
  SerialNumber copyWithCompanion(SerialNumbersCompanion data) {
    return SerialNumber(
      serialId: data.serialId.present ? data.serialId.value : this.serialId,
      productId: data.productId.present ? data.productId.value : this.productId,
      serialNo: data.serialNo.present ? data.serialNo.value : this.serialNo,
      warehouseId: data.warehouseId.present
          ? data.warehouseId.value
          : this.warehouseId,
      status: data.status.present ? data.status.value : this.status,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SerialNumber(')
          ..write('serialId: $serialId, ')
          ..write('productId: $productId, ')
          ..write('serialNo: $serialNo, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    serialId,
    productId,
    serialNo,
    warehouseId,
    status,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SerialNumber &&
          other.serialId == this.serialId &&
          other.productId == this.productId &&
          other.serialNo == this.serialNo &&
          other.warehouseId == this.warehouseId &&
          other.status == this.status &&
          other.createdAt == this.createdAt);
}

class SerialNumbersCompanion extends UpdateCompanion<SerialNumber> {
  final Value<String> serialId;
  final Value<String> productId;
  final Value<String> serialNo;
  final Value<String> warehouseId;
  final Value<String> status;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const SerialNumbersCompanion({
    this.serialId = const Value.absent(),
    this.productId = const Value.absent(),
    this.serialNo = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SerialNumbersCompanion.insert({
    required String serialId,
    required String productId,
    required String serialNo,
    required String warehouseId,
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : serialId = Value(serialId),
       productId = Value(productId),
       serialNo = Value(serialNo),
       warehouseId = Value(warehouseId);
  static Insertable<SerialNumber> custom({
    Expression<String>? serialId,
    Expression<String>? productId,
    Expression<String>? serialNo,
    Expression<String>? warehouseId,
    Expression<String>? status,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (serialId != null) 'serial_id': serialId,
      if (productId != null) 'product_id': productId,
      if (serialNo != null) 'serial_no': serialNo,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (status != null) 'status': status,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SerialNumbersCompanion copyWith({
    Value<String>? serialId,
    Value<String>? productId,
    Value<String>? serialNo,
    Value<String>? warehouseId,
    Value<String>? status,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return SerialNumbersCompanion(
      serialId: serialId ?? this.serialId,
      productId: productId ?? this.productId,
      serialNo: serialNo ?? this.serialNo,
      warehouseId: warehouseId ?? this.warehouseId,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (serialId.present) {
      map['serial_id'] = Variable<String>(serialId.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (serialNo.present) {
      map['serial_no'] = Variable<String>(serialNo.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<String>(warehouseId.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SerialNumbersCompanion(')
          ..write('serialId: $serialId, ')
          ..write('productId: $productId, ')
          ..write('serialNo: $serialNo, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ModifierGroupsTable extends ModifierGroups
    with TableInfo<$ModifierGroupsTable, ModifierGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ModifierGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _modifierGroupIdMeta = const VerificationMeta(
    'modifierGroupId',
  );
  @override
  late final GeneratedColumn<String> modifierGroupId = GeneratedColumn<String>(
    'modifier_group_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _groupNameMeta = const VerificationMeta(
    'groupName',
  );
  @override
  late final GeneratedColumn<String> groupName = GeneratedColumn<String>(
    'group_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _selectionTypeMeta = const VerificationMeta(
    'selectionType',
  );
  @override
  late final GeneratedColumn<String> selectionType = GeneratedColumn<String>(
    'selection_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('SINGLE'),
  );
  static const VerificationMeta _minSelectionMeta = const VerificationMeta(
    'minSelection',
  );
  @override
  late final GeneratedColumn<int> minSelection = GeneratedColumn<int>(
    'min_selection',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _maxSelectionMeta = const VerificationMeta(
    'maxSelection',
  );
  @override
  late final GeneratedColumn<int> maxSelection = GeneratedColumn<int>(
    'max_selection',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _isRequiredMeta = const VerificationMeta(
    'isRequired',
  );
  @override
  late final GeneratedColumn<bool> isRequired = GeneratedColumn<bool>(
    'is_required',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_required" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    modifierGroupId,
    groupName,
    selectionType,
    minSelection,
    maxSelection,
    isRequired,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'modifier_groups';
  @override
  VerificationContext validateIntegrity(
    Insertable<ModifierGroup> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('modifier_group_id')) {
      context.handle(
        _modifierGroupIdMeta,
        modifierGroupId.isAcceptableOrUnknown(
          data['modifier_group_id']!,
          _modifierGroupIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_modifierGroupIdMeta);
    }
    if (data.containsKey('group_name')) {
      context.handle(
        _groupNameMeta,
        groupName.isAcceptableOrUnknown(data['group_name']!, _groupNameMeta),
      );
    } else if (isInserting) {
      context.missing(_groupNameMeta);
    }
    if (data.containsKey('selection_type')) {
      context.handle(
        _selectionTypeMeta,
        selectionType.isAcceptableOrUnknown(
          data['selection_type']!,
          _selectionTypeMeta,
        ),
      );
    }
    if (data.containsKey('min_selection')) {
      context.handle(
        _minSelectionMeta,
        minSelection.isAcceptableOrUnknown(
          data['min_selection']!,
          _minSelectionMeta,
        ),
      );
    }
    if (data.containsKey('max_selection')) {
      context.handle(
        _maxSelectionMeta,
        maxSelection.isAcceptableOrUnknown(
          data['max_selection']!,
          _maxSelectionMeta,
        ),
      );
    }
    if (data.containsKey('is_required')) {
      context.handle(
        _isRequiredMeta,
        isRequired.isAcceptableOrUnknown(data['is_required']!, _isRequiredMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {modifierGroupId};
  @override
  ModifierGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ModifierGroup(
      modifierGroupId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}modifier_group_id'],
      )!,
      groupName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}group_name'],
      )!,
      selectionType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}selection_type'],
      )!,
      minSelection: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}min_selection'],
      )!,
      maxSelection: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_selection'],
      )!,
      isRequired: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_required'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ModifierGroupsTable createAlias(String alias) {
    return $ModifierGroupsTable(attachedDatabase, alias);
  }
}

class ModifierGroup extends DataClass implements Insertable<ModifierGroup> {
  final String modifierGroupId;
  final String groupName;
  final String selectionType;
  final int minSelection;
  final int maxSelection;
  final bool isRequired;
  final DateTime createdAt;
  const ModifierGroup({
    required this.modifierGroupId,
    required this.groupName,
    required this.selectionType,
    required this.minSelection,
    required this.maxSelection,
    required this.isRequired,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['modifier_group_id'] = Variable<String>(modifierGroupId);
    map['group_name'] = Variable<String>(groupName);
    map['selection_type'] = Variable<String>(selectionType);
    map['min_selection'] = Variable<int>(minSelection);
    map['max_selection'] = Variable<int>(maxSelection);
    map['is_required'] = Variable<bool>(isRequired);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ModifierGroupsCompanion toCompanion(bool nullToAbsent) {
    return ModifierGroupsCompanion(
      modifierGroupId: Value(modifierGroupId),
      groupName: Value(groupName),
      selectionType: Value(selectionType),
      minSelection: Value(minSelection),
      maxSelection: Value(maxSelection),
      isRequired: Value(isRequired),
      createdAt: Value(createdAt),
    );
  }

  factory ModifierGroup.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ModifierGroup(
      modifierGroupId: serializer.fromJson<String>(json['modifierGroupId']),
      groupName: serializer.fromJson<String>(json['groupName']),
      selectionType: serializer.fromJson<String>(json['selectionType']),
      minSelection: serializer.fromJson<int>(json['minSelection']),
      maxSelection: serializer.fromJson<int>(json['maxSelection']),
      isRequired: serializer.fromJson<bool>(json['isRequired']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'modifierGroupId': serializer.toJson<String>(modifierGroupId),
      'groupName': serializer.toJson<String>(groupName),
      'selectionType': serializer.toJson<String>(selectionType),
      'minSelection': serializer.toJson<int>(minSelection),
      'maxSelection': serializer.toJson<int>(maxSelection),
      'isRequired': serializer.toJson<bool>(isRequired),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  ModifierGroup copyWith({
    String? modifierGroupId,
    String? groupName,
    String? selectionType,
    int? minSelection,
    int? maxSelection,
    bool? isRequired,
    DateTime? createdAt,
  }) => ModifierGroup(
    modifierGroupId: modifierGroupId ?? this.modifierGroupId,
    groupName: groupName ?? this.groupName,
    selectionType: selectionType ?? this.selectionType,
    minSelection: minSelection ?? this.minSelection,
    maxSelection: maxSelection ?? this.maxSelection,
    isRequired: isRequired ?? this.isRequired,
    createdAt: createdAt ?? this.createdAt,
  );
  ModifierGroup copyWithCompanion(ModifierGroupsCompanion data) {
    return ModifierGroup(
      modifierGroupId: data.modifierGroupId.present
          ? data.modifierGroupId.value
          : this.modifierGroupId,
      groupName: data.groupName.present ? data.groupName.value : this.groupName,
      selectionType: data.selectionType.present
          ? data.selectionType.value
          : this.selectionType,
      minSelection: data.minSelection.present
          ? data.minSelection.value
          : this.minSelection,
      maxSelection: data.maxSelection.present
          ? data.maxSelection.value
          : this.maxSelection,
      isRequired: data.isRequired.present
          ? data.isRequired.value
          : this.isRequired,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ModifierGroup(')
          ..write('modifierGroupId: $modifierGroupId, ')
          ..write('groupName: $groupName, ')
          ..write('selectionType: $selectionType, ')
          ..write('minSelection: $minSelection, ')
          ..write('maxSelection: $maxSelection, ')
          ..write('isRequired: $isRequired, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    modifierGroupId,
    groupName,
    selectionType,
    minSelection,
    maxSelection,
    isRequired,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ModifierGroup &&
          other.modifierGroupId == this.modifierGroupId &&
          other.groupName == this.groupName &&
          other.selectionType == this.selectionType &&
          other.minSelection == this.minSelection &&
          other.maxSelection == this.maxSelection &&
          other.isRequired == this.isRequired &&
          other.createdAt == this.createdAt);
}

class ModifierGroupsCompanion extends UpdateCompanion<ModifierGroup> {
  final Value<String> modifierGroupId;
  final Value<String> groupName;
  final Value<String> selectionType;
  final Value<int> minSelection;
  final Value<int> maxSelection;
  final Value<bool> isRequired;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ModifierGroupsCompanion({
    this.modifierGroupId = const Value.absent(),
    this.groupName = const Value.absent(),
    this.selectionType = const Value.absent(),
    this.minSelection = const Value.absent(),
    this.maxSelection = const Value.absent(),
    this.isRequired = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ModifierGroupsCompanion.insert({
    required String modifierGroupId,
    required String groupName,
    this.selectionType = const Value.absent(),
    this.minSelection = const Value.absent(),
    this.maxSelection = const Value.absent(),
    this.isRequired = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : modifierGroupId = Value(modifierGroupId),
       groupName = Value(groupName);
  static Insertable<ModifierGroup> custom({
    Expression<String>? modifierGroupId,
    Expression<String>? groupName,
    Expression<String>? selectionType,
    Expression<int>? minSelection,
    Expression<int>? maxSelection,
    Expression<bool>? isRequired,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (modifierGroupId != null) 'modifier_group_id': modifierGroupId,
      if (groupName != null) 'group_name': groupName,
      if (selectionType != null) 'selection_type': selectionType,
      if (minSelection != null) 'min_selection': minSelection,
      if (maxSelection != null) 'max_selection': maxSelection,
      if (isRequired != null) 'is_required': isRequired,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ModifierGroupsCompanion copyWith({
    Value<String>? modifierGroupId,
    Value<String>? groupName,
    Value<String>? selectionType,
    Value<int>? minSelection,
    Value<int>? maxSelection,
    Value<bool>? isRequired,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ModifierGroupsCompanion(
      modifierGroupId: modifierGroupId ?? this.modifierGroupId,
      groupName: groupName ?? this.groupName,
      selectionType: selectionType ?? this.selectionType,
      minSelection: minSelection ?? this.minSelection,
      maxSelection: maxSelection ?? this.maxSelection,
      isRequired: isRequired ?? this.isRequired,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (modifierGroupId.present) {
      map['modifier_group_id'] = Variable<String>(modifierGroupId.value);
    }
    if (groupName.present) {
      map['group_name'] = Variable<String>(groupName.value);
    }
    if (selectionType.present) {
      map['selection_type'] = Variable<String>(selectionType.value);
    }
    if (minSelection.present) {
      map['min_selection'] = Variable<int>(minSelection.value);
    }
    if (maxSelection.present) {
      map['max_selection'] = Variable<int>(maxSelection.value);
    }
    if (isRequired.present) {
      map['is_required'] = Variable<bool>(isRequired.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ModifierGroupsCompanion(')
          ..write('modifierGroupId: $modifierGroupId, ')
          ..write('groupName: $groupName, ')
          ..write('selectionType: $selectionType, ')
          ..write('minSelection: $minSelection, ')
          ..write('maxSelection: $maxSelection, ')
          ..write('isRequired: $isRequired, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ModifiersTable extends Modifiers
    with TableInfo<$ModifiersTable, Modifier> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ModifiersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _modifierIdMeta = const VerificationMeta(
    'modifierId',
  );
  @override
  late final GeneratedColumn<String> modifierId = GeneratedColumn<String>(
    'modifier_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _modifierGroupIdMeta = const VerificationMeta(
    'modifierGroupId',
  );
  @override
  late final GeneratedColumn<String> modifierGroupId = GeneratedColumn<String>(
    'modifier_group_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES modifier_groups (modifier_group_id)',
    ),
  );
  static const VerificationMeta _modifierNameMeta = const VerificationMeta(
    'modifierName',
  );
  @override
  late final GeneratedColumn<String> modifierName = GeneratedColumn<String>(
    'modifier_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _priceAdjustmentMeta = const VerificationMeta(
    'priceAdjustment',
  );
  @override
  late final GeneratedColumn<double> priceAdjustment = GeneratedColumn<double>(
    'price_adjustment',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isDefaultMeta = const VerificationMeta(
    'isDefault',
  );
  @override
  late final GeneratedColumn<bool> isDefault = GeneratedColumn<bool>(
    'is_default',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_default" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _displayOrderMeta = const VerificationMeta(
    'displayOrder',
  );
  @override
  late final GeneratedColumn<int> displayOrder = GeneratedColumn<int>(
    'display_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    modifierId,
    modifierGroupId,
    modifierName,
    priceAdjustment,
    isDefault,
    displayOrder,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'modifiers';
  @override
  VerificationContext validateIntegrity(
    Insertable<Modifier> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('modifier_id')) {
      context.handle(
        _modifierIdMeta,
        modifierId.isAcceptableOrUnknown(data['modifier_id']!, _modifierIdMeta),
      );
    } else if (isInserting) {
      context.missing(_modifierIdMeta);
    }
    if (data.containsKey('modifier_group_id')) {
      context.handle(
        _modifierGroupIdMeta,
        modifierGroupId.isAcceptableOrUnknown(
          data['modifier_group_id']!,
          _modifierGroupIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_modifierGroupIdMeta);
    }
    if (data.containsKey('modifier_name')) {
      context.handle(
        _modifierNameMeta,
        modifierName.isAcceptableOrUnknown(
          data['modifier_name']!,
          _modifierNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_modifierNameMeta);
    }
    if (data.containsKey('price_adjustment')) {
      context.handle(
        _priceAdjustmentMeta,
        priceAdjustment.isAcceptableOrUnknown(
          data['price_adjustment']!,
          _priceAdjustmentMeta,
        ),
      );
    }
    if (data.containsKey('is_default')) {
      context.handle(
        _isDefaultMeta,
        isDefault.isAcceptableOrUnknown(data['is_default']!, _isDefaultMeta),
      );
    }
    if (data.containsKey('display_order')) {
      context.handle(
        _displayOrderMeta,
        displayOrder.isAcceptableOrUnknown(
          data['display_order']!,
          _displayOrderMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {modifierId};
  @override
  Modifier map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Modifier(
      modifierId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}modifier_id'],
      )!,
      modifierGroupId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}modifier_group_id'],
      )!,
      modifierName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}modifier_name'],
      )!,
      priceAdjustment: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_adjustment'],
      )!,
      isDefault: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_default'],
      )!,
      displayOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}display_order'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ModifiersTable createAlias(String alias) {
    return $ModifiersTable(attachedDatabase, alias);
  }
}

class Modifier extends DataClass implements Insertable<Modifier> {
  final String modifierId;
  final String modifierGroupId;
  final String modifierName;
  final double priceAdjustment;
  final bool isDefault;
  final int displayOrder;
  final DateTime createdAt;
  const Modifier({
    required this.modifierId,
    required this.modifierGroupId,
    required this.modifierName,
    required this.priceAdjustment,
    required this.isDefault,
    required this.displayOrder,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['modifier_id'] = Variable<String>(modifierId);
    map['modifier_group_id'] = Variable<String>(modifierGroupId);
    map['modifier_name'] = Variable<String>(modifierName);
    map['price_adjustment'] = Variable<double>(priceAdjustment);
    map['is_default'] = Variable<bool>(isDefault);
    map['display_order'] = Variable<int>(displayOrder);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ModifiersCompanion toCompanion(bool nullToAbsent) {
    return ModifiersCompanion(
      modifierId: Value(modifierId),
      modifierGroupId: Value(modifierGroupId),
      modifierName: Value(modifierName),
      priceAdjustment: Value(priceAdjustment),
      isDefault: Value(isDefault),
      displayOrder: Value(displayOrder),
      createdAt: Value(createdAt),
    );
  }

  factory Modifier.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Modifier(
      modifierId: serializer.fromJson<String>(json['modifierId']),
      modifierGroupId: serializer.fromJson<String>(json['modifierGroupId']),
      modifierName: serializer.fromJson<String>(json['modifierName']),
      priceAdjustment: serializer.fromJson<double>(json['priceAdjustment']),
      isDefault: serializer.fromJson<bool>(json['isDefault']),
      displayOrder: serializer.fromJson<int>(json['displayOrder']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'modifierId': serializer.toJson<String>(modifierId),
      'modifierGroupId': serializer.toJson<String>(modifierGroupId),
      'modifierName': serializer.toJson<String>(modifierName),
      'priceAdjustment': serializer.toJson<double>(priceAdjustment),
      'isDefault': serializer.toJson<bool>(isDefault),
      'displayOrder': serializer.toJson<int>(displayOrder),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Modifier copyWith({
    String? modifierId,
    String? modifierGroupId,
    String? modifierName,
    double? priceAdjustment,
    bool? isDefault,
    int? displayOrder,
    DateTime? createdAt,
  }) => Modifier(
    modifierId: modifierId ?? this.modifierId,
    modifierGroupId: modifierGroupId ?? this.modifierGroupId,
    modifierName: modifierName ?? this.modifierName,
    priceAdjustment: priceAdjustment ?? this.priceAdjustment,
    isDefault: isDefault ?? this.isDefault,
    displayOrder: displayOrder ?? this.displayOrder,
    createdAt: createdAt ?? this.createdAt,
  );
  Modifier copyWithCompanion(ModifiersCompanion data) {
    return Modifier(
      modifierId: data.modifierId.present
          ? data.modifierId.value
          : this.modifierId,
      modifierGroupId: data.modifierGroupId.present
          ? data.modifierGroupId.value
          : this.modifierGroupId,
      modifierName: data.modifierName.present
          ? data.modifierName.value
          : this.modifierName,
      priceAdjustment: data.priceAdjustment.present
          ? data.priceAdjustment.value
          : this.priceAdjustment,
      isDefault: data.isDefault.present ? data.isDefault.value : this.isDefault,
      displayOrder: data.displayOrder.present
          ? data.displayOrder.value
          : this.displayOrder,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Modifier(')
          ..write('modifierId: $modifierId, ')
          ..write('modifierGroupId: $modifierGroupId, ')
          ..write('modifierName: $modifierName, ')
          ..write('priceAdjustment: $priceAdjustment, ')
          ..write('isDefault: $isDefault, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    modifierId,
    modifierGroupId,
    modifierName,
    priceAdjustment,
    isDefault,
    displayOrder,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Modifier &&
          other.modifierId == this.modifierId &&
          other.modifierGroupId == this.modifierGroupId &&
          other.modifierName == this.modifierName &&
          other.priceAdjustment == this.priceAdjustment &&
          other.isDefault == this.isDefault &&
          other.displayOrder == this.displayOrder &&
          other.createdAt == this.createdAt);
}

class ModifiersCompanion extends UpdateCompanion<Modifier> {
  final Value<String> modifierId;
  final Value<String> modifierGroupId;
  final Value<String> modifierName;
  final Value<double> priceAdjustment;
  final Value<bool> isDefault;
  final Value<int> displayOrder;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ModifiersCompanion({
    this.modifierId = const Value.absent(),
    this.modifierGroupId = const Value.absent(),
    this.modifierName = const Value.absent(),
    this.priceAdjustment = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.displayOrder = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ModifiersCompanion.insert({
    required String modifierId,
    required String modifierGroupId,
    required String modifierName,
    this.priceAdjustment = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.displayOrder = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : modifierId = Value(modifierId),
       modifierGroupId = Value(modifierGroupId),
       modifierName = Value(modifierName);
  static Insertable<Modifier> custom({
    Expression<String>? modifierId,
    Expression<String>? modifierGroupId,
    Expression<String>? modifierName,
    Expression<double>? priceAdjustment,
    Expression<bool>? isDefault,
    Expression<int>? displayOrder,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (modifierId != null) 'modifier_id': modifierId,
      if (modifierGroupId != null) 'modifier_group_id': modifierGroupId,
      if (modifierName != null) 'modifier_name': modifierName,
      if (priceAdjustment != null) 'price_adjustment': priceAdjustment,
      if (isDefault != null) 'is_default': isDefault,
      if (displayOrder != null) 'display_order': displayOrder,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ModifiersCompanion copyWith({
    Value<String>? modifierId,
    Value<String>? modifierGroupId,
    Value<String>? modifierName,
    Value<double>? priceAdjustment,
    Value<bool>? isDefault,
    Value<int>? displayOrder,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ModifiersCompanion(
      modifierId: modifierId ?? this.modifierId,
      modifierGroupId: modifierGroupId ?? this.modifierGroupId,
      modifierName: modifierName ?? this.modifierName,
      priceAdjustment: priceAdjustment ?? this.priceAdjustment,
      isDefault: isDefault ?? this.isDefault,
      displayOrder: displayOrder ?? this.displayOrder,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (modifierId.present) {
      map['modifier_id'] = Variable<String>(modifierId.value);
    }
    if (modifierGroupId.present) {
      map['modifier_group_id'] = Variable<String>(modifierGroupId.value);
    }
    if (modifierName.present) {
      map['modifier_name'] = Variable<String>(modifierName.value);
    }
    if (priceAdjustment.present) {
      map['price_adjustment'] = Variable<double>(priceAdjustment.value);
    }
    if (isDefault.present) {
      map['is_default'] = Variable<bool>(isDefault.value);
    }
    if (displayOrder.present) {
      map['display_order'] = Variable<int>(displayOrder.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ModifiersCompanion(')
          ..write('modifierId: $modifierId, ')
          ..write('modifierGroupId: $modifierGroupId, ')
          ..write('modifierName: $modifierName, ')
          ..write('priceAdjustment: $priceAdjustment, ')
          ..write('isDefault: $isDefault, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProductModifiersTable extends ProductModifiers
    with TableInfo<$ProductModifiersTable, ProductModifier> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductModifiersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES products (product_id)',
    ),
  );
  static const VerificationMeta _modifierGroupIdMeta = const VerificationMeta(
    'modifierGroupId',
  );
  @override
  late final GeneratedColumn<String> modifierGroupId = GeneratedColumn<String>(
    'modifier_group_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES modifier_groups (modifier_group_id)',
    ),
  );
  static const VerificationMeta _isRequiredMeta = const VerificationMeta(
    'isRequired',
  );
  @override
  late final GeneratedColumn<bool> isRequired = GeneratedColumn<bool>(
    'is_required',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_required" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    productId,
    modifierGroupId,
    isRequired,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'product_modifiers';
  @override
  VerificationContext validateIntegrity(
    Insertable<ProductModifier> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('modifier_group_id')) {
      context.handle(
        _modifierGroupIdMeta,
        modifierGroupId.isAcceptableOrUnknown(
          data['modifier_group_id']!,
          _modifierGroupIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_modifierGroupIdMeta);
    }
    if (data.containsKey('is_required')) {
      context.handle(
        _isRequiredMeta,
        isRequired.isAcceptableOrUnknown(data['is_required']!, _isRequiredMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {productId, modifierGroupId};
  @override
  ProductModifier map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProductModifier(
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_id'],
      )!,
      modifierGroupId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}modifier_group_id'],
      )!,
      isRequired: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_required'],
      )!,
    );
  }

  @override
  $ProductModifiersTable createAlias(String alias) {
    return $ProductModifiersTable(attachedDatabase, alias);
  }
}

class ProductModifier extends DataClass implements Insertable<ProductModifier> {
  final String productId;
  final String modifierGroupId;
  final bool isRequired;
  const ProductModifier({
    required this.productId,
    required this.modifierGroupId,
    required this.isRequired,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['product_id'] = Variable<String>(productId);
    map['modifier_group_id'] = Variable<String>(modifierGroupId);
    map['is_required'] = Variable<bool>(isRequired);
    return map;
  }

  ProductModifiersCompanion toCompanion(bool nullToAbsent) {
    return ProductModifiersCompanion(
      productId: Value(productId),
      modifierGroupId: Value(modifierGroupId),
      isRequired: Value(isRequired),
    );
  }

  factory ProductModifier.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProductModifier(
      productId: serializer.fromJson<String>(json['productId']),
      modifierGroupId: serializer.fromJson<String>(json['modifierGroupId']),
      isRequired: serializer.fromJson<bool>(json['isRequired']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'productId': serializer.toJson<String>(productId),
      'modifierGroupId': serializer.toJson<String>(modifierGroupId),
      'isRequired': serializer.toJson<bool>(isRequired),
    };
  }

  ProductModifier copyWith({
    String? productId,
    String? modifierGroupId,
    bool? isRequired,
  }) => ProductModifier(
    productId: productId ?? this.productId,
    modifierGroupId: modifierGroupId ?? this.modifierGroupId,
    isRequired: isRequired ?? this.isRequired,
  );
  ProductModifier copyWithCompanion(ProductModifiersCompanion data) {
    return ProductModifier(
      productId: data.productId.present ? data.productId.value : this.productId,
      modifierGroupId: data.modifierGroupId.present
          ? data.modifierGroupId.value
          : this.modifierGroupId,
      isRequired: data.isRequired.present
          ? data.isRequired.value
          : this.isRequired,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ProductModifier(')
          ..write('productId: $productId, ')
          ..write('modifierGroupId: $modifierGroupId, ')
          ..write('isRequired: $isRequired')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(productId, modifierGroupId, isRequired);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProductModifier &&
          other.productId == this.productId &&
          other.modifierGroupId == this.modifierGroupId &&
          other.isRequired == this.isRequired);
}

class ProductModifiersCompanion extends UpdateCompanion<ProductModifier> {
  final Value<String> productId;
  final Value<String> modifierGroupId;
  final Value<bool> isRequired;
  final Value<int> rowid;
  const ProductModifiersCompanion({
    this.productId = const Value.absent(),
    this.modifierGroupId = const Value.absent(),
    this.isRequired = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProductModifiersCompanion.insert({
    required String productId,
    required String modifierGroupId,
    this.isRequired = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : productId = Value(productId),
       modifierGroupId = Value(modifierGroupId);
  static Insertable<ProductModifier> custom({
    Expression<String>? productId,
    Expression<String>? modifierGroupId,
    Expression<bool>? isRequired,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (productId != null) 'product_id': productId,
      if (modifierGroupId != null) 'modifier_group_id': modifierGroupId,
      if (isRequired != null) 'is_required': isRequired,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProductModifiersCompanion copyWith({
    Value<String>? productId,
    Value<String>? modifierGroupId,
    Value<bool>? isRequired,
    Value<int>? rowid,
  }) {
    return ProductModifiersCompanion(
      productId: productId ?? this.productId,
      modifierGroupId: modifierGroupId ?? this.modifierGroupId,
      isRequired: isRequired ?? this.isRequired,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (modifierGroupId.present) {
      map['modifier_group_id'] = Variable<String>(modifierGroupId.value);
    }
    if (isRequired.present) {
      map['is_required'] = Variable<bool>(isRequired.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductModifiersCompanion(')
          ..write('productId: $productId, ')
          ..write('modifierGroupId: $modifierGroupId, ')
          ..write('isRequired: $isRequired, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ZonesTable extends Zones with TableInfo<$ZonesTable, Zone> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ZonesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _zoneIdMeta = const VerificationMeta('zoneId');
  @override
  late final GeneratedColumn<String> zoneId = GeneratedColumn<String>(
    'zone_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _zoneNameMeta = const VerificationMeta(
    'zoneName',
  );
  @override
  late final GeneratedColumn<String> zoneName = GeneratedColumn<String>(
    'zone_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES branches (branch_id)',
    ),
  );
  static const VerificationMeta _displayOrderMeta = const VerificationMeta(
    'displayOrder',
  );
  @override
  late final GeneratedColumn<int> displayOrder = GeneratedColumn<int>(
    'display_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    zoneId,
    zoneName,
    branchId,
    displayOrder,
    isActive,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'zones';
  @override
  VerificationContext validateIntegrity(
    Insertable<Zone> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('zone_id')) {
      context.handle(
        _zoneIdMeta,
        zoneId.isAcceptableOrUnknown(data['zone_id']!, _zoneIdMeta),
      );
    } else if (isInserting) {
      context.missing(_zoneIdMeta);
    }
    if (data.containsKey('zone_name')) {
      context.handle(
        _zoneNameMeta,
        zoneName.isAcceptableOrUnknown(data['zone_name']!, _zoneNameMeta),
      );
    } else if (isInserting) {
      context.missing(_zoneNameMeta);
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    } else if (isInserting) {
      context.missing(_branchIdMeta);
    }
    if (data.containsKey('display_order')) {
      context.handle(
        _displayOrderMeta,
        displayOrder.isAcceptableOrUnknown(
          data['display_order']!,
          _displayOrderMeta,
        ),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {zoneId};
  @override
  Zone map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Zone(
      zoneId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}zone_id'],
      )!,
      zoneName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}zone_name'],
      )!,
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      )!,
      displayOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}display_order'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ZonesTable createAlias(String alias) {
    return $ZonesTable(attachedDatabase, alias);
  }
}

class Zone extends DataClass implements Insertable<Zone> {
  final String zoneId;
  final String zoneName;
  final String branchId;
  final int displayOrder;
  final bool isActive;
  final DateTime createdAt;
  const Zone({
    required this.zoneId,
    required this.zoneName,
    required this.branchId,
    required this.displayOrder,
    required this.isActive,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['zone_id'] = Variable<String>(zoneId);
    map['zone_name'] = Variable<String>(zoneName);
    map['branch_id'] = Variable<String>(branchId);
    map['display_order'] = Variable<int>(displayOrder);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ZonesCompanion toCompanion(bool nullToAbsent) {
    return ZonesCompanion(
      zoneId: Value(zoneId),
      zoneName: Value(zoneName),
      branchId: Value(branchId),
      displayOrder: Value(displayOrder),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
    );
  }

  factory Zone.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Zone(
      zoneId: serializer.fromJson<String>(json['zoneId']),
      zoneName: serializer.fromJson<String>(json['zoneName']),
      branchId: serializer.fromJson<String>(json['branchId']),
      displayOrder: serializer.fromJson<int>(json['displayOrder']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'zoneId': serializer.toJson<String>(zoneId),
      'zoneName': serializer.toJson<String>(zoneName),
      'branchId': serializer.toJson<String>(branchId),
      'displayOrder': serializer.toJson<int>(displayOrder),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Zone copyWith({
    String? zoneId,
    String? zoneName,
    String? branchId,
    int? displayOrder,
    bool? isActive,
    DateTime? createdAt,
  }) => Zone(
    zoneId: zoneId ?? this.zoneId,
    zoneName: zoneName ?? this.zoneName,
    branchId: branchId ?? this.branchId,
    displayOrder: displayOrder ?? this.displayOrder,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
  );
  Zone copyWithCompanion(ZonesCompanion data) {
    return Zone(
      zoneId: data.zoneId.present ? data.zoneId.value : this.zoneId,
      zoneName: data.zoneName.present ? data.zoneName.value : this.zoneName,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      displayOrder: data.displayOrder.present
          ? data.displayOrder.value
          : this.displayOrder,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Zone(')
          ..write('zoneId: $zoneId, ')
          ..write('zoneName: $zoneName, ')
          ..write('branchId: $branchId, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    zoneId,
    zoneName,
    branchId,
    displayOrder,
    isActive,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Zone &&
          other.zoneId == this.zoneId &&
          other.zoneName == this.zoneName &&
          other.branchId == this.branchId &&
          other.displayOrder == this.displayOrder &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt);
}

class ZonesCompanion extends UpdateCompanion<Zone> {
  final Value<String> zoneId;
  final Value<String> zoneName;
  final Value<String> branchId;
  final Value<int> displayOrder;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ZonesCompanion({
    this.zoneId = const Value.absent(),
    this.zoneName = const Value.absent(),
    this.branchId = const Value.absent(),
    this.displayOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ZonesCompanion.insert({
    required String zoneId,
    required String zoneName,
    required String branchId,
    this.displayOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : zoneId = Value(zoneId),
       zoneName = Value(zoneName),
       branchId = Value(branchId);
  static Insertable<Zone> custom({
    Expression<String>? zoneId,
    Expression<String>? zoneName,
    Expression<String>? branchId,
    Expression<int>? displayOrder,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (zoneId != null) 'zone_id': zoneId,
      if (zoneName != null) 'zone_name': zoneName,
      if (branchId != null) 'branch_id': branchId,
      if (displayOrder != null) 'display_order': displayOrder,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ZonesCompanion copyWith({
    Value<String>? zoneId,
    Value<String>? zoneName,
    Value<String>? branchId,
    Value<int>? displayOrder,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ZonesCompanion(
      zoneId: zoneId ?? this.zoneId,
      zoneName: zoneName ?? this.zoneName,
      branchId: branchId ?? this.branchId,
      displayOrder: displayOrder ?? this.displayOrder,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (zoneId.present) {
      map['zone_id'] = Variable<String>(zoneId.value);
    }
    if (zoneName.present) {
      map['zone_name'] = Variable<String>(zoneName.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (displayOrder.present) {
      map['display_order'] = Variable<int>(displayOrder.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ZonesCompanion(')
          ..write('zoneId: $zoneId, ')
          ..write('zoneName: $zoneName, ')
          ..write('branchId: $branchId, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DiningTablesTable extends DiningTables
    with TableInfo<$DiningTablesTable, DiningTable> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DiningTablesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tableIdMeta = const VerificationMeta(
    'tableId',
  );
  @override
  late final GeneratedColumn<String> tableId = GeneratedColumn<String>(
    'table_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tableNoMeta = const VerificationMeta(
    'tableNo',
  );
  @override
  late final GeneratedColumn<String> tableNo = GeneratedColumn<String>(
    'table_no',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tableDisplayNameMeta = const VerificationMeta(
    'tableDisplayName',
  );
  @override
  late final GeneratedColumn<String> tableDisplayName = GeneratedColumn<String>(
    'table_display_name',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _zoneIdMeta = const VerificationMeta('zoneId');
  @override
  late final GeneratedColumn<String> zoneId = GeneratedColumn<String>(
    'zone_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES zones (zone_id)',
    ),
  );
  static const VerificationMeta _capacityMeta = const VerificationMeta(
    'capacity',
  );
  @override
  late final GeneratedColumn<int> capacity = GeneratedColumn<int>(
    'capacity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(4),
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('AVAILABLE'),
  );
  static const VerificationMeta _currentOrderIdMeta = const VerificationMeta(
    'currentOrderId',
  );
  @override
  late final GeneratedColumn<String> currentOrderId = GeneratedColumn<String>(
    'current_order_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastOccupiedAtMeta = const VerificationMeta(
    'lastOccupiedAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastOccupiedAt =
      GeneratedColumn<DateTime>(
        'last_occupied_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    tableId,
    tableNo,
    tableDisplayName,
    zoneId,
    capacity,
    status,
    currentOrderId,
    lastOccupiedAt,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'dining_tables';
  @override
  VerificationContext validateIntegrity(
    Insertable<DiningTable> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('table_id')) {
      context.handle(
        _tableIdMeta,
        tableId.isAcceptableOrUnknown(data['table_id']!, _tableIdMeta),
      );
    } else if (isInserting) {
      context.missing(_tableIdMeta);
    }
    if (data.containsKey('table_no')) {
      context.handle(
        _tableNoMeta,
        tableNo.isAcceptableOrUnknown(data['table_no']!, _tableNoMeta),
      );
    } else if (isInserting) {
      context.missing(_tableNoMeta);
    }
    if (data.containsKey('table_display_name')) {
      context.handle(
        _tableDisplayNameMeta,
        tableDisplayName.isAcceptableOrUnknown(
          data['table_display_name']!,
          _tableDisplayNameMeta,
        ),
      );
    }
    if (data.containsKey('zone_id')) {
      context.handle(
        _zoneIdMeta,
        zoneId.isAcceptableOrUnknown(data['zone_id']!, _zoneIdMeta),
      );
    } else if (isInserting) {
      context.missing(_zoneIdMeta);
    }
    if (data.containsKey('capacity')) {
      context.handle(
        _capacityMeta,
        capacity.isAcceptableOrUnknown(data['capacity']!, _capacityMeta),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('current_order_id')) {
      context.handle(
        _currentOrderIdMeta,
        currentOrderId.isAcceptableOrUnknown(
          data['current_order_id']!,
          _currentOrderIdMeta,
        ),
      );
    }
    if (data.containsKey('last_occupied_at')) {
      context.handle(
        _lastOccupiedAtMeta,
        lastOccupiedAt.isAcceptableOrUnknown(
          data['last_occupied_at']!,
          _lastOccupiedAtMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {tableId};
  @override
  DiningTable map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DiningTable(
      tableId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}table_id'],
      )!,
      tableNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}table_no'],
      )!,
      tableDisplayName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}table_display_name'],
      ),
      zoneId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}zone_id'],
      )!,
      capacity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}capacity'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      currentOrderId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}current_order_id'],
      ),
      lastOccupiedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_occupied_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $DiningTablesTable createAlias(String alias) {
    return $DiningTablesTable(attachedDatabase, alias);
  }
}

class DiningTable extends DataClass implements Insertable<DiningTable> {
  final String tableId;
  final String tableNo;
  final String? tableDisplayName;
  final String zoneId;
  final int capacity;
  final String status;
  final String? currentOrderId;
  final DateTime? lastOccupiedAt;
  final DateTime createdAt;
  const DiningTable({
    required this.tableId,
    required this.tableNo,
    this.tableDisplayName,
    required this.zoneId,
    required this.capacity,
    required this.status,
    this.currentOrderId,
    this.lastOccupiedAt,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['table_id'] = Variable<String>(tableId);
    map['table_no'] = Variable<String>(tableNo);
    if (!nullToAbsent || tableDisplayName != null) {
      map['table_display_name'] = Variable<String>(tableDisplayName);
    }
    map['zone_id'] = Variable<String>(zoneId);
    map['capacity'] = Variable<int>(capacity);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || currentOrderId != null) {
      map['current_order_id'] = Variable<String>(currentOrderId);
    }
    if (!nullToAbsent || lastOccupiedAt != null) {
      map['last_occupied_at'] = Variable<DateTime>(lastOccupiedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  DiningTablesCompanion toCompanion(bool nullToAbsent) {
    return DiningTablesCompanion(
      tableId: Value(tableId),
      tableNo: Value(tableNo),
      tableDisplayName: tableDisplayName == null && nullToAbsent
          ? const Value.absent()
          : Value(tableDisplayName),
      zoneId: Value(zoneId),
      capacity: Value(capacity),
      status: Value(status),
      currentOrderId: currentOrderId == null && nullToAbsent
          ? const Value.absent()
          : Value(currentOrderId),
      lastOccupiedAt: lastOccupiedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastOccupiedAt),
      createdAt: Value(createdAt),
    );
  }

  factory DiningTable.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DiningTable(
      tableId: serializer.fromJson<String>(json['tableId']),
      tableNo: serializer.fromJson<String>(json['tableNo']),
      tableDisplayName: serializer.fromJson<String?>(json['tableDisplayName']),
      zoneId: serializer.fromJson<String>(json['zoneId']),
      capacity: serializer.fromJson<int>(json['capacity']),
      status: serializer.fromJson<String>(json['status']),
      currentOrderId: serializer.fromJson<String?>(json['currentOrderId']),
      lastOccupiedAt: serializer.fromJson<DateTime?>(json['lastOccupiedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tableId': serializer.toJson<String>(tableId),
      'tableNo': serializer.toJson<String>(tableNo),
      'tableDisplayName': serializer.toJson<String?>(tableDisplayName),
      'zoneId': serializer.toJson<String>(zoneId),
      'capacity': serializer.toJson<int>(capacity),
      'status': serializer.toJson<String>(status),
      'currentOrderId': serializer.toJson<String?>(currentOrderId),
      'lastOccupiedAt': serializer.toJson<DateTime?>(lastOccupiedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  DiningTable copyWith({
    String? tableId,
    String? tableNo,
    Value<String?> tableDisplayName = const Value.absent(),
    String? zoneId,
    int? capacity,
    String? status,
    Value<String?> currentOrderId = const Value.absent(),
    Value<DateTime?> lastOccupiedAt = const Value.absent(),
    DateTime? createdAt,
  }) => DiningTable(
    tableId: tableId ?? this.tableId,
    tableNo: tableNo ?? this.tableNo,
    tableDisplayName: tableDisplayName.present
        ? tableDisplayName.value
        : this.tableDisplayName,
    zoneId: zoneId ?? this.zoneId,
    capacity: capacity ?? this.capacity,
    status: status ?? this.status,
    currentOrderId: currentOrderId.present
        ? currentOrderId.value
        : this.currentOrderId,
    lastOccupiedAt: lastOccupiedAt.present
        ? lastOccupiedAt.value
        : this.lastOccupiedAt,
    createdAt: createdAt ?? this.createdAt,
  );
  DiningTable copyWithCompanion(DiningTablesCompanion data) {
    return DiningTable(
      tableId: data.tableId.present ? data.tableId.value : this.tableId,
      tableNo: data.tableNo.present ? data.tableNo.value : this.tableNo,
      tableDisplayName: data.tableDisplayName.present
          ? data.tableDisplayName.value
          : this.tableDisplayName,
      zoneId: data.zoneId.present ? data.zoneId.value : this.zoneId,
      capacity: data.capacity.present ? data.capacity.value : this.capacity,
      status: data.status.present ? data.status.value : this.status,
      currentOrderId: data.currentOrderId.present
          ? data.currentOrderId.value
          : this.currentOrderId,
      lastOccupiedAt: data.lastOccupiedAt.present
          ? data.lastOccupiedAt.value
          : this.lastOccupiedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DiningTable(')
          ..write('tableId: $tableId, ')
          ..write('tableNo: $tableNo, ')
          ..write('tableDisplayName: $tableDisplayName, ')
          ..write('zoneId: $zoneId, ')
          ..write('capacity: $capacity, ')
          ..write('status: $status, ')
          ..write('currentOrderId: $currentOrderId, ')
          ..write('lastOccupiedAt: $lastOccupiedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    tableId,
    tableNo,
    tableDisplayName,
    zoneId,
    capacity,
    status,
    currentOrderId,
    lastOccupiedAt,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DiningTable &&
          other.tableId == this.tableId &&
          other.tableNo == this.tableNo &&
          other.tableDisplayName == this.tableDisplayName &&
          other.zoneId == this.zoneId &&
          other.capacity == this.capacity &&
          other.status == this.status &&
          other.currentOrderId == this.currentOrderId &&
          other.lastOccupiedAt == this.lastOccupiedAt &&
          other.createdAt == this.createdAt);
}

class DiningTablesCompanion extends UpdateCompanion<DiningTable> {
  final Value<String> tableId;
  final Value<String> tableNo;
  final Value<String?> tableDisplayName;
  final Value<String> zoneId;
  final Value<int> capacity;
  final Value<String> status;
  final Value<String?> currentOrderId;
  final Value<DateTime?> lastOccupiedAt;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const DiningTablesCompanion({
    this.tableId = const Value.absent(),
    this.tableNo = const Value.absent(),
    this.tableDisplayName = const Value.absent(),
    this.zoneId = const Value.absent(),
    this.capacity = const Value.absent(),
    this.status = const Value.absent(),
    this.currentOrderId = const Value.absent(),
    this.lastOccupiedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DiningTablesCompanion.insert({
    required String tableId,
    required String tableNo,
    this.tableDisplayName = const Value.absent(),
    required String zoneId,
    this.capacity = const Value.absent(),
    this.status = const Value.absent(),
    this.currentOrderId = const Value.absent(),
    this.lastOccupiedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : tableId = Value(tableId),
       tableNo = Value(tableNo),
       zoneId = Value(zoneId);
  static Insertable<DiningTable> custom({
    Expression<String>? tableId,
    Expression<String>? tableNo,
    Expression<String>? tableDisplayName,
    Expression<String>? zoneId,
    Expression<int>? capacity,
    Expression<String>? status,
    Expression<String>? currentOrderId,
    Expression<DateTime>? lastOccupiedAt,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (tableId != null) 'table_id': tableId,
      if (tableNo != null) 'table_no': tableNo,
      if (tableDisplayName != null) 'table_display_name': tableDisplayName,
      if (zoneId != null) 'zone_id': zoneId,
      if (capacity != null) 'capacity': capacity,
      if (status != null) 'status': status,
      if (currentOrderId != null) 'current_order_id': currentOrderId,
      if (lastOccupiedAt != null) 'last_occupied_at': lastOccupiedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DiningTablesCompanion copyWith({
    Value<String>? tableId,
    Value<String>? tableNo,
    Value<String?>? tableDisplayName,
    Value<String>? zoneId,
    Value<int>? capacity,
    Value<String>? status,
    Value<String?>? currentOrderId,
    Value<DateTime?>? lastOccupiedAt,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return DiningTablesCompanion(
      tableId: tableId ?? this.tableId,
      tableNo: tableNo ?? this.tableNo,
      tableDisplayName: tableDisplayName ?? this.tableDisplayName,
      zoneId: zoneId ?? this.zoneId,
      capacity: capacity ?? this.capacity,
      status: status ?? this.status,
      currentOrderId: currentOrderId ?? this.currentOrderId,
      lastOccupiedAt: lastOccupiedAt ?? this.lastOccupiedAt,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tableId.present) {
      map['table_id'] = Variable<String>(tableId.value);
    }
    if (tableNo.present) {
      map['table_no'] = Variable<String>(tableNo.value);
    }
    if (tableDisplayName.present) {
      map['table_display_name'] = Variable<String>(tableDisplayName.value);
    }
    if (zoneId.present) {
      map['zone_id'] = Variable<String>(zoneId.value);
    }
    if (capacity.present) {
      map['capacity'] = Variable<int>(capacity.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (currentOrderId.present) {
      map['current_order_id'] = Variable<String>(currentOrderId.value);
    }
    if (lastOccupiedAt.present) {
      map['last_occupied_at'] = Variable<DateTime>(lastOccupiedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DiningTablesCompanion(')
          ..write('tableId: $tableId, ')
          ..write('tableNo: $tableNo, ')
          ..write('tableDisplayName: $tableDisplayName, ')
          ..write('zoneId: $zoneId, ')
          ..write('capacity: $capacity, ')
          ..write('status: $status, ')
          ..write('currentOrderId: $currentOrderId, ')
          ..write('lastOccupiedAt: $lastOccupiedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CustomerGroupsTable extends CustomerGroups
    with TableInfo<$CustomerGroupsTable, CustomerGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CustomerGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _customerGroupIdMeta = const VerificationMeta(
    'customerGroupId',
  );
  @override
  late final GeneratedColumn<String> customerGroupId = GeneratedColumn<String>(
    'customer_group_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _groupNameMeta = const VerificationMeta(
    'groupName',
  );
  @override
  late final GeneratedColumn<String> groupName = GeneratedColumn<String>(
    'group_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _discountRateMeta = const VerificationMeta(
    'discountRate',
  );
  @override
  late final GeneratedColumn<double> discountRate = GeneratedColumn<double>(
    'discount_rate',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _priceLevelMeta = const VerificationMeta(
    'priceLevel',
  );
  @override
  late final GeneratedColumn<int> priceLevel = GeneratedColumn<int>(
    'price_level',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    customerGroupId,
    groupName,
    discountRate,
    priceLevel,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'customer_groups';
  @override
  VerificationContext validateIntegrity(
    Insertable<CustomerGroup> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('customer_group_id')) {
      context.handle(
        _customerGroupIdMeta,
        customerGroupId.isAcceptableOrUnknown(
          data['customer_group_id']!,
          _customerGroupIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_customerGroupIdMeta);
    }
    if (data.containsKey('group_name')) {
      context.handle(
        _groupNameMeta,
        groupName.isAcceptableOrUnknown(data['group_name']!, _groupNameMeta),
      );
    } else if (isInserting) {
      context.missing(_groupNameMeta);
    }
    if (data.containsKey('discount_rate')) {
      context.handle(
        _discountRateMeta,
        discountRate.isAcceptableOrUnknown(
          data['discount_rate']!,
          _discountRateMeta,
        ),
      );
    }
    if (data.containsKey('price_level')) {
      context.handle(
        _priceLevelMeta,
        priceLevel.isAcceptableOrUnknown(data['price_level']!, _priceLevelMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {customerGroupId};
  @override
  CustomerGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CustomerGroup(
      customerGroupId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_group_id'],
      )!,
      groupName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}group_name'],
      )!,
      discountRate: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}discount_rate'],
      )!,
      priceLevel: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}price_level'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $CustomerGroupsTable createAlias(String alias) {
    return $CustomerGroupsTable(attachedDatabase, alias);
  }
}

class CustomerGroup extends DataClass implements Insertable<CustomerGroup> {
  final String customerGroupId;
  final String groupName;
  final double discountRate;
  final int priceLevel;
  final DateTime createdAt;
  const CustomerGroup({
    required this.customerGroupId,
    required this.groupName,
    required this.discountRate,
    required this.priceLevel,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['customer_group_id'] = Variable<String>(customerGroupId);
    map['group_name'] = Variable<String>(groupName);
    map['discount_rate'] = Variable<double>(discountRate);
    map['price_level'] = Variable<int>(priceLevel);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  CustomerGroupsCompanion toCompanion(bool nullToAbsent) {
    return CustomerGroupsCompanion(
      customerGroupId: Value(customerGroupId),
      groupName: Value(groupName),
      discountRate: Value(discountRate),
      priceLevel: Value(priceLevel),
      createdAt: Value(createdAt),
    );
  }

  factory CustomerGroup.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CustomerGroup(
      customerGroupId: serializer.fromJson<String>(json['customerGroupId']),
      groupName: serializer.fromJson<String>(json['groupName']),
      discountRate: serializer.fromJson<double>(json['discountRate']),
      priceLevel: serializer.fromJson<int>(json['priceLevel']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'customerGroupId': serializer.toJson<String>(customerGroupId),
      'groupName': serializer.toJson<String>(groupName),
      'discountRate': serializer.toJson<double>(discountRate),
      'priceLevel': serializer.toJson<int>(priceLevel),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  CustomerGroup copyWith({
    String? customerGroupId,
    String? groupName,
    double? discountRate,
    int? priceLevel,
    DateTime? createdAt,
  }) => CustomerGroup(
    customerGroupId: customerGroupId ?? this.customerGroupId,
    groupName: groupName ?? this.groupName,
    discountRate: discountRate ?? this.discountRate,
    priceLevel: priceLevel ?? this.priceLevel,
    createdAt: createdAt ?? this.createdAt,
  );
  CustomerGroup copyWithCompanion(CustomerGroupsCompanion data) {
    return CustomerGroup(
      customerGroupId: data.customerGroupId.present
          ? data.customerGroupId.value
          : this.customerGroupId,
      groupName: data.groupName.present ? data.groupName.value : this.groupName,
      discountRate: data.discountRate.present
          ? data.discountRate.value
          : this.discountRate,
      priceLevel: data.priceLevel.present
          ? data.priceLevel.value
          : this.priceLevel,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CustomerGroup(')
          ..write('customerGroupId: $customerGroupId, ')
          ..write('groupName: $groupName, ')
          ..write('discountRate: $discountRate, ')
          ..write('priceLevel: $priceLevel, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    customerGroupId,
    groupName,
    discountRate,
    priceLevel,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CustomerGroup &&
          other.customerGroupId == this.customerGroupId &&
          other.groupName == this.groupName &&
          other.discountRate == this.discountRate &&
          other.priceLevel == this.priceLevel &&
          other.createdAt == this.createdAt);
}

class CustomerGroupsCompanion extends UpdateCompanion<CustomerGroup> {
  final Value<String> customerGroupId;
  final Value<String> groupName;
  final Value<double> discountRate;
  final Value<int> priceLevel;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const CustomerGroupsCompanion({
    this.customerGroupId = const Value.absent(),
    this.groupName = const Value.absent(),
    this.discountRate = const Value.absent(),
    this.priceLevel = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CustomerGroupsCompanion.insert({
    required String customerGroupId,
    required String groupName,
    this.discountRate = const Value.absent(),
    this.priceLevel = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : customerGroupId = Value(customerGroupId),
       groupName = Value(groupName);
  static Insertable<CustomerGroup> custom({
    Expression<String>? customerGroupId,
    Expression<String>? groupName,
    Expression<double>? discountRate,
    Expression<int>? priceLevel,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (customerGroupId != null) 'customer_group_id': customerGroupId,
      if (groupName != null) 'group_name': groupName,
      if (discountRate != null) 'discount_rate': discountRate,
      if (priceLevel != null) 'price_level': priceLevel,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CustomerGroupsCompanion copyWith({
    Value<String>? customerGroupId,
    Value<String>? groupName,
    Value<double>? discountRate,
    Value<int>? priceLevel,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return CustomerGroupsCompanion(
      customerGroupId: customerGroupId ?? this.customerGroupId,
      groupName: groupName ?? this.groupName,
      discountRate: discountRate ?? this.discountRate,
      priceLevel: priceLevel ?? this.priceLevel,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (customerGroupId.present) {
      map['customer_group_id'] = Variable<String>(customerGroupId.value);
    }
    if (groupName.present) {
      map['group_name'] = Variable<String>(groupName.value);
    }
    if (discountRate.present) {
      map['discount_rate'] = Variable<double>(discountRate.value);
    }
    if (priceLevel.present) {
      map['price_level'] = Variable<int>(priceLevel.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CustomerGroupsCompanion(')
          ..write('customerGroupId: $customerGroupId, ')
          ..write('groupName: $groupName, ')
          ..write('discountRate: $discountRate, ')
          ..write('priceLevel: $priceLevel, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CustomersTable extends Customers
    with TableInfo<$CustomersTable, Customer> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CustomersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _customerIdMeta = const VerificationMeta(
    'customerId',
  );
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
    'customer_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _customerCodeMeta = const VerificationMeta(
    'customerCode',
  );
  @override
  late final GeneratedColumn<String> customerCode = GeneratedColumn<String>(
    'customer_code',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _customerNameMeta = const VerificationMeta(
    'customerName',
  );
  @override
  late final GeneratedColumn<String> customerName = GeneratedColumn<String>(
    'customer_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 300),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _customerGroupIdMeta = const VerificationMeta(
    'customerGroupId',
  );
  @override
  late final GeneratedColumn<String> customerGroupId = GeneratedColumn<String>(
    'customer_group_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES customer_groups (customer_group_id)',
    ),
  );
  static const VerificationMeta _addressMeta = const VerificationMeta(
    'address',
  );
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
    'email',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _taxIdMeta = const VerificationMeta('taxId');
  @override
  late final GeneratedColumn<String> taxId = GeneratedColumn<String>(
    'tax_id',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _creditLimitMeta = const VerificationMeta(
    'creditLimit',
  );
  @override
  late final GeneratedColumn<double> creditLimit = GeneratedColumn<double>(
    'credit_limit',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _creditDaysMeta = const VerificationMeta(
    'creditDays',
  );
  @override
  late final GeneratedColumn<int> creditDays = GeneratedColumn<int>(
    'credit_days',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _currentBalanceMeta = const VerificationMeta(
    'currentBalance',
  );
  @override
  late final GeneratedColumn<double> currentBalance = GeneratedColumn<double>(
    'current_balance',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _memberNoMeta = const VerificationMeta(
    'memberNo',
  );
  @override
  late final GeneratedColumn<String> memberNo = GeneratedColumn<String>(
    'member_no',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _pointsMeta = const VerificationMeta('points');
  @override
  late final GeneratedColumn<int> points = GeneratedColumn<int>(
    'points',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    customerId,
    customerCode,
    customerName,
    customerGroupId,
    address,
    phone,
    email,
    taxId,
    creditLimit,
    creditDays,
    currentBalance,
    memberNo,
    points,
    isActive,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'customers';
  @override
  VerificationContext validateIntegrity(
    Insertable<Customer> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('customer_id')) {
      context.handle(
        _customerIdMeta,
        customerId.isAcceptableOrUnknown(data['customer_id']!, _customerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('customer_code')) {
      context.handle(
        _customerCodeMeta,
        customerCode.isAcceptableOrUnknown(
          data['customer_code']!,
          _customerCodeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_customerCodeMeta);
    }
    if (data.containsKey('customer_name')) {
      context.handle(
        _customerNameMeta,
        customerName.isAcceptableOrUnknown(
          data['customer_name']!,
          _customerNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_customerNameMeta);
    }
    if (data.containsKey('customer_group_id')) {
      context.handle(
        _customerGroupIdMeta,
        customerGroupId.isAcceptableOrUnknown(
          data['customer_group_id']!,
          _customerGroupIdMeta,
        ),
      );
    }
    if (data.containsKey('address')) {
      context.handle(
        _addressMeta,
        address.isAcceptableOrUnknown(data['address']!, _addressMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('email')) {
      context.handle(
        _emailMeta,
        email.isAcceptableOrUnknown(data['email']!, _emailMeta),
      );
    }
    if (data.containsKey('tax_id')) {
      context.handle(
        _taxIdMeta,
        taxId.isAcceptableOrUnknown(data['tax_id']!, _taxIdMeta),
      );
    }
    if (data.containsKey('credit_limit')) {
      context.handle(
        _creditLimitMeta,
        creditLimit.isAcceptableOrUnknown(
          data['credit_limit']!,
          _creditLimitMeta,
        ),
      );
    }
    if (data.containsKey('credit_days')) {
      context.handle(
        _creditDaysMeta,
        creditDays.isAcceptableOrUnknown(data['credit_days']!, _creditDaysMeta),
      );
    }
    if (data.containsKey('current_balance')) {
      context.handle(
        _currentBalanceMeta,
        currentBalance.isAcceptableOrUnknown(
          data['current_balance']!,
          _currentBalanceMeta,
        ),
      );
    }
    if (data.containsKey('member_no')) {
      context.handle(
        _memberNoMeta,
        memberNo.isAcceptableOrUnknown(data['member_no']!, _memberNoMeta),
      );
    }
    if (data.containsKey('points')) {
      context.handle(
        _pointsMeta,
        points.isAcceptableOrUnknown(data['points']!, _pointsMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {customerId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {customerCode},
  ];
  @override
  Customer map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Customer(
      customerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_id'],
      )!,
      customerCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_code'],
      )!,
      customerName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_name'],
      )!,
      customerGroupId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_group_id'],
      ),
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      email: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}email'],
      ),
      taxId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tax_id'],
      ),
      creditLimit: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}credit_limit'],
      )!,
      creditDays: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}credit_days'],
      )!,
      currentBalance: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}current_balance'],
      )!,
      memberNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}member_no'],
      ),
      points: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}points'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $CustomersTable createAlias(String alias) {
    return $CustomersTable(attachedDatabase, alias);
  }
}

class Customer extends DataClass implements Insertable<Customer> {
  final String customerId;
  final String customerCode;
  final String customerName;
  final String? customerGroupId;
  final String? address;
  final String? phone;
  final String? email;
  final String? taxId;
  final double creditLimit;
  final int creditDays;
  final double currentBalance;
  final String? memberNo;
  final int points;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Customer({
    required this.customerId,
    required this.customerCode,
    required this.customerName,
    this.customerGroupId,
    this.address,
    this.phone,
    this.email,
    this.taxId,
    required this.creditLimit,
    required this.creditDays,
    required this.currentBalance,
    this.memberNo,
    required this.points,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['customer_id'] = Variable<String>(customerId);
    map['customer_code'] = Variable<String>(customerCode);
    map['customer_name'] = Variable<String>(customerName);
    if (!nullToAbsent || customerGroupId != null) {
      map['customer_group_id'] = Variable<String>(customerGroupId);
    }
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || taxId != null) {
      map['tax_id'] = Variable<String>(taxId);
    }
    map['credit_limit'] = Variable<double>(creditLimit);
    map['credit_days'] = Variable<int>(creditDays);
    map['current_balance'] = Variable<double>(currentBalance);
    if (!nullToAbsent || memberNo != null) {
      map['member_no'] = Variable<String>(memberNo);
    }
    map['points'] = Variable<int>(points);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  CustomersCompanion toCompanion(bool nullToAbsent) {
    return CustomersCompanion(
      customerId: Value(customerId),
      customerCode: Value(customerCode),
      customerName: Value(customerName),
      customerGroupId: customerGroupId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerGroupId),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      email: email == null && nullToAbsent
          ? const Value.absent()
          : Value(email),
      taxId: taxId == null && nullToAbsent
          ? const Value.absent()
          : Value(taxId),
      creditLimit: Value(creditLimit),
      creditDays: Value(creditDays),
      currentBalance: Value(currentBalance),
      memberNo: memberNo == null && nullToAbsent
          ? const Value.absent()
          : Value(memberNo),
      points: Value(points),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Customer.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Customer(
      customerId: serializer.fromJson<String>(json['customerId']),
      customerCode: serializer.fromJson<String>(json['customerCode']),
      customerName: serializer.fromJson<String>(json['customerName']),
      customerGroupId: serializer.fromJson<String?>(json['customerGroupId']),
      address: serializer.fromJson<String?>(json['address']),
      phone: serializer.fromJson<String?>(json['phone']),
      email: serializer.fromJson<String?>(json['email']),
      taxId: serializer.fromJson<String?>(json['taxId']),
      creditLimit: serializer.fromJson<double>(json['creditLimit']),
      creditDays: serializer.fromJson<int>(json['creditDays']),
      currentBalance: serializer.fromJson<double>(json['currentBalance']),
      memberNo: serializer.fromJson<String?>(json['memberNo']),
      points: serializer.fromJson<int>(json['points']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'customerId': serializer.toJson<String>(customerId),
      'customerCode': serializer.toJson<String>(customerCode),
      'customerName': serializer.toJson<String>(customerName),
      'customerGroupId': serializer.toJson<String?>(customerGroupId),
      'address': serializer.toJson<String?>(address),
      'phone': serializer.toJson<String?>(phone),
      'email': serializer.toJson<String?>(email),
      'taxId': serializer.toJson<String?>(taxId),
      'creditLimit': serializer.toJson<double>(creditLimit),
      'creditDays': serializer.toJson<int>(creditDays),
      'currentBalance': serializer.toJson<double>(currentBalance),
      'memberNo': serializer.toJson<String?>(memberNo),
      'points': serializer.toJson<int>(points),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Customer copyWith({
    String? customerId,
    String? customerCode,
    String? customerName,
    Value<String?> customerGroupId = const Value.absent(),
    Value<String?> address = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    Value<String?> email = const Value.absent(),
    Value<String?> taxId = const Value.absent(),
    double? creditLimit,
    int? creditDays,
    double? currentBalance,
    Value<String?> memberNo = const Value.absent(),
    int? points,
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Customer(
    customerId: customerId ?? this.customerId,
    customerCode: customerCode ?? this.customerCode,
    customerName: customerName ?? this.customerName,
    customerGroupId: customerGroupId.present
        ? customerGroupId.value
        : this.customerGroupId,
    address: address.present ? address.value : this.address,
    phone: phone.present ? phone.value : this.phone,
    email: email.present ? email.value : this.email,
    taxId: taxId.present ? taxId.value : this.taxId,
    creditLimit: creditLimit ?? this.creditLimit,
    creditDays: creditDays ?? this.creditDays,
    currentBalance: currentBalance ?? this.currentBalance,
    memberNo: memberNo.present ? memberNo.value : this.memberNo,
    points: points ?? this.points,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Customer copyWithCompanion(CustomersCompanion data) {
    return Customer(
      customerId: data.customerId.present
          ? data.customerId.value
          : this.customerId,
      customerCode: data.customerCode.present
          ? data.customerCode.value
          : this.customerCode,
      customerName: data.customerName.present
          ? data.customerName.value
          : this.customerName,
      customerGroupId: data.customerGroupId.present
          ? data.customerGroupId.value
          : this.customerGroupId,
      address: data.address.present ? data.address.value : this.address,
      phone: data.phone.present ? data.phone.value : this.phone,
      email: data.email.present ? data.email.value : this.email,
      taxId: data.taxId.present ? data.taxId.value : this.taxId,
      creditLimit: data.creditLimit.present
          ? data.creditLimit.value
          : this.creditLimit,
      creditDays: data.creditDays.present
          ? data.creditDays.value
          : this.creditDays,
      currentBalance: data.currentBalance.present
          ? data.currentBalance.value
          : this.currentBalance,
      memberNo: data.memberNo.present ? data.memberNo.value : this.memberNo,
      points: data.points.present ? data.points.value : this.points,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Customer(')
          ..write('customerId: $customerId, ')
          ..write('customerCode: $customerCode, ')
          ..write('customerName: $customerName, ')
          ..write('customerGroupId: $customerGroupId, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('taxId: $taxId, ')
          ..write('creditLimit: $creditLimit, ')
          ..write('creditDays: $creditDays, ')
          ..write('currentBalance: $currentBalance, ')
          ..write('memberNo: $memberNo, ')
          ..write('points: $points, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    customerId,
    customerCode,
    customerName,
    customerGroupId,
    address,
    phone,
    email,
    taxId,
    creditLimit,
    creditDays,
    currentBalance,
    memberNo,
    points,
    isActive,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Customer &&
          other.customerId == this.customerId &&
          other.customerCode == this.customerCode &&
          other.customerName == this.customerName &&
          other.customerGroupId == this.customerGroupId &&
          other.address == this.address &&
          other.phone == this.phone &&
          other.email == this.email &&
          other.taxId == this.taxId &&
          other.creditLimit == this.creditLimit &&
          other.creditDays == this.creditDays &&
          other.currentBalance == this.currentBalance &&
          other.memberNo == this.memberNo &&
          other.points == this.points &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class CustomersCompanion extends UpdateCompanion<Customer> {
  final Value<String> customerId;
  final Value<String> customerCode;
  final Value<String> customerName;
  final Value<String?> customerGroupId;
  final Value<String?> address;
  final Value<String?> phone;
  final Value<String?> email;
  final Value<String?> taxId;
  final Value<double> creditLimit;
  final Value<int> creditDays;
  final Value<double> currentBalance;
  final Value<String?> memberNo;
  final Value<int> points;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const CustomersCompanion({
    this.customerId = const Value.absent(),
    this.customerCode = const Value.absent(),
    this.customerName = const Value.absent(),
    this.customerGroupId = const Value.absent(),
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.taxId = const Value.absent(),
    this.creditLimit = const Value.absent(),
    this.creditDays = const Value.absent(),
    this.currentBalance = const Value.absent(),
    this.memberNo = const Value.absent(),
    this.points = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CustomersCompanion.insert({
    required String customerId,
    required String customerCode,
    required String customerName,
    this.customerGroupId = const Value.absent(),
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.taxId = const Value.absent(),
    this.creditLimit = const Value.absent(),
    this.creditDays = const Value.absent(),
    this.currentBalance = const Value.absent(),
    this.memberNo = const Value.absent(),
    this.points = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : customerId = Value(customerId),
       customerCode = Value(customerCode),
       customerName = Value(customerName);
  static Insertable<Customer> custom({
    Expression<String>? customerId,
    Expression<String>? customerCode,
    Expression<String>? customerName,
    Expression<String>? customerGroupId,
    Expression<String>? address,
    Expression<String>? phone,
    Expression<String>? email,
    Expression<String>? taxId,
    Expression<double>? creditLimit,
    Expression<int>? creditDays,
    Expression<double>? currentBalance,
    Expression<String>? memberNo,
    Expression<int>? points,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (customerId != null) 'customer_id': customerId,
      if (customerCode != null) 'customer_code': customerCode,
      if (customerName != null) 'customer_name': customerName,
      if (customerGroupId != null) 'customer_group_id': customerGroupId,
      if (address != null) 'address': address,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (taxId != null) 'tax_id': taxId,
      if (creditLimit != null) 'credit_limit': creditLimit,
      if (creditDays != null) 'credit_days': creditDays,
      if (currentBalance != null) 'current_balance': currentBalance,
      if (memberNo != null) 'member_no': memberNo,
      if (points != null) 'points': points,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CustomersCompanion copyWith({
    Value<String>? customerId,
    Value<String>? customerCode,
    Value<String>? customerName,
    Value<String?>? customerGroupId,
    Value<String?>? address,
    Value<String?>? phone,
    Value<String?>? email,
    Value<String?>? taxId,
    Value<double>? creditLimit,
    Value<int>? creditDays,
    Value<double>? currentBalance,
    Value<String?>? memberNo,
    Value<int>? points,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return CustomersCompanion(
      customerId: customerId ?? this.customerId,
      customerCode: customerCode ?? this.customerCode,
      customerName: customerName ?? this.customerName,
      customerGroupId: customerGroupId ?? this.customerGroupId,
      address: address ?? this.address,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      taxId: taxId ?? this.taxId,
      creditLimit: creditLimit ?? this.creditLimit,
      creditDays: creditDays ?? this.creditDays,
      currentBalance: currentBalance ?? this.currentBalance,
      memberNo: memberNo ?? this.memberNo,
      points: points ?? this.points,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (customerCode.present) {
      map['customer_code'] = Variable<String>(customerCode.value);
    }
    if (customerName.present) {
      map['customer_name'] = Variable<String>(customerName.value);
    }
    if (customerGroupId.present) {
      map['customer_group_id'] = Variable<String>(customerGroupId.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (taxId.present) {
      map['tax_id'] = Variable<String>(taxId.value);
    }
    if (creditLimit.present) {
      map['credit_limit'] = Variable<double>(creditLimit.value);
    }
    if (creditDays.present) {
      map['credit_days'] = Variable<int>(creditDays.value);
    }
    if (currentBalance.present) {
      map['current_balance'] = Variable<double>(currentBalance.value);
    }
    if (memberNo.present) {
      map['member_no'] = Variable<String>(memberNo.value);
    }
    if (points.present) {
      map['points'] = Variable<int>(points.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CustomersCompanion(')
          ..write('customerId: $customerId, ')
          ..write('customerCode: $customerCode, ')
          ..write('customerName: $customerName, ')
          ..write('customerGroupId: $customerGroupId, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('taxId: $taxId, ')
          ..write('creditLimit: $creditLimit, ')
          ..write('creditDays: $creditDays, ')
          ..write('currentBalance: $currentBalance, ')
          ..write('memberNo: $memberNo, ')
          ..write('points: $points, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SuppliersTable extends Suppliers
    with TableInfo<$SuppliersTable, Supplier> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SuppliersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _supplierIdMeta = const VerificationMeta(
    'supplierId',
  );
  @override
  late final GeneratedColumn<String> supplierId = GeneratedColumn<String>(
    'supplier_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _supplierCodeMeta = const VerificationMeta(
    'supplierCode',
  );
  @override
  late final GeneratedColumn<String> supplierCode = GeneratedColumn<String>(
    'supplier_code',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _supplierNameMeta = const VerificationMeta(
    'supplierName',
  );
  @override
  late final GeneratedColumn<String> supplierName = GeneratedColumn<String>(
    'supplier_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 300),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _addressMeta = const VerificationMeta(
    'address',
  );
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
    'email',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _taxIdMeta = const VerificationMeta('taxId');
  @override
  late final GeneratedColumn<String> taxId = GeneratedColumn<String>(
    'tax_id',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _creditDaysMeta = const VerificationMeta(
    'creditDays',
  );
  @override
  late final GeneratedColumn<int> creditDays = GeneratedColumn<int>(
    'credit_days',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    supplierId,
    supplierCode,
    supplierName,
    address,
    phone,
    email,
    taxId,
    creditDays,
    isActive,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'suppliers';
  @override
  VerificationContext validateIntegrity(
    Insertable<Supplier> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('supplier_id')) {
      context.handle(
        _supplierIdMeta,
        supplierId.isAcceptableOrUnknown(data['supplier_id']!, _supplierIdMeta),
      );
    } else if (isInserting) {
      context.missing(_supplierIdMeta);
    }
    if (data.containsKey('supplier_code')) {
      context.handle(
        _supplierCodeMeta,
        supplierCode.isAcceptableOrUnknown(
          data['supplier_code']!,
          _supplierCodeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_supplierCodeMeta);
    }
    if (data.containsKey('supplier_name')) {
      context.handle(
        _supplierNameMeta,
        supplierName.isAcceptableOrUnknown(
          data['supplier_name']!,
          _supplierNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_supplierNameMeta);
    }
    if (data.containsKey('address')) {
      context.handle(
        _addressMeta,
        address.isAcceptableOrUnknown(data['address']!, _addressMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('email')) {
      context.handle(
        _emailMeta,
        email.isAcceptableOrUnknown(data['email']!, _emailMeta),
      );
    }
    if (data.containsKey('tax_id')) {
      context.handle(
        _taxIdMeta,
        taxId.isAcceptableOrUnknown(data['tax_id']!, _taxIdMeta),
      );
    }
    if (data.containsKey('credit_days')) {
      context.handle(
        _creditDaysMeta,
        creditDays.isAcceptableOrUnknown(data['credit_days']!, _creditDaysMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {supplierId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {supplierCode},
  ];
  @override
  Supplier map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Supplier(
      supplierId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}supplier_id'],
      )!,
      supplierCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}supplier_code'],
      )!,
      supplierName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}supplier_name'],
      )!,
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      email: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}email'],
      ),
      taxId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tax_id'],
      ),
      creditDays: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}credit_days'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $SuppliersTable createAlias(String alias) {
    return $SuppliersTable(attachedDatabase, alias);
  }
}

class Supplier extends DataClass implements Insertable<Supplier> {
  final String supplierId;
  final String supplierCode;
  final String supplierName;
  final String? address;
  final String? phone;
  final String? email;
  final String? taxId;
  final int creditDays;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Supplier({
    required this.supplierId,
    required this.supplierCode,
    required this.supplierName,
    this.address,
    this.phone,
    this.email,
    this.taxId,
    required this.creditDays,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['supplier_id'] = Variable<String>(supplierId);
    map['supplier_code'] = Variable<String>(supplierCode);
    map['supplier_name'] = Variable<String>(supplierName);
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || taxId != null) {
      map['tax_id'] = Variable<String>(taxId);
    }
    map['credit_days'] = Variable<int>(creditDays);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SuppliersCompanion toCompanion(bool nullToAbsent) {
    return SuppliersCompanion(
      supplierId: Value(supplierId),
      supplierCode: Value(supplierCode),
      supplierName: Value(supplierName),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      email: email == null && nullToAbsent
          ? const Value.absent()
          : Value(email),
      taxId: taxId == null && nullToAbsent
          ? const Value.absent()
          : Value(taxId),
      creditDays: Value(creditDays),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Supplier.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Supplier(
      supplierId: serializer.fromJson<String>(json['supplierId']),
      supplierCode: serializer.fromJson<String>(json['supplierCode']),
      supplierName: serializer.fromJson<String>(json['supplierName']),
      address: serializer.fromJson<String?>(json['address']),
      phone: serializer.fromJson<String?>(json['phone']),
      email: serializer.fromJson<String?>(json['email']),
      taxId: serializer.fromJson<String?>(json['taxId']),
      creditDays: serializer.fromJson<int>(json['creditDays']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'supplierId': serializer.toJson<String>(supplierId),
      'supplierCode': serializer.toJson<String>(supplierCode),
      'supplierName': serializer.toJson<String>(supplierName),
      'address': serializer.toJson<String?>(address),
      'phone': serializer.toJson<String?>(phone),
      'email': serializer.toJson<String?>(email),
      'taxId': serializer.toJson<String?>(taxId),
      'creditDays': serializer.toJson<int>(creditDays),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Supplier copyWith({
    String? supplierId,
    String? supplierCode,
    String? supplierName,
    Value<String?> address = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    Value<String?> email = const Value.absent(),
    Value<String?> taxId = const Value.absent(),
    int? creditDays,
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Supplier(
    supplierId: supplierId ?? this.supplierId,
    supplierCode: supplierCode ?? this.supplierCode,
    supplierName: supplierName ?? this.supplierName,
    address: address.present ? address.value : this.address,
    phone: phone.present ? phone.value : this.phone,
    email: email.present ? email.value : this.email,
    taxId: taxId.present ? taxId.value : this.taxId,
    creditDays: creditDays ?? this.creditDays,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Supplier copyWithCompanion(SuppliersCompanion data) {
    return Supplier(
      supplierId: data.supplierId.present
          ? data.supplierId.value
          : this.supplierId,
      supplierCode: data.supplierCode.present
          ? data.supplierCode.value
          : this.supplierCode,
      supplierName: data.supplierName.present
          ? data.supplierName.value
          : this.supplierName,
      address: data.address.present ? data.address.value : this.address,
      phone: data.phone.present ? data.phone.value : this.phone,
      email: data.email.present ? data.email.value : this.email,
      taxId: data.taxId.present ? data.taxId.value : this.taxId,
      creditDays: data.creditDays.present
          ? data.creditDays.value
          : this.creditDays,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Supplier(')
          ..write('supplierId: $supplierId, ')
          ..write('supplierCode: $supplierCode, ')
          ..write('supplierName: $supplierName, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('taxId: $taxId, ')
          ..write('creditDays: $creditDays, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    supplierId,
    supplierCode,
    supplierName,
    address,
    phone,
    email,
    taxId,
    creditDays,
    isActive,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Supplier &&
          other.supplierId == this.supplierId &&
          other.supplierCode == this.supplierCode &&
          other.supplierName == this.supplierName &&
          other.address == this.address &&
          other.phone == this.phone &&
          other.email == this.email &&
          other.taxId == this.taxId &&
          other.creditDays == this.creditDays &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SuppliersCompanion extends UpdateCompanion<Supplier> {
  final Value<String> supplierId;
  final Value<String> supplierCode;
  final Value<String> supplierName;
  final Value<String?> address;
  final Value<String?> phone;
  final Value<String?> email;
  final Value<String?> taxId;
  final Value<int> creditDays;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const SuppliersCompanion({
    this.supplierId = const Value.absent(),
    this.supplierCode = const Value.absent(),
    this.supplierName = const Value.absent(),
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.taxId = const Value.absent(),
    this.creditDays = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SuppliersCompanion.insert({
    required String supplierId,
    required String supplierCode,
    required String supplierName,
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.taxId = const Value.absent(),
    this.creditDays = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : supplierId = Value(supplierId),
       supplierCode = Value(supplierCode),
       supplierName = Value(supplierName);
  static Insertable<Supplier> custom({
    Expression<String>? supplierId,
    Expression<String>? supplierCode,
    Expression<String>? supplierName,
    Expression<String>? address,
    Expression<String>? phone,
    Expression<String>? email,
    Expression<String>? taxId,
    Expression<int>? creditDays,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (supplierId != null) 'supplier_id': supplierId,
      if (supplierCode != null) 'supplier_code': supplierCode,
      if (supplierName != null) 'supplier_name': supplierName,
      if (address != null) 'address': address,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (taxId != null) 'tax_id': taxId,
      if (creditDays != null) 'credit_days': creditDays,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SuppliersCompanion copyWith({
    Value<String>? supplierId,
    Value<String>? supplierCode,
    Value<String>? supplierName,
    Value<String?>? address,
    Value<String?>? phone,
    Value<String?>? email,
    Value<String?>? taxId,
    Value<int>? creditDays,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return SuppliersCompanion(
      supplierId: supplierId ?? this.supplierId,
      supplierCode: supplierCode ?? this.supplierCode,
      supplierName: supplierName ?? this.supplierName,
      address: address ?? this.address,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      taxId: taxId ?? this.taxId,
      creditDays: creditDays ?? this.creditDays,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (supplierId.present) {
      map['supplier_id'] = Variable<String>(supplierId.value);
    }
    if (supplierCode.present) {
      map['supplier_code'] = Variable<String>(supplierCode.value);
    }
    if (supplierName.present) {
      map['supplier_name'] = Variable<String>(supplierName.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (taxId.present) {
      map['tax_id'] = Variable<String>(taxId.value);
    }
    if (creditDays.present) {
      map['credit_days'] = Variable<int>(creditDays.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SuppliersCompanion(')
          ..write('supplierId: $supplierId, ')
          ..write('supplierCode: $supplierCode, ')
          ..write('supplierName: $supplierName, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('taxId: $taxId, ')
          ..write('creditDays: $creditDays, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SalesOrdersTable extends SalesOrders
    with TableInfo<$SalesOrdersTable, SalesOrder> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SalesOrdersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _orderIdMeta = const VerificationMeta(
    'orderId',
  );
  @override
  late final GeneratedColumn<String> orderId = GeneratedColumn<String>(
    'order_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _orderNoMeta = const VerificationMeta(
    'orderNo',
  );
  @override
  late final GeneratedColumn<String> orderNo = GeneratedColumn<String>(
    'order_no',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _orderDateMeta = const VerificationMeta(
    'orderDate',
  );
  @override
  late final GeneratedColumn<DateTime> orderDate = GeneratedColumn<DateTime>(
    'order_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _orderTypeMeta = const VerificationMeta(
    'orderType',
  );
  @override
  late final GeneratedColumn<String> orderType = GeneratedColumn<String>(
    'order_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('SALE'),
  );
  static const VerificationMeta _customerIdMeta = const VerificationMeta(
    'customerId',
  );
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
    'customer_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES customers (customer_id)',
    ),
  );
  static const VerificationMeta _customerNameMeta = const VerificationMeta(
    'customerName',
  );
  @override
  late final GeneratedColumn<String> customerName = GeneratedColumn<String>(
    'customer_name',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 300),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _customerAddressMeta = const VerificationMeta(
    'customerAddress',
  );
  @override
  late final GeneratedColumn<String> customerAddress = GeneratedColumn<String>(
    'customer_address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _customerTaxIdMeta = const VerificationMeta(
    'customerTaxId',
  );
  @override
  late final GeneratedColumn<String> customerTaxId = GeneratedColumn<String>(
    'customer_tax_id',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES branches (branch_id)',
    ),
  );
  static const VerificationMeta _warehouseIdMeta = const VerificationMeta(
    'warehouseId',
  );
  @override
  late final GeneratedColumn<String> warehouseId = GeneratedColumn<String>(
    'warehouse_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES warehouses (warehouse_id)',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (user_id)',
    ),
  );
  static const VerificationMeta _tableIdMeta = const VerificationMeta(
    'tableId',
  );
  @override
  late final GeneratedColumn<String> tableId = GeneratedColumn<String>(
    'table_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _partySizeMeta = const VerificationMeta(
    'partySize',
  );
  @override
  late final GeneratedColumn<int> partySize = GeneratedColumn<int>(
    'party_size',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _subtotalMeta = const VerificationMeta(
    'subtotal',
  );
  @override
  late final GeneratedColumn<double> subtotal = GeneratedColumn<double>(
    'subtotal',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _discountAmountMeta = const VerificationMeta(
    'discountAmount',
  );
  @override
  late final GeneratedColumn<double> discountAmount = GeneratedColumn<double>(
    'discount_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _amountBeforeVatMeta = const VerificationMeta(
    'amountBeforeVat',
  );
  @override
  late final GeneratedColumn<double> amountBeforeVat = GeneratedColumn<double>(
    'amount_before_vat',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _vatAmountMeta = const VerificationMeta(
    'vatAmount',
  );
  @override
  late final GeneratedColumn<double> vatAmount = GeneratedColumn<double>(
    'vat_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _totalAmountMeta = const VerificationMeta(
    'totalAmount',
  );
  @override
  late final GeneratedColumn<double> totalAmount = GeneratedColumn<double>(
    'total_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _paymentTypeMeta = const VerificationMeta(
    'paymentType',
  );
  @override
  late final GeneratedColumn<String> paymentType = GeneratedColumn<String>(
    'payment_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('CASH'),
  );
  static const VerificationMeta _paidAmountMeta = const VerificationMeta(
    'paidAmount',
  );
  @override
  late final GeneratedColumn<double> paidAmount = GeneratedColumn<double>(
    'paid_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _changeAmountMeta = const VerificationMeta(
    'changeAmount',
  );
  @override
  late final GeneratedColumn<double> changeAmount = GeneratedColumn<double>(
    'change_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('OPEN'),
  );
  static const VerificationMeta _isVatIncludeMeta = const VerificationMeta(
    'isVatInclude',
  );
  @override
  late final GeneratedColumn<bool> isVatInclude = GeneratedColumn<bool>(
    'is_vat_include',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_vat_include" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _remarkMeta = const VerificationMeta('remark');
  @override
  late final GeneratedColumn<String> remark = GeneratedColumn<String>(
    'remark',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    orderId,
    orderNo,
    orderDate,
    orderType,
    customerId,
    customerName,
    customerAddress,
    customerTaxId,
    branchId,
    warehouseId,
    userId,
    tableId,
    partySize,
    subtotal,
    discountAmount,
    amountBeforeVat,
    vatAmount,
    totalAmount,
    paymentType,
    paidAmount,
    changeAmount,
    status,
    isVatInclude,
    remark,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sales_orders';
  @override
  VerificationContext validateIntegrity(
    Insertable<SalesOrder> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('order_id')) {
      context.handle(
        _orderIdMeta,
        orderId.isAcceptableOrUnknown(data['order_id']!, _orderIdMeta),
      );
    } else if (isInserting) {
      context.missing(_orderIdMeta);
    }
    if (data.containsKey('order_no')) {
      context.handle(
        _orderNoMeta,
        orderNo.isAcceptableOrUnknown(data['order_no']!, _orderNoMeta),
      );
    } else if (isInserting) {
      context.missing(_orderNoMeta);
    }
    if (data.containsKey('order_date')) {
      context.handle(
        _orderDateMeta,
        orderDate.isAcceptableOrUnknown(data['order_date']!, _orderDateMeta),
      );
    } else if (isInserting) {
      context.missing(_orderDateMeta);
    }
    if (data.containsKey('order_type')) {
      context.handle(
        _orderTypeMeta,
        orderType.isAcceptableOrUnknown(data['order_type']!, _orderTypeMeta),
      );
    }
    if (data.containsKey('customer_id')) {
      context.handle(
        _customerIdMeta,
        customerId.isAcceptableOrUnknown(data['customer_id']!, _customerIdMeta),
      );
    }
    if (data.containsKey('customer_name')) {
      context.handle(
        _customerNameMeta,
        customerName.isAcceptableOrUnknown(
          data['customer_name']!,
          _customerNameMeta,
        ),
      );
    }
    if (data.containsKey('customer_address')) {
      context.handle(
        _customerAddressMeta,
        customerAddress.isAcceptableOrUnknown(
          data['customer_address']!,
          _customerAddressMeta,
        ),
      );
    }
    if (data.containsKey('customer_tax_id')) {
      context.handle(
        _customerTaxIdMeta,
        customerTaxId.isAcceptableOrUnknown(
          data['customer_tax_id']!,
          _customerTaxIdMeta,
        ),
      );
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    } else if (isInserting) {
      context.missing(_branchIdMeta);
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
        _warehouseIdMeta,
        warehouseId.isAcceptableOrUnknown(
          data['warehouse_id']!,
          _warehouseIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('table_id')) {
      context.handle(
        _tableIdMeta,
        tableId.isAcceptableOrUnknown(data['table_id']!, _tableIdMeta),
      );
    }
    if (data.containsKey('party_size')) {
      context.handle(
        _partySizeMeta,
        partySize.isAcceptableOrUnknown(data['party_size']!, _partySizeMeta),
      );
    }
    if (data.containsKey('subtotal')) {
      context.handle(
        _subtotalMeta,
        subtotal.isAcceptableOrUnknown(data['subtotal']!, _subtotalMeta),
      );
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
        _discountAmountMeta,
        discountAmount.isAcceptableOrUnknown(
          data['discount_amount']!,
          _discountAmountMeta,
        ),
      );
    }
    if (data.containsKey('amount_before_vat')) {
      context.handle(
        _amountBeforeVatMeta,
        amountBeforeVat.isAcceptableOrUnknown(
          data['amount_before_vat']!,
          _amountBeforeVatMeta,
        ),
      );
    }
    if (data.containsKey('vat_amount')) {
      context.handle(
        _vatAmountMeta,
        vatAmount.isAcceptableOrUnknown(data['vat_amount']!, _vatAmountMeta),
      );
    }
    if (data.containsKey('total_amount')) {
      context.handle(
        _totalAmountMeta,
        totalAmount.isAcceptableOrUnknown(
          data['total_amount']!,
          _totalAmountMeta,
        ),
      );
    }
    if (data.containsKey('payment_type')) {
      context.handle(
        _paymentTypeMeta,
        paymentType.isAcceptableOrUnknown(
          data['payment_type']!,
          _paymentTypeMeta,
        ),
      );
    }
    if (data.containsKey('paid_amount')) {
      context.handle(
        _paidAmountMeta,
        paidAmount.isAcceptableOrUnknown(data['paid_amount']!, _paidAmountMeta),
      );
    }
    if (data.containsKey('change_amount')) {
      context.handle(
        _changeAmountMeta,
        changeAmount.isAcceptableOrUnknown(
          data['change_amount']!,
          _changeAmountMeta,
        ),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('is_vat_include')) {
      context.handle(
        _isVatIncludeMeta,
        isVatInclude.isAcceptableOrUnknown(
          data['is_vat_include']!,
          _isVatIncludeMeta,
        ),
      );
    }
    if (data.containsKey('remark')) {
      context.handle(
        _remarkMeta,
        remark.isAcceptableOrUnknown(data['remark']!, _remarkMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {orderId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {orderNo},
  ];
  @override
  SalesOrder map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SalesOrder(
      orderId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_id'],
      )!,
      orderNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_no'],
      )!,
      orderDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}order_date'],
      )!,
      orderType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_type'],
      )!,
      customerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_id'],
      ),
      customerName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_name'],
      ),
      customerAddress: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_address'],
      ),
      customerTaxId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_tax_id'],
      ),
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      )!,
      warehouseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}warehouse_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      tableId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}table_id'],
      ),
      partySize: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}party_size'],
      ),
      subtotal: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}subtotal'],
      )!,
      discountAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}discount_amount'],
      )!,
      amountBeforeVat: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}amount_before_vat'],
      )!,
      vatAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}vat_amount'],
      )!,
      totalAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_amount'],
      )!,
      paymentType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payment_type'],
      )!,
      paidAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}paid_amount'],
      )!,
      changeAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}change_amount'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      isVatInclude: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_vat_include'],
      )!,
      remark: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}remark'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $SalesOrdersTable createAlias(String alias) {
    return $SalesOrdersTable(attachedDatabase, alias);
  }
}

class SalesOrder extends DataClass implements Insertable<SalesOrder> {
  final String orderId;
  final String orderNo;
  final DateTime orderDate;
  final String orderType;
  final String? customerId;
  final String? customerName;
  final String? customerAddress;
  final String? customerTaxId;
  final String branchId;
  final String warehouseId;
  final String userId;
  final String? tableId;
  final int? partySize;
  final double subtotal;
  final double discountAmount;
  final double amountBeforeVat;
  final double vatAmount;
  final double totalAmount;
  final String paymentType;
  final double paidAmount;
  final double changeAmount;
  final String status;
  final bool isVatInclude;
  final String? remark;
  final DateTime createdAt;
  final DateTime updatedAt;
  const SalesOrder({
    required this.orderId,
    required this.orderNo,
    required this.orderDate,
    required this.orderType,
    this.customerId,
    this.customerName,
    this.customerAddress,
    this.customerTaxId,
    required this.branchId,
    required this.warehouseId,
    required this.userId,
    this.tableId,
    this.partySize,
    required this.subtotal,
    required this.discountAmount,
    required this.amountBeforeVat,
    required this.vatAmount,
    required this.totalAmount,
    required this.paymentType,
    required this.paidAmount,
    required this.changeAmount,
    required this.status,
    required this.isVatInclude,
    this.remark,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['order_id'] = Variable<String>(orderId);
    map['order_no'] = Variable<String>(orderNo);
    map['order_date'] = Variable<DateTime>(orderDate);
    map['order_type'] = Variable<String>(orderType);
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || customerName != null) {
      map['customer_name'] = Variable<String>(customerName);
    }
    if (!nullToAbsent || customerAddress != null) {
      map['customer_address'] = Variable<String>(customerAddress);
    }
    if (!nullToAbsent || customerTaxId != null) {
      map['customer_tax_id'] = Variable<String>(customerTaxId);
    }
    map['branch_id'] = Variable<String>(branchId);
    map['warehouse_id'] = Variable<String>(warehouseId);
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || tableId != null) {
      map['table_id'] = Variable<String>(tableId);
    }
    if (!nullToAbsent || partySize != null) {
      map['party_size'] = Variable<int>(partySize);
    }
    map['subtotal'] = Variable<double>(subtotal);
    map['discount_amount'] = Variable<double>(discountAmount);
    map['amount_before_vat'] = Variable<double>(amountBeforeVat);
    map['vat_amount'] = Variable<double>(vatAmount);
    map['total_amount'] = Variable<double>(totalAmount);
    map['payment_type'] = Variable<String>(paymentType);
    map['paid_amount'] = Variable<double>(paidAmount);
    map['change_amount'] = Variable<double>(changeAmount);
    map['status'] = Variable<String>(status);
    map['is_vat_include'] = Variable<bool>(isVatInclude);
    if (!nullToAbsent || remark != null) {
      map['remark'] = Variable<String>(remark);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SalesOrdersCompanion toCompanion(bool nullToAbsent) {
    return SalesOrdersCompanion(
      orderId: Value(orderId),
      orderNo: Value(orderNo),
      orderDate: Value(orderDate),
      orderType: Value(orderType),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      customerName: customerName == null && nullToAbsent
          ? const Value.absent()
          : Value(customerName),
      customerAddress: customerAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(customerAddress),
      customerTaxId: customerTaxId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerTaxId),
      branchId: Value(branchId),
      warehouseId: Value(warehouseId),
      userId: Value(userId),
      tableId: tableId == null && nullToAbsent
          ? const Value.absent()
          : Value(tableId),
      partySize: partySize == null && nullToAbsent
          ? const Value.absent()
          : Value(partySize),
      subtotal: Value(subtotal),
      discountAmount: Value(discountAmount),
      amountBeforeVat: Value(amountBeforeVat),
      vatAmount: Value(vatAmount),
      totalAmount: Value(totalAmount),
      paymentType: Value(paymentType),
      paidAmount: Value(paidAmount),
      changeAmount: Value(changeAmount),
      status: Value(status),
      isVatInclude: Value(isVatInclude),
      remark: remark == null && nullToAbsent
          ? const Value.absent()
          : Value(remark),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory SalesOrder.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesOrder(
      orderId: serializer.fromJson<String>(json['orderId']),
      orderNo: serializer.fromJson<String>(json['orderNo']),
      orderDate: serializer.fromJson<DateTime>(json['orderDate']),
      orderType: serializer.fromJson<String>(json['orderType']),
      customerId: serializer.fromJson<String?>(json['customerId']),
      customerName: serializer.fromJson<String?>(json['customerName']),
      customerAddress: serializer.fromJson<String?>(json['customerAddress']),
      customerTaxId: serializer.fromJson<String?>(json['customerTaxId']),
      branchId: serializer.fromJson<String>(json['branchId']),
      warehouseId: serializer.fromJson<String>(json['warehouseId']),
      userId: serializer.fromJson<String>(json['userId']),
      tableId: serializer.fromJson<String?>(json['tableId']),
      partySize: serializer.fromJson<int?>(json['partySize']),
      subtotal: serializer.fromJson<double>(json['subtotal']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      amountBeforeVat: serializer.fromJson<double>(json['amountBeforeVat']),
      vatAmount: serializer.fromJson<double>(json['vatAmount']),
      totalAmount: serializer.fromJson<double>(json['totalAmount']),
      paymentType: serializer.fromJson<String>(json['paymentType']),
      paidAmount: serializer.fromJson<double>(json['paidAmount']),
      changeAmount: serializer.fromJson<double>(json['changeAmount']),
      status: serializer.fromJson<String>(json['status']),
      isVatInclude: serializer.fromJson<bool>(json['isVatInclude']),
      remark: serializer.fromJson<String?>(json['remark']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'orderId': serializer.toJson<String>(orderId),
      'orderNo': serializer.toJson<String>(orderNo),
      'orderDate': serializer.toJson<DateTime>(orderDate),
      'orderType': serializer.toJson<String>(orderType),
      'customerId': serializer.toJson<String?>(customerId),
      'customerName': serializer.toJson<String?>(customerName),
      'customerAddress': serializer.toJson<String?>(customerAddress),
      'customerTaxId': serializer.toJson<String?>(customerTaxId),
      'branchId': serializer.toJson<String>(branchId),
      'warehouseId': serializer.toJson<String>(warehouseId),
      'userId': serializer.toJson<String>(userId),
      'tableId': serializer.toJson<String?>(tableId),
      'partySize': serializer.toJson<int?>(partySize),
      'subtotal': serializer.toJson<double>(subtotal),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'amountBeforeVat': serializer.toJson<double>(amountBeforeVat),
      'vatAmount': serializer.toJson<double>(vatAmount),
      'totalAmount': serializer.toJson<double>(totalAmount),
      'paymentType': serializer.toJson<String>(paymentType),
      'paidAmount': serializer.toJson<double>(paidAmount),
      'changeAmount': serializer.toJson<double>(changeAmount),
      'status': serializer.toJson<String>(status),
      'isVatInclude': serializer.toJson<bool>(isVatInclude),
      'remark': serializer.toJson<String?>(remark),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  SalesOrder copyWith({
    String? orderId,
    String? orderNo,
    DateTime? orderDate,
    String? orderType,
    Value<String?> customerId = const Value.absent(),
    Value<String?> customerName = const Value.absent(),
    Value<String?> customerAddress = const Value.absent(),
    Value<String?> customerTaxId = const Value.absent(),
    String? branchId,
    String? warehouseId,
    String? userId,
    Value<String?> tableId = const Value.absent(),
    Value<int?> partySize = const Value.absent(),
    double? subtotal,
    double? discountAmount,
    double? amountBeforeVat,
    double? vatAmount,
    double? totalAmount,
    String? paymentType,
    double? paidAmount,
    double? changeAmount,
    String? status,
    bool? isVatInclude,
    Value<String?> remark = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => SalesOrder(
    orderId: orderId ?? this.orderId,
    orderNo: orderNo ?? this.orderNo,
    orderDate: orderDate ?? this.orderDate,
    orderType: orderType ?? this.orderType,
    customerId: customerId.present ? customerId.value : this.customerId,
    customerName: customerName.present ? customerName.value : this.customerName,
    customerAddress: customerAddress.present
        ? customerAddress.value
        : this.customerAddress,
    customerTaxId: customerTaxId.present
        ? customerTaxId.value
        : this.customerTaxId,
    branchId: branchId ?? this.branchId,
    warehouseId: warehouseId ?? this.warehouseId,
    userId: userId ?? this.userId,
    tableId: tableId.present ? tableId.value : this.tableId,
    partySize: partySize.present ? partySize.value : this.partySize,
    subtotal: subtotal ?? this.subtotal,
    discountAmount: discountAmount ?? this.discountAmount,
    amountBeforeVat: amountBeforeVat ?? this.amountBeforeVat,
    vatAmount: vatAmount ?? this.vatAmount,
    totalAmount: totalAmount ?? this.totalAmount,
    paymentType: paymentType ?? this.paymentType,
    paidAmount: paidAmount ?? this.paidAmount,
    changeAmount: changeAmount ?? this.changeAmount,
    status: status ?? this.status,
    isVatInclude: isVatInclude ?? this.isVatInclude,
    remark: remark.present ? remark.value : this.remark,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  SalesOrder copyWithCompanion(SalesOrdersCompanion data) {
    return SalesOrder(
      orderId: data.orderId.present ? data.orderId.value : this.orderId,
      orderNo: data.orderNo.present ? data.orderNo.value : this.orderNo,
      orderDate: data.orderDate.present ? data.orderDate.value : this.orderDate,
      orderType: data.orderType.present ? data.orderType.value : this.orderType,
      customerId: data.customerId.present
          ? data.customerId.value
          : this.customerId,
      customerName: data.customerName.present
          ? data.customerName.value
          : this.customerName,
      customerAddress: data.customerAddress.present
          ? data.customerAddress.value
          : this.customerAddress,
      customerTaxId: data.customerTaxId.present
          ? data.customerTaxId.value
          : this.customerTaxId,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      warehouseId: data.warehouseId.present
          ? data.warehouseId.value
          : this.warehouseId,
      userId: data.userId.present ? data.userId.value : this.userId,
      tableId: data.tableId.present ? data.tableId.value : this.tableId,
      partySize: data.partySize.present ? data.partySize.value : this.partySize,
      subtotal: data.subtotal.present ? data.subtotal.value : this.subtotal,
      discountAmount: data.discountAmount.present
          ? data.discountAmount.value
          : this.discountAmount,
      amountBeforeVat: data.amountBeforeVat.present
          ? data.amountBeforeVat.value
          : this.amountBeforeVat,
      vatAmount: data.vatAmount.present ? data.vatAmount.value : this.vatAmount,
      totalAmount: data.totalAmount.present
          ? data.totalAmount.value
          : this.totalAmount,
      paymentType: data.paymentType.present
          ? data.paymentType.value
          : this.paymentType,
      paidAmount: data.paidAmount.present
          ? data.paidAmount.value
          : this.paidAmount,
      changeAmount: data.changeAmount.present
          ? data.changeAmount.value
          : this.changeAmount,
      status: data.status.present ? data.status.value : this.status,
      isVatInclude: data.isVatInclude.present
          ? data.isVatInclude.value
          : this.isVatInclude,
      remark: data.remark.present ? data.remark.value : this.remark,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SalesOrder(')
          ..write('orderId: $orderId, ')
          ..write('orderNo: $orderNo, ')
          ..write('orderDate: $orderDate, ')
          ..write('orderType: $orderType, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('customerAddress: $customerAddress, ')
          ..write('customerTaxId: $customerTaxId, ')
          ..write('branchId: $branchId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('userId: $userId, ')
          ..write('tableId: $tableId, ')
          ..write('partySize: $partySize, ')
          ..write('subtotal: $subtotal, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('amountBeforeVat: $amountBeforeVat, ')
          ..write('vatAmount: $vatAmount, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('paymentType: $paymentType, ')
          ..write('paidAmount: $paidAmount, ')
          ..write('changeAmount: $changeAmount, ')
          ..write('status: $status, ')
          ..write('isVatInclude: $isVatInclude, ')
          ..write('remark: $remark, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    orderId,
    orderNo,
    orderDate,
    orderType,
    customerId,
    customerName,
    customerAddress,
    customerTaxId,
    branchId,
    warehouseId,
    userId,
    tableId,
    partySize,
    subtotal,
    discountAmount,
    amountBeforeVat,
    vatAmount,
    totalAmount,
    paymentType,
    paidAmount,
    changeAmount,
    status,
    isVatInclude,
    remark,
    createdAt,
    updatedAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesOrder &&
          other.orderId == this.orderId &&
          other.orderNo == this.orderNo &&
          other.orderDate == this.orderDate &&
          other.orderType == this.orderType &&
          other.customerId == this.customerId &&
          other.customerName == this.customerName &&
          other.customerAddress == this.customerAddress &&
          other.customerTaxId == this.customerTaxId &&
          other.branchId == this.branchId &&
          other.warehouseId == this.warehouseId &&
          other.userId == this.userId &&
          other.tableId == this.tableId &&
          other.partySize == this.partySize &&
          other.subtotal == this.subtotal &&
          other.discountAmount == this.discountAmount &&
          other.amountBeforeVat == this.amountBeforeVat &&
          other.vatAmount == this.vatAmount &&
          other.totalAmount == this.totalAmount &&
          other.paymentType == this.paymentType &&
          other.paidAmount == this.paidAmount &&
          other.changeAmount == this.changeAmount &&
          other.status == this.status &&
          other.isVatInclude == this.isVatInclude &&
          other.remark == this.remark &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SalesOrdersCompanion extends UpdateCompanion<SalesOrder> {
  final Value<String> orderId;
  final Value<String> orderNo;
  final Value<DateTime> orderDate;
  final Value<String> orderType;
  final Value<String?> customerId;
  final Value<String?> customerName;
  final Value<String?> customerAddress;
  final Value<String?> customerTaxId;
  final Value<String> branchId;
  final Value<String> warehouseId;
  final Value<String> userId;
  final Value<String?> tableId;
  final Value<int?> partySize;
  final Value<double> subtotal;
  final Value<double> discountAmount;
  final Value<double> amountBeforeVat;
  final Value<double> vatAmount;
  final Value<double> totalAmount;
  final Value<String> paymentType;
  final Value<double> paidAmount;
  final Value<double> changeAmount;
  final Value<String> status;
  final Value<bool> isVatInclude;
  final Value<String?> remark;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const SalesOrdersCompanion({
    this.orderId = const Value.absent(),
    this.orderNo = const Value.absent(),
    this.orderDate = const Value.absent(),
    this.orderType = const Value.absent(),
    this.customerId = const Value.absent(),
    this.customerName = const Value.absent(),
    this.customerAddress = const Value.absent(),
    this.customerTaxId = const Value.absent(),
    this.branchId = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.userId = const Value.absent(),
    this.tableId = const Value.absent(),
    this.partySize = const Value.absent(),
    this.subtotal = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.amountBeforeVat = const Value.absent(),
    this.vatAmount = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.paymentType = const Value.absent(),
    this.paidAmount = const Value.absent(),
    this.changeAmount = const Value.absent(),
    this.status = const Value.absent(),
    this.isVatInclude = const Value.absent(),
    this.remark = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SalesOrdersCompanion.insert({
    required String orderId,
    required String orderNo,
    required DateTime orderDate,
    this.orderType = const Value.absent(),
    this.customerId = const Value.absent(),
    this.customerName = const Value.absent(),
    this.customerAddress = const Value.absent(),
    this.customerTaxId = const Value.absent(),
    required String branchId,
    required String warehouseId,
    required String userId,
    this.tableId = const Value.absent(),
    this.partySize = const Value.absent(),
    this.subtotal = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.amountBeforeVat = const Value.absent(),
    this.vatAmount = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.paymentType = const Value.absent(),
    this.paidAmount = const Value.absent(),
    this.changeAmount = const Value.absent(),
    this.status = const Value.absent(),
    this.isVatInclude = const Value.absent(),
    this.remark = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : orderId = Value(orderId),
       orderNo = Value(orderNo),
       orderDate = Value(orderDate),
       branchId = Value(branchId),
       warehouseId = Value(warehouseId),
       userId = Value(userId);
  static Insertable<SalesOrder> custom({
    Expression<String>? orderId,
    Expression<String>? orderNo,
    Expression<DateTime>? orderDate,
    Expression<String>? orderType,
    Expression<String>? customerId,
    Expression<String>? customerName,
    Expression<String>? customerAddress,
    Expression<String>? customerTaxId,
    Expression<String>? branchId,
    Expression<String>? warehouseId,
    Expression<String>? userId,
    Expression<String>? tableId,
    Expression<int>? partySize,
    Expression<double>? subtotal,
    Expression<double>? discountAmount,
    Expression<double>? amountBeforeVat,
    Expression<double>? vatAmount,
    Expression<double>? totalAmount,
    Expression<String>? paymentType,
    Expression<double>? paidAmount,
    Expression<double>? changeAmount,
    Expression<String>? status,
    Expression<bool>? isVatInclude,
    Expression<String>? remark,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (orderId != null) 'order_id': orderId,
      if (orderNo != null) 'order_no': orderNo,
      if (orderDate != null) 'order_date': orderDate,
      if (orderType != null) 'order_type': orderType,
      if (customerId != null) 'customer_id': customerId,
      if (customerName != null) 'customer_name': customerName,
      if (customerAddress != null) 'customer_address': customerAddress,
      if (customerTaxId != null) 'customer_tax_id': customerTaxId,
      if (branchId != null) 'branch_id': branchId,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (userId != null) 'user_id': userId,
      if (tableId != null) 'table_id': tableId,
      if (partySize != null) 'party_size': partySize,
      if (subtotal != null) 'subtotal': subtotal,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (amountBeforeVat != null) 'amount_before_vat': amountBeforeVat,
      if (vatAmount != null) 'vat_amount': vatAmount,
      if (totalAmount != null) 'total_amount': totalAmount,
      if (paymentType != null) 'payment_type': paymentType,
      if (paidAmount != null) 'paid_amount': paidAmount,
      if (changeAmount != null) 'change_amount': changeAmount,
      if (status != null) 'status': status,
      if (isVatInclude != null) 'is_vat_include': isVatInclude,
      if (remark != null) 'remark': remark,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SalesOrdersCompanion copyWith({
    Value<String>? orderId,
    Value<String>? orderNo,
    Value<DateTime>? orderDate,
    Value<String>? orderType,
    Value<String?>? customerId,
    Value<String?>? customerName,
    Value<String?>? customerAddress,
    Value<String?>? customerTaxId,
    Value<String>? branchId,
    Value<String>? warehouseId,
    Value<String>? userId,
    Value<String?>? tableId,
    Value<int?>? partySize,
    Value<double>? subtotal,
    Value<double>? discountAmount,
    Value<double>? amountBeforeVat,
    Value<double>? vatAmount,
    Value<double>? totalAmount,
    Value<String>? paymentType,
    Value<double>? paidAmount,
    Value<double>? changeAmount,
    Value<String>? status,
    Value<bool>? isVatInclude,
    Value<String?>? remark,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return SalesOrdersCompanion(
      orderId: orderId ?? this.orderId,
      orderNo: orderNo ?? this.orderNo,
      orderDate: orderDate ?? this.orderDate,
      orderType: orderType ?? this.orderType,
      customerId: customerId ?? this.customerId,
      customerName: customerName ?? this.customerName,
      customerAddress: customerAddress ?? this.customerAddress,
      customerTaxId: customerTaxId ?? this.customerTaxId,
      branchId: branchId ?? this.branchId,
      warehouseId: warehouseId ?? this.warehouseId,
      userId: userId ?? this.userId,
      tableId: tableId ?? this.tableId,
      partySize: partySize ?? this.partySize,
      subtotal: subtotal ?? this.subtotal,
      discountAmount: discountAmount ?? this.discountAmount,
      amountBeforeVat: amountBeforeVat ?? this.amountBeforeVat,
      vatAmount: vatAmount ?? this.vatAmount,
      totalAmount: totalAmount ?? this.totalAmount,
      paymentType: paymentType ?? this.paymentType,
      paidAmount: paidAmount ?? this.paidAmount,
      changeAmount: changeAmount ?? this.changeAmount,
      status: status ?? this.status,
      isVatInclude: isVatInclude ?? this.isVatInclude,
      remark: remark ?? this.remark,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (orderId.present) {
      map['order_id'] = Variable<String>(orderId.value);
    }
    if (orderNo.present) {
      map['order_no'] = Variable<String>(orderNo.value);
    }
    if (orderDate.present) {
      map['order_date'] = Variable<DateTime>(orderDate.value);
    }
    if (orderType.present) {
      map['order_type'] = Variable<String>(orderType.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (customerName.present) {
      map['customer_name'] = Variable<String>(customerName.value);
    }
    if (customerAddress.present) {
      map['customer_address'] = Variable<String>(customerAddress.value);
    }
    if (customerTaxId.present) {
      map['customer_tax_id'] = Variable<String>(customerTaxId.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<String>(warehouseId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (tableId.present) {
      map['table_id'] = Variable<String>(tableId.value);
    }
    if (partySize.present) {
      map['party_size'] = Variable<int>(partySize.value);
    }
    if (subtotal.present) {
      map['subtotal'] = Variable<double>(subtotal.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (amountBeforeVat.present) {
      map['amount_before_vat'] = Variable<double>(amountBeforeVat.value);
    }
    if (vatAmount.present) {
      map['vat_amount'] = Variable<double>(vatAmount.value);
    }
    if (totalAmount.present) {
      map['total_amount'] = Variable<double>(totalAmount.value);
    }
    if (paymentType.present) {
      map['payment_type'] = Variable<String>(paymentType.value);
    }
    if (paidAmount.present) {
      map['paid_amount'] = Variable<double>(paidAmount.value);
    }
    if (changeAmount.present) {
      map['change_amount'] = Variable<double>(changeAmount.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (isVatInclude.present) {
      map['is_vat_include'] = Variable<bool>(isVatInclude.value);
    }
    if (remark.present) {
      map['remark'] = Variable<String>(remark.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesOrdersCompanion(')
          ..write('orderId: $orderId, ')
          ..write('orderNo: $orderNo, ')
          ..write('orderDate: $orderDate, ')
          ..write('orderType: $orderType, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('customerAddress: $customerAddress, ')
          ..write('customerTaxId: $customerTaxId, ')
          ..write('branchId: $branchId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('userId: $userId, ')
          ..write('tableId: $tableId, ')
          ..write('partySize: $partySize, ')
          ..write('subtotal: $subtotal, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('amountBeforeVat: $amountBeforeVat, ')
          ..write('vatAmount: $vatAmount, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('paymentType: $paymentType, ')
          ..write('paidAmount: $paidAmount, ')
          ..write('changeAmount: $changeAmount, ')
          ..write('status: $status, ')
          ..write('isVatInclude: $isVatInclude, ')
          ..write('remark: $remark, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SalesOrderItemsTable extends SalesOrderItems
    with TableInfo<$SalesOrderItemsTable, SalesOrderItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SalesOrderItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
    'item_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _orderIdMeta = const VerificationMeta(
    'orderId',
  );
  @override
  late final GeneratedColumn<String> orderId = GeneratedColumn<String>(
    'order_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sales_orders (order_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _lineNoMeta = const VerificationMeta('lineNo');
  @override
  late final GeneratedColumn<int> lineNo = GeneratedColumn<int>(
    'line_no',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES products (product_id)',
    ),
  );
  static const VerificationMeta _productCodeMeta = const VerificationMeta(
    'productCode',
  );
  @override
  late final GeneratedColumn<String> productCode = GeneratedColumn<String>(
    'product_code',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productNameMeta = const VerificationMeta(
    'productName',
  );
  @override
  late final GeneratedColumn<String> productName = GeneratedColumn<String>(
    'product_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 500),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _unitMeta = const VerificationMeta('unit');
  @override
  late final GeneratedColumn<String> unit = GeneratedColumn<String>(
    'unit',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _unitPriceMeta = const VerificationMeta(
    'unitPrice',
  );
  @override
  late final GeneratedColumn<double> unitPrice = GeneratedColumn<double>(
    'unit_price',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _discountPercentMeta = const VerificationMeta(
    'discountPercent',
  );
  @override
  late final GeneratedColumn<double> discountPercent = GeneratedColumn<double>(
    'discount_percent',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _discountAmountMeta = const VerificationMeta(
    'discountAmount',
  );
  @override
  late final GeneratedColumn<double> discountAmount = GeneratedColumn<double>(
    'discount_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
    'amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _costMeta = const VerificationMeta('cost');
  @override
  late final GeneratedColumn<double> cost = GeneratedColumn<double>(
    'cost',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _warehouseIdMeta = const VerificationMeta(
    'warehouseId',
  );
  @override
  late final GeneratedColumn<String> warehouseId = GeneratedColumn<String>(
    'warehouse_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES warehouses (warehouse_id)',
    ),
  );
  static const VerificationMeta _serialNoMeta = const VerificationMeta(
    'serialNo',
  );
  @override
  late final GeneratedColumn<String> serialNo = GeneratedColumn<String>(
    'serial_no',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _kitchenStatusMeta = const VerificationMeta(
    'kitchenStatus',
  );
  @override
  late final GeneratedColumn<String> kitchenStatus = GeneratedColumn<String>(
    'kitchen_status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('PENDING'),
  );
  static const VerificationMeta _preparedAtMeta = const VerificationMeta(
    'preparedAt',
  );
  @override
  late final GeneratedColumn<DateTime> preparedAt = GeneratedColumn<DateTime>(
    'prepared_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _specialInstructionsMeta =
      const VerificationMeta('specialInstructions');
  @override
  late final GeneratedColumn<String> specialInstructions =
      GeneratedColumn<String>(
        'special_instructions',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    itemId,
    orderId,
    lineNo,
    productId,
    productCode,
    productName,
    unit,
    quantity,
    unitPrice,
    discountPercent,
    discountAmount,
    amount,
    cost,
    warehouseId,
    serialNo,
    kitchenStatus,
    preparedAt,
    specialInstructions,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sales_order_items';
  @override
  VerificationContext validateIntegrity(
    Insertable<SalesOrderItem> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('item_id')) {
      context.handle(
        _itemIdMeta,
        itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta),
      );
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('order_id')) {
      context.handle(
        _orderIdMeta,
        orderId.isAcceptableOrUnknown(data['order_id']!, _orderIdMeta),
      );
    } else if (isInserting) {
      context.missing(_orderIdMeta);
    }
    if (data.containsKey('line_no')) {
      context.handle(
        _lineNoMeta,
        lineNo.isAcceptableOrUnknown(data['line_no']!, _lineNoMeta),
      );
    } else if (isInserting) {
      context.missing(_lineNoMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('product_code')) {
      context.handle(
        _productCodeMeta,
        productCode.isAcceptableOrUnknown(
          data['product_code']!,
          _productCodeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_productCodeMeta);
    }
    if (data.containsKey('product_name')) {
      context.handle(
        _productNameMeta,
        productName.isAcceptableOrUnknown(
          data['product_name']!,
          _productNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_productNameMeta);
    }
    if (data.containsKey('unit')) {
      context.handle(
        _unitMeta,
        unit.isAcceptableOrUnknown(data['unit']!, _unitMeta),
      );
    } else if (isInserting) {
      context.missing(_unitMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('unit_price')) {
      context.handle(
        _unitPriceMeta,
        unitPrice.isAcceptableOrUnknown(data['unit_price']!, _unitPriceMeta),
      );
    } else if (isInserting) {
      context.missing(_unitPriceMeta);
    }
    if (data.containsKey('discount_percent')) {
      context.handle(
        _discountPercentMeta,
        discountPercent.isAcceptableOrUnknown(
          data['discount_percent']!,
          _discountPercentMeta,
        ),
      );
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
        _discountAmountMeta,
        discountAmount.isAcceptableOrUnknown(
          data['discount_amount']!,
          _discountAmountMeta,
        ),
      );
    }
    if (data.containsKey('amount')) {
      context.handle(
        _amountMeta,
        amount.isAcceptableOrUnknown(data['amount']!, _amountMeta),
      );
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('cost')) {
      context.handle(
        _costMeta,
        cost.isAcceptableOrUnknown(data['cost']!, _costMeta),
      );
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
        _warehouseIdMeta,
        warehouseId.isAcceptableOrUnknown(
          data['warehouse_id']!,
          _warehouseIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('serial_no')) {
      context.handle(
        _serialNoMeta,
        serialNo.isAcceptableOrUnknown(data['serial_no']!, _serialNoMeta),
      );
    }
    if (data.containsKey('kitchen_status')) {
      context.handle(
        _kitchenStatusMeta,
        kitchenStatus.isAcceptableOrUnknown(
          data['kitchen_status']!,
          _kitchenStatusMeta,
        ),
      );
    }
    if (data.containsKey('prepared_at')) {
      context.handle(
        _preparedAtMeta,
        preparedAt.isAcceptableOrUnknown(data['prepared_at']!, _preparedAtMeta),
      );
    }
    if (data.containsKey('special_instructions')) {
      context.handle(
        _specialInstructionsMeta,
        specialInstructions.isAcceptableOrUnknown(
          data['special_instructions']!,
          _specialInstructionsMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {itemId};
  @override
  SalesOrderItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SalesOrderItem(
      itemId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}item_id'],
      )!,
      orderId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_id'],
      )!,
      lineNo: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}line_no'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_id'],
      )!,
      productCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_code'],
      )!,
      productName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_name'],
      )!,
      unit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}unit'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}quantity'],
      )!,
      unitPrice: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}unit_price'],
      )!,
      discountPercent: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}discount_percent'],
      )!,
      discountAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}discount_amount'],
      )!,
      amount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}amount'],
      )!,
      cost: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}cost'],
      )!,
      warehouseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}warehouse_id'],
      )!,
      serialNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}serial_no'],
      ),
      kitchenStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}kitchen_status'],
      )!,
      preparedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}prepared_at'],
      ),
      specialInstructions: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}special_instructions'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $SalesOrderItemsTable createAlias(String alias) {
    return $SalesOrderItemsTable(attachedDatabase, alias);
  }
}

class SalesOrderItem extends DataClass implements Insertable<SalesOrderItem> {
  final String itemId;
  final String orderId;
  final int lineNo;
  final String productId;
  final String productCode;
  final String productName;
  final String unit;
  final double quantity;
  final double unitPrice;
  final double discountPercent;
  final double discountAmount;
  final double amount;
  final double cost;
  final String warehouseId;
  final String? serialNo;
  final String kitchenStatus;
  final DateTime? preparedAt;
  final String? specialInstructions;
  final DateTime createdAt;
  const SalesOrderItem({
    required this.itemId,
    required this.orderId,
    required this.lineNo,
    required this.productId,
    required this.productCode,
    required this.productName,
    required this.unit,
    required this.quantity,
    required this.unitPrice,
    required this.discountPercent,
    required this.discountAmount,
    required this.amount,
    required this.cost,
    required this.warehouseId,
    this.serialNo,
    required this.kitchenStatus,
    this.preparedAt,
    this.specialInstructions,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['item_id'] = Variable<String>(itemId);
    map['order_id'] = Variable<String>(orderId);
    map['line_no'] = Variable<int>(lineNo);
    map['product_id'] = Variable<String>(productId);
    map['product_code'] = Variable<String>(productCode);
    map['product_name'] = Variable<String>(productName);
    map['unit'] = Variable<String>(unit);
    map['quantity'] = Variable<double>(quantity);
    map['unit_price'] = Variable<double>(unitPrice);
    map['discount_percent'] = Variable<double>(discountPercent);
    map['discount_amount'] = Variable<double>(discountAmount);
    map['amount'] = Variable<double>(amount);
    map['cost'] = Variable<double>(cost);
    map['warehouse_id'] = Variable<String>(warehouseId);
    if (!nullToAbsent || serialNo != null) {
      map['serial_no'] = Variable<String>(serialNo);
    }
    map['kitchen_status'] = Variable<String>(kitchenStatus);
    if (!nullToAbsent || preparedAt != null) {
      map['prepared_at'] = Variable<DateTime>(preparedAt);
    }
    if (!nullToAbsent || specialInstructions != null) {
      map['special_instructions'] = Variable<String>(specialInstructions);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  SalesOrderItemsCompanion toCompanion(bool nullToAbsent) {
    return SalesOrderItemsCompanion(
      itemId: Value(itemId),
      orderId: Value(orderId),
      lineNo: Value(lineNo),
      productId: Value(productId),
      productCode: Value(productCode),
      productName: Value(productName),
      unit: Value(unit),
      quantity: Value(quantity),
      unitPrice: Value(unitPrice),
      discountPercent: Value(discountPercent),
      discountAmount: Value(discountAmount),
      amount: Value(amount),
      cost: Value(cost),
      warehouseId: Value(warehouseId),
      serialNo: serialNo == null && nullToAbsent
          ? const Value.absent()
          : Value(serialNo),
      kitchenStatus: Value(kitchenStatus),
      preparedAt: preparedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(preparedAt),
      specialInstructions: specialInstructions == null && nullToAbsent
          ? const Value.absent()
          : Value(specialInstructions),
      createdAt: Value(createdAt),
    );
  }

  factory SalesOrderItem.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesOrderItem(
      itemId: serializer.fromJson<String>(json['itemId']),
      orderId: serializer.fromJson<String>(json['orderId']),
      lineNo: serializer.fromJson<int>(json['lineNo']),
      productId: serializer.fromJson<String>(json['productId']),
      productCode: serializer.fromJson<String>(json['productCode']),
      productName: serializer.fromJson<String>(json['productName']),
      unit: serializer.fromJson<String>(json['unit']),
      quantity: serializer.fromJson<double>(json['quantity']),
      unitPrice: serializer.fromJson<double>(json['unitPrice']),
      discountPercent: serializer.fromJson<double>(json['discountPercent']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      amount: serializer.fromJson<double>(json['amount']),
      cost: serializer.fromJson<double>(json['cost']),
      warehouseId: serializer.fromJson<String>(json['warehouseId']),
      serialNo: serializer.fromJson<String?>(json['serialNo']),
      kitchenStatus: serializer.fromJson<String>(json['kitchenStatus']),
      preparedAt: serializer.fromJson<DateTime?>(json['preparedAt']),
      specialInstructions: serializer.fromJson<String?>(
        json['specialInstructions'],
      ),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'itemId': serializer.toJson<String>(itemId),
      'orderId': serializer.toJson<String>(orderId),
      'lineNo': serializer.toJson<int>(lineNo),
      'productId': serializer.toJson<String>(productId),
      'productCode': serializer.toJson<String>(productCode),
      'productName': serializer.toJson<String>(productName),
      'unit': serializer.toJson<String>(unit),
      'quantity': serializer.toJson<double>(quantity),
      'unitPrice': serializer.toJson<double>(unitPrice),
      'discountPercent': serializer.toJson<double>(discountPercent),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'amount': serializer.toJson<double>(amount),
      'cost': serializer.toJson<double>(cost),
      'warehouseId': serializer.toJson<String>(warehouseId),
      'serialNo': serializer.toJson<String?>(serialNo),
      'kitchenStatus': serializer.toJson<String>(kitchenStatus),
      'preparedAt': serializer.toJson<DateTime?>(preparedAt),
      'specialInstructions': serializer.toJson<String?>(specialInstructions),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  SalesOrderItem copyWith({
    String? itemId,
    String? orderId,
    int? lineNo,
    String? productId,
    String? productCode,
    String? productName,
    String? unit,
    double? quantity,
    double? unitPrice,
    double? discountPercent,
    double? discountAmount,
    double? amount,
    double? cost,
    String? warehouseId,
    Value<String?> serialNo = const Value.absent(),
    String? kitchenStatus,
    Value<DateTime?> preparedAt = const Value.absent(),
    Value<String?> specialInstructions = const Value.absent(),
    DateTime? createdAt,
  }) => SalesOrderItem(
    itemId: itemId ?? this.itemId,
    orderId: orderId ?? this.orderId,
    lineNo: lineNo ?? this.lineNo,
    productId: productId ?? this.productId,
    productCode: productCode ?? this.productCode,
    productName: productName ?? this.productName,
    unit: unit ?? this.unit,
    quantity: quantity ?? this.quantity,
    unitPrice: unitPrice ?? this.unitPrice,
    discountPercent: discountPercent ?? this.discountPercent,
    discountAmount: discountAmount ?? this.discountAmount,
    amount: amount ?? this.amount,
    cost: cost ?? this.cost,
    warehouseId: warehouseId ?? this.warehouseId,
    serialNo: serialNo.present ? serialNo.value : this.serialNo,
    kitchenStatus: kitchenStatus ?? this.kitchenStatus,
    preparedAt: preparedAt.present ? preparedAt.value : this.preparedAt,
    specialInstructions: specialInstructions.present
        ? specialInstructions.value
        : this.specialInstructions,
    createdAt: createdAt ?? this.createdAt,
  );
  SalesOrderItem copyWithCompanion(SalesOrderItemsCompanion data) {
    return SalesOrderItem(
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      orderId: data.orderId.present ? data.orderId.value : this.orderId,
      lineNo: data.lineNo.present ? data.lineNo.value : this.lineNo,
      productId: data.productId.present ? data.productId.value : this.productId,
      productCode: data.productCode.present
          ? data.productCode.value
          : this.productCode,
      productName: data.productName.present
          ? data.productName.value
          : this.productName,
      unit: data.unit.present ? data.unit.value : this.unit,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      unitPrice: data.unitPrice.present ? data.unitPrice.value : this.unitPrice,
      discountPercent: data.discountPercent.present
          ? data.discountPercent.value
          : this.discountPercent,
      discountAmount: data.discountAmount.present
          ? data.discountAmount.value
          : this.discountAmount,
      amount: data.amount.present ? data.amount.value : this.amount,
      cost: data.cost.present ? data.cost.value : this.cost,
      warehouseId: data.warehouseId.present
          ? data.warehouseId.value
          : this.warehouseId,
      serialNo: data.serialNo.present ? data.serialNo.value : this.serialNo,
      kitchenStatus: data.kitchenStatus.present
          ? data.kitchenStatus.value
          : this.kitchenStatus,
      preparedAt: data.preparedAt.present
          ? data.preparedAt.value
          : this.preparedAt,
      specialInstructions: data.specialInstructions.present
          ? data.specialInstructions.value
          : this.specialInstructions,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SalesOrderItem(')
          ..write('itemId: $itemId, ')
          ..write('orderId: $orderId, ')
          ..write('lineNo: $lineNo, ')
          ..write('productId: $productId, ')
          ..write('productCode: $productCode, ')
          ..write('productName: $productName, ')
          ..write('unit: $unit, ')
          ..write('quantity: $quantity, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('discountPercent: $discountPercent, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('amount: $amount, ')
          ..write('cost: $cost, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('serialNo: $serialNo, ')
          ..write('kitchenStatus: $kitchenStatus, ')
          ..write('preparedAt: $preparedAt, ')
          ..write('specialInstructions: $specialInstructions, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    itemId,
    orderId,
    lineNo,
    productId,
    productCode,
    productName,
    unit,
    quantity,
    unitPrice,
    discountPercent,
    discountAmount,
    amount,
    cost,
    warehouseId,
    serialNo,
    kitchenStatus,
    preparedAt,
    specialInstructions,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesOrderItem &&
          other.itemId == this.itemId &&
          other.orderId == this.orderId &&
          other.lineNo == this.lineNo &&
          other.productId == this.productId &&
          other.productCode == this.productCode &&
          other.productName == this.productName &&
          other.unit == this.unit &&
          other.quantity == this.quantity &&
          other.unitPrice == this.unitPrice &&
          other.discountPercent == this.discountPercent &&
          other.discountAmount == this.discountAmount &&
          other.amount == this.amount &&
          other.cost == this.cost &&
          other.warehouseId == this.warehouseId &&
          other.serialNo == this.serialNo &&
          other.kitchenStatus == this.kitchenStatus &&
          other.preparedAt == this.preparedAt &&
          other.specialInstructions == this.specialInstructions &&
          other.createdAt == this.createdAt);
}

class SalesOrderItemsCompanion extends UpdateCompanion<SalesOrderItem> {
  final Value<String> itemId;
  final Value<String> orderId;
  final Value<int> lineNo;
  final Value<String> productId;
  final Value<String> productCode;
  final Value<String> productName;
  final Value<String> unit;
  final Value<double> quantity;
  final Value<double> unitPrice;
  final Value<double> discountPercent;
  final Value<double> discountAmount;
  final Value<double> amount;
  final Value<double> cost;
  final Value<String> warehouseId;
  final Value<String?> serialNo;
  final Value<String> kitchenStatus;
  final Value<DateTime?> preparedAt;
  final Value<String?> specialInstructions;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const SalesOrderItemsCompanion({
    this.itemId = const Value.absent(),
    this.orderId = const Value.absent(),
    this.lineNo = const Value.absent(),
    this.productId = const Value.absent(),
    this.productCode = const Value.absent(),
    this.productName = const Value.absent(),
    this.unit = const Value.absent(),
    this.quantity = const Value.absent(),
    this.unitPrice = const Value.absent(),
    this.discountPercent = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.amount = const Value.absent(),
    this.cost = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.serialNo = const Value.absent(),
    this.kitchenStatus = const Value.absent(),
    this.preparedAt = const Value.absent(),
    this.specialInstructions = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SalesOrderItemsCompanion.insert({
    required String itemId,
    required String orderId,
    required int lineNo,
    required String productId,
    required String productCode,
    required String productName,
    required String unit,
    required double quantity,
    required double unitPrice,
    this.discountPercent = const Value.absent(),
    this.discountAmount = const Value.absent(),
    required double amount,
    this.cost = const Value.absent(),
    required String warehouseId,
    this.serialNo = const Value.absent(),
    this.kitchenStatus = const Value.absent(),
    this.preparedAt = const Value.absent(),
    this.specialInstructions = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : itemId = Value(itemId),
       orderId = Value(orderId),
       lineNo = Value(lineNo),
       productId = Value(productId),
       productCode = Value(productCode),
       productName = Value(productName),
       unit = Value(unit),
       quantity = Value(quantity),
       unitPrice = Value(unitPrice),
       amount = Value(amount),
       warehouseId = Value(warehouseId);
  static Insertable<SalesOrderItem> custom({
    Expression<String>? itemId,
    Expression<String>? orderId,
    Expression<int>? lineNo,
    Expression<String>? productId,
    Expression<String>? productCode,
    Expression<String>? productName,
    Expression<String>? unit,
    Expression<double>? quantity,
    Expression<double>? unitPrice,
    Expression<double>? discountPercent,
    Expression<double>? discountAmount,
    Expression<double>? amount,
    Expression<double>? cost,
    Expression<String>? warehouseId,
    Expression<String>? serialNo,
    Expression<String>? kitchenStatus,
    Expression<DateTime>? preparedAt,
    Expression<String>? specialInstructions,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (itemId != null) 'item_id': itemId,
      if (orderId != null) 'order_id': orderId,
      if (lineNo != null) 'line_no': lineNo,
      if (productId != null) 'product_id': productId,
      if (productCode != null) 'product_code': productCode,
      if (productName != null) 'product_name': productName,
      if (unit != null) 'unit': unit,
      if (quantity != null) 'quantity': quantity,
      if (unitPrice != null) 'unit_price': unitPrice,
      if (discountPercent != null) 'discount_percent': discountPercent,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (amount != null) 'amount': amount,
      if (cost != null) 'cost': cost,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (serialNo != null) 'serial_no': serialNo,
      if (kitchenStatus != null) 'kitchen_status': kitchenStatus,
      if (preparedAt != null) 'prepared_at': preparedAt,
      if (specialInstructions != null)
        'special_instructions': specialInstructions,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SalesOrderItemsCompanion copyWith({
    Value<String>? itemId,
    Value<String>? orderId,
    Value<int>? lineNo,
    Value<String>? productId,
    Value<String>? productCode,
    Value<String>? productName,
    Value<String>? unit,
    Value<double>? quantity,
    Value<double>? unitPrice,
    Value<double>? discountPercent,
    Value<double>? discountAmount,
    Value<double>? amount,
    Value<double>? cost,
    Value<String>? warehouseId,
    Value<String?>? serialNo,
    Value<String>? kitchenStatus,
    Value<DateTime?>? preparedAt,
    Value<String?>? specialInstructions,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return SalesOrderItemsCompanion(
      itemId: itemId ?? this.itemId,
      orderId: orderId ?? this.orderId,
      lineNo: lineNo ?? this.lineNo,
      productId: productId ?? this.productId,
      productCode: productCode ?? this.productCode,
      productName: productName ?? this.productName,
      unit: unit ?? this.unit,
      quantity: quantity ?? this.quantity,
      unitPrice: unitPrice ?? this.unitPrice,
      discountPercent: discountPercent ?? this.discountPercent,
      discountAmount: discountAmount ?? this.discountAmount,
      amount: amount ?? this.amount,
      cost: cost ?? this.cost,
      warehouseId: warehouseId ?? this.warehouseId,
      serialNo: serialNo ?? this.serialNo,
      kitchenStatus: kitchenStatus ?? this.kitchenStatus,
      preparedAt: preparedAt ?? this.preparedAt,
      specialInstructions: specialInstructions ?? this.specialInstructions,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (orderId.present) {
      map['order_id'] = Variable<String>(orderId.value);
    }
    if (lineNo.present) {
      map['line_no'] = Variable<int>(lineNo.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (productCode.present) {
      map['product_code'] = Variable<String>(productCode.value);
    }
    if (productName.present) {
      map['product_name'] = Variable<String>(productName.value);
    }
    if (unit.present) {
      map['unit'] = Variable<String>(unit.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (unitPrice.present) {
      map['unit_price'] = Variable<double>(unitPrice.value);
    }
    if (discountPercent.present) {
      map['discount_percent'] = Variable<double>(discountPercent.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (cost.present) {
      map['cost'] = Variable<double>(cost.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<String>(warehouseId.value);
    }
    if (serialNo.present) {
      map['serial_no'] = Variable<String>(serialNo.value);
    }
    if (kitchenStatus.present) {
      map['kitchen_status'] = Variable<String>(kitchenStatus.value);
    }
    if (preparedAt.present) {
      map['prepared_at'] = Variable<DateTime>(preparedAt.value);
    }
    if (specialInstructions.present) {
      map['special_instructions'] = Variable<String>(specialInstructions.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesOrderItemsCompanion(')
          ..write('itemId: $itemId, ')
          ..write('orderId: $orderId, ')
          ..write('lineNo: $lineNo, ')
          ..write('productId: $productId, ')
          ..write('productCode: $productCode, ')
          ..write('productName: $productName, ')
          ..write('unit: $unit, ')
          ..write('quantity: $quantity, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('discountPercent: $discountPercent, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('amount: $amount, ')
          ..write('cost: $cost, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('serialNo: $serialNo, ')
          ..write('kitchenStatus: $kitchenStatus, ')
          ..write('preparedAt: $preparedAt, ')
          ..write('specialInstructions: $specialInstructions, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OrderItemModifiersTable extends OrderItemModifiers
    with TableInfo<$OrderItemModifiersTable, OrderItemModifier> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrderItemModifiersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _itemModifierIdMeta = const VerificationMeta(
    'itemModifierId',
  );
  @override
  late final GeneratedColumn<String> itemModifierId = GeneratedColumn<String>(
    'item_modifier_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _orderItemIdMeta = const VerificationMeta(
    'orderItemId',
  );
  @override
  late final GeneratedColumn<String> orderItemId = GeneratedColumn<String>(
    'order_item_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sales_order_items (item_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _modifierIdMeta = const VerificationMeta(
    'modifierId',
  );
  @override
  late final GeneratedColumn<String> modifierId = GeneratedColumn<String>(
    'modifier_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES modifiers (modifier_id)',
    ),
  );
  static const VerificationMeta _modifierNameMeta = const VerificationMeta(
    'modifierName',
  );
  @override
  late final GeneratedColumn<String> modifierName = GeneratedColumn<String>(
    'modifier_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _priceAdjustmentMeta = const VerificationMeta(
    'priceAdjustment',
  );
  @override
  late final GeneratedColumn<double> priceAdjustment = GeneratedColumn<double>(
    'price_adjustment',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    itemModifierId,
    orderItemId,
    modifierId,
    modifierName,
    priceAdjustment,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'order_item_modifiers';
  @override
  VerificationContext validateIntegrity(
    Insertable<OrderItemModifier> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('item_modifier_id')) {
      context.handle(
        _itemModifierIdMeta,
        itemModifierId.isAcceptableOrUnknown(
          data['item_modifier_id']!,
          _itemModifierIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_itemModifierIdMeta);
    }
    if (data.containsKey('order_item_id')) {
      context.handle(
        _orderItemIdMeta,
        orderItemId.isAcceptableOrUnknown(
          data['order_item_id']!,
          _orderItemIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_orderItemIdMeta);
    }
    if (data.containsKey('modifier_id')) {
      context.handle(
        _modifierIdMeta,
        modifierId.isAcceptableOrUnknown(data['modifier_id']!, _modifierIdMeta),
      );
    } else if (isInserting) {
      context.missing(_modifierIdMeta);
    }
    if (data.containsKey('modifier_name')) {
      context.handle(
        _modifierNameMeta,
        modifierName.isAcceptableOrUnknown(
          data['modifier_name']!,
          _modifierNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_modifierNameMeta);
    }
    if (data.containsKey('price_adjustment')) {
      context.handle(
        _priceAdjustmentMeta,
        priceAdjustment.isAcceptableOrUnknown(
          data['price_adjustment']!,
          _priceAdjustmentMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {itemModifierId};
  @override
  OrderItemModifier map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrderItemModifier(
      itemModifierId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}item_modifier_id'],
      )!,
      orderItemId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_item_id'],
      )!,
      modifierId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}modifier_id'],
      )!,
      modifierName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}modifier_name'],
      )!,
      priceAdjustment: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_adjustment'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $OrderItemModifiersTable createAlias(String alias) {
    return $OrderItemModifiersTable(attachedDatabase, alias);
  }
}

class OrderItemModifier extends DataClass
    implements Insertable<OrderItemModifier> {
  final String itemModifierId;
  final String orderItemId;
  final String modifierId;
  final String modifierName;
  final double priceAdjustment;
  final DateTime createdAt;
  const OrderItemModifier({
    required this.itemModifierId,
    required this.orderItemId,
    required this.modifierId,
    required this.modifierName,
    required this.priceAdjustment,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['item_modifier_id'] = Variable<String>(itemModifierId);
    map['order_item_id'] = Variable<String>(orderItemId);
    map['modifier_id'] = Variable<String>(modifierId);
    map['modifier_name'] = Variable<String>(modifierName);
    map['price_adjustment'] = Variable<double>(priceAdjustment);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  OrderItemModifiersCompanion toCompanion(bool nullToAbsent) {
    return OrderItemModifiersCompanion(
      itemModifierId: Value(itemModifierId),
      orderItemId: Value(orderItemId),
      modifierId: Value(modifierId),
      modifierName: Value(modifierName),
      priceAdjustment: Value(priceAdjustment),
      createdAt: Value(createdAt),
    );
  }

  factory OrderItemModifier.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrderItemModifier(
      itemModifierId: serializer.fromJson<String>(json['itemModifierId']),
      orderItemId: serializer.fromJson<String>(json['orderItemId']),
      modifierId: serializer.fromJson<String>(json['modifierId']),
      modifierName: serializer.fromJson<String>(json['modifierName']),
      priceAdjustment: serializer.fromJson<double>(json['priceAdjustment']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'itemModifierId': serializer.toJson<String>(itemModifierId),
      'orderItemId': serializer.toJson<String>(orderItemId),
      'modifierId': serializer.toJson<String>(modifierId),
      'modifierName': serializer.toJson<String>(modifierName),
      'priceAdjustment': serializer.toJson<double>(priceAdjustment),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  OrderItemModifier copyWith({
    String? itemModifierId,
    String? orderItemId,
    String? modifierId,
    String? modifierName,
    double? priceAdjustment,
    DateTime? createdAt,
  }) => OrderItemModifier(
    itemModifierId: itemModifierId ?? this.itemModifierId,
    orderItemId: orderItemId ?? this.orderItemId,
    modifierId: modifierId ?? this.modifierId,
    modifierName: modifierName ?? this.modifierName,
    priceAdjustment: priceAdjustment ?? this.priceAdjustment,
    createdAt: createdAt ?? this.createdAt,
  );
  OrderItemModifier copyWithCompanion(OrderItemModifiersCompanion data) {
    return OrderItemModifier(
      itemModifierId: data.itemModifierId.present
          ? data.itemModifierId.value
          : this.itemModifierId,
      orderItemId: data.orderItemId.present
          ? data.orderItemId.value
          : this.orderItemId,
      modifierId: data.modifierId.present
          ? data.modifierId.value
          : this.modifierId,
      modifierName: data.modifierName.present
          ? data.modifierName.value
          : this.modifierName,
      priceAdjustment: data.priceAdjustment.present
          ? data.priceAdjustment.value
          : this.priceAdjustment,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OrderItemModifier(')
          ..write('itemModifierId: $itemModifierId, ')
          ..write('orderItemId: $orderItemId, ')
          ..write('modifierId: $modifierId, ')
          ..write('modifierName: $modifierName, ')
          ..write('priceAdjustment: $priceAdjustment, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    itemModifierId,
    orderItemId,
    modifierId,
    modifierName,
    priceAdjustment,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrderItemModifier &&
          other.itemModifierId == this.itemModifierId &&
          other.orderItemId == this.orderItemId &&
          other.modifierId == this.modifierId &&
          other.modifierName == this.modifierName &&
          other.priceAdjustment == this.priceAdjustment &&
          other.createdAt == this.createdAt);
}

class OrderItemModifiersCompanion extends UpdateCompanion<OrderItemModifier> {
  final Value<String> itemModifierId;
  final Value<String> orderItemId;
  final Value<String> modifierId;
  final Value<String> modifierName;
  final Value<double> priceAdjustment;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const OrderItemModifiersCompanion({
    this.itemModifierId = const Value.absent(),
    this.orderItemId = const Value.absent(),
    this.modifierId = const Value.absent(),
    this.modifierName = const Value.absent(),
    this.priceAdjustment = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OrderItemModifiersCompanion.insert({
    required String itemModifierId,
    required String orderItemId,
    required String modifierId,
    required String modifierName,
    this.priceAdjustment = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : itemModifierId = Value(itemModifierId),
       orderItemId = Value(orderItemId),
       modifierId = Value(modifierId),
       modifierName = Value(modifierName);
  static Insertable<OrderItemModifier> custom({
    Expression<String>? itemModifierId,
    Expression<String>? orderItemId,
    Expression<String>? modifierId,
    Expression<String>? modifierName,
    Expression<double>? priceAdjustment,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (itemModifierId != null) 'item_modifier_id': itemModifierId,
      if (orderItemId != null) 'order_item_id': orderItemId,
      if (modifierId != null) 'modifier_id': modifierId,
      if (modifierName != null) 'modifier_name': modifierName,
      if (priceAdjustment != null) 'price_adjustment': priceAdjustment,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OrderItemModifiersCompanion copyWith({
    Value<String>? itemModifierId,
    Value<String>? orderItemId,
    Value<String>? modifierId,
    Value<String>? modifierName,
    Value<double>? priceAdjustment,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return OrderItemModifiersCompanion(
      itemModifierId: itemModifierId ?? this.itemModifierId,
      orderItemId: orderItemId ?? this.orderItemId,
      modifierId: modifierId ?? this.modifierId,
      modifierName: modifierName ?? this.modifierName,
      priceAdjustment: priceAdjustment ?? this.priceAdjustment,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (itemModifierId.present) {
      map['item_modifier_id'] = Variable<String>(itemModifierId.value);
    }
    if (orderItemId.present) {
      map['order_item_id'] = Variable<String>(orderItemId.value);
    }
    if (modifierId.present) {
      map['modifier_id'] = Variable<String>(modifierId.value);
    }
    if (modifierName.present) {
      map['modifier_name'] = Variable<String>(modifierName.value);
    }
    if (priceAdjustment.present) {
      map['price_adjustment'] = Variable<double>(priceAdjustment.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrderItemModifiersCompanion(')
          ..write('itemModifierId: $itemModifierId, ')
          ..write('orderItemId: $orderItemId, ')
          ..write('modifierId: $modifierId, ')
          ..write('modifierName: $modifierName, ')
          ..write('priceAdjustment: $priceAdjustment, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PurchaseOrdersTable extends PurchaseOrders
    with TableInfo<$PurchaseOrdersTable, PurchaseOrder> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PurchaseOrdersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _poIdMeta = const VerificationMeta('poId');
  @override
  late final GeneratedColumn<String> poId = GeneratedColumn<String>(
    'po_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _poNoMeta = const VerificationMeta('poNo');
  @override
  late final GeneratedColumn<String> poNo = GeneratedColumn<String>(
    'po_no',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _poDateMeta = const VerificationMeta('poDate');
  @override
  late final GeneratedColumn<DateTime> poDate = GeneratedColumn<DateTime>(
    'po_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _poTypeMeta = const VerificationMeta('poType');
  @override
  late final GeneratedColumn<String> poType = GeneratedColumn<String>(
    'po_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('PO'),
  );
  static const VerificationMeta _supplierIdMeta = const VerificationMeta(
    'supplierId',
  );
  @override
  late final GeneratedColumn<String> supplierId = GeneratedColumn<String>(
    'supplier_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES suppliers (supplier_id)',
    ),
  );
  static const VerificationMeta _supplierNameMeta = const VerificationMeta(
    'supplierName',
  );
  @override
  late final GeneratedColumn<String> supplierName = GeneratedColumn<String>(
    'supplier_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 300),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES branches (branch_id)',
    ),
  );
  static const VerificationMeta _warehouseIdMeta = const VerificationMeta(
    'warehouseId',
  );
  @override
  late final GeneratedColumn<String> warehouseId = GeneratedColumn<String>(
    'warehouse_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES warehouses (warehouse_id)',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (user_id)',
    ),
  );
  static const VerificationMeta _subtotalMeta = const VerificationMeta(
    'subtotal',
  );
  @override
  late final GeneratedColumn<double> subtotal = GeneratedColumn<double>(
    'subtotal',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _discountAmountMeta = const VerificationMeta(
    'discountAmount',
  );
  @override
  late final GeneratedColumn<double> discountAmount = GeneratedColumn<double>(
    'discount_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _amountBeforeVatMeta = const VerificationMeta(
    'amountBeforeVat',
  );
  @override
  late final GeneratedColumn<double> amountBeforeVat = GeneratedColumn<double>(
    'amount_before_vat',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _vatAmountMeta = const VerificationMeta(
    'vatAmount',
  );
  @override
  late final GeneratedColumn<double> vatAmount = GeneratedColumn<double>(
    'vat_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _totalAmountMeta = const VerificationMeta(
    'totalAmount',
  );
  @override
  late final GeneratedColumn<double> totalAmount = GeneratedColumn<double>(
    'total_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('OPEN'),
  );
  static const VerificationMeta _remarkMeta = const VerificationMeta('remark');
  @override
  late final GeneratedColumn<String> remark = GeneratedColumn<String>(
    'remark',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    poId,
    poNo,
    poDate,
    poType,
    supplierId,
    supplierName,
    branchId,
    warehouseId,
    userId,
    subtotal,
    discountAmount,
    amountBeforeVat,
    vatAmount,
    totalAmount,
    status,
    remark,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'purchase_orders';
  @override
  VerificationContext validateIntegrity(
    Insertable<PurchaseOrder> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('po_id')) {
      context.handle(
        _poIdMeta,
        poId.isAcceptableOrUnknown(data['po_id']!, _poIdMeta),
      );
    } else if (isInserting) {
      context.missing(_poIdMeta);
    }
    if (data.containsKey('po_no')) {
      context.handle(
        _poNoMeta,
        poNo.isAcceptableOrUnknown(data['po_no']!, _poNoMeta),
      );
    } else if (isInserting) {
      context.missing(_poNoMeta);
    }
    if (data.containsKey('po_date')) {
      context.handle(
        _poDateMeta,
        poDate.isAcceptableOrUnknown(data['po_date']!, _poDateMeta),
      );
    } else if (isInserting) {
      context.missing(_poDateMeta);
    }
    if (data.containsKey('po_type')) {
      context.handle(
        _poTypeMeta,
        poType.isAcceptableOrUnknown(data['po_type']!, _poTypeMeta),
      );
    }
    if (data.containsKey('supplier_id')) {
      context.handle(
        _supplierIdMeta,
        supplierId.isAcceptableOrUnknown(data['supplier_id']!, _supplierIdMeta),
      );
    } else if (isInserting) {
      context.missing(_supplierIdMeta);
    }
    if (data.containsKey('supplier_name')) {
      context.handle(
        _supplierNameMeta,
        supplierName.isAcceptableOrUnknown(
          data['supplier_name']!,
          _supplierNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_supplierNameMeta);
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    } else if (isInserting) {
      context.missing(_branchIdMeta);
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
        _warehouseIdMeta,
        warehouseId.isAcceptableOrUnknown(
          data['warehouse_id']!,
          _warehouseIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('subtotal')) {
      context.handle(
        _subtotalMeta,
        subtotal.isAcceptableOrUnknown(data['subtotal']!, _subtotalMeta),
      );
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
        _discountAmountMeta,
        discountAmount.isAcceptableOrUnknown(
          data['discount_amount']!,
          _discountAmountMeta,
        ),
      );
    }
    if (data.containsKey('amount_before_vat')) {
      context.handle(
        _amountBeforeVatMeta,
        amountBeforeVat.isAcceptableOrUnknown(
          data['amount_before_vat']!,
          _amountBeforeVatMeta,
        ),
      );
    }
    if (data.containsKey('vat_amount')) {
      context.handle(
        _vatAmountMeta,
        vatAmount.isAcceptableOrUnknown(data['vat_amount']!, _vatAmountMeta),
      );
    }
    if (data.containsKey('total_amount')) {
      context.handle(
        _totalAmountMeta,
        totalAmount.isAcceptableOrUnknown(
          data['total_amount']!,
          _totalAmountMeta,
        ),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('remark')) {
      context.handle(
        _remarkMeta,
        remark.isAcceptableOrUnknown(data['remark']!, _remarkMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {poId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {poNo},
  ];
  @override
  PurchaseOrder map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PurchaseOrder(
      poId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}po_id'],
      )!,
      poNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}po_no'],
      )!,
      poDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}po_date'],
      )!,
      poType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}po_type'],
      )!,
      supplierId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}supplier_id'],
      )!,
      supplierName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}supplier_name'],
      )!,
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      )!,
      warehouseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}warehouse_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      subtotal: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}subtotal'],
      )!,
      discountAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}discount_amount'],
      )!,
      amountBeforeVat: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}amount_before_vat'],
      )!,
      vatAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}vat_amount'],
      )!,
      totalAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_amount'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      remark: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}remark'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $PurchaseOrdersTable createAlias(String alias) {
    return $PurchaseOrdersTable(attachedDatabase, alias);
  }
}

class PurchaseOrder extends DataClass implements Insertable<PurchaseOrder> {
  final String poId;
  final String poNo;
  final DateTime poDate;
  final String poType;
  final String supplierId;
  final String supplierName;
  final String branchId;
  final String warehouseId;
  final String userId;
  final double subtotal;
  final double discountAmount;
  final double amountBeforeVat;
  final double vatAmount;
  final double totalAmount;
  final String status;
  final String? remark;
  final DateTime createdAt;
  final DateTime updatedAt;
  const PurchaseOrder({
    required this.poId,
    required this.poNo,
    required this.poDate,
    required this.poType,
    required this.supplierId,
    required this.supplierName,
    required this.branchId,
    required this.warehouseId,
    required this.userId,
    required this.subtotal,
    required this.discountAmount,
    required this.amountBeforeVat,
    required this.vatAmount,
    required this.totalAmount,
    required this.status,
    this.remark,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['po_id'] = Variable<String>(poId);
    map['po_no'] = Variable<String>(poNo);
    map['po_date'] = Variable<DateTime>(poDate);
    map['po_type'] = Variable<String>(poType);
    map['supplier_id'] = Variable<String>(supplierId);
    map['supplier_name'] = Variable<String>(supplierName);
    map['branch_id'] = Variable<String>(branchId);
    map['warehouse_id'] = Variable<String>(warehouseId);
    map['user_id'] = Variable<String>(userId);
    map['subtotal'] = Variable<double>(subtotal);
    map['discount_amount'] = Variable<double>(discountAmount);
    map['amount_before_vat'] = Variable<double>(amountBeforeVat);
    map['vat_amount'] = Variable<double>(vatAmount);
    map['total_amount'] = Variable<double>(totalAmount);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || remark != null) {
      map['remark'] = Variable<String>(remark);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  PurchaseOrdersCompanion toCompanion(bool nullToAbsent) {
    return PurchaseOrdersCompanion(
      poId: Value(poId),
      poNo: Value(poNo),
      poDate: Value(poDate),
      poType: Value(poType),
      supplierId: Value(supplierId),
      supplierName: Value(supplierName),
      branchId: Value(branchId),
      warehouseId: Value(warehouseId),
      userId: Value(userId),
      subtotal: Value(subtotal),
      discountAmount: Value(discountAmount),
      amountBeforeVat: Value(amountBeforeVat),
      vatAmount: Value(vatAmount),
      totalAmount: Value(totalAmount),
      status: Value(status),
      remark: remark == null && nullToAbsent
          ? const Value.absent()
          : Value(remark),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory PurchaseOrder.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PurchaseOrder(
      poId: serializer.fromJson<String>(json['poId']),
      poNo: serializer.fromJson<String>(json['poNo']),
      poDate: serializer.fromJson<DateTime>(json['poDate']),
      poType: serializer.fromJson<String>(json['poType']),
      supplierId: serializer.fromJson<String>(json['supplierId']),
      supplierName: serializer.fromJson<String>(json['supplierName']),
      branchId: serializer.fromJson<String>(json['branchId']),
      warehouseId: serializer.fromJson<String>(json['warehouseId']),
      userId: serializer.fromJson<String>(json['userId']),
      subtotal: serializer.fromJson<double>(json['subtotal']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      amountBeforeVat: serializer.fromJson<double>(json['amountBeforeVat']),
      vatAmount: serializer.fromJson<double>(json['vatAmount']),
      totalAmount: serializer.fromJson<double>(json['totalAmount']),
      status: serializer.fromJson<String>(json['status']),
      remark: serializer.fromJson<String?>(json['remark']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'poId': serializer.toJson<String>(poId),
      'poNo': serializer.toJson<String>(poNo),
      'poDate': serializer.toJson<DateTime>(poDate),
      'poType': serializer.toJson<String>(poType),
      'supplierId': serializer.toJson<String>(supplierId),
      'supplierName': serializer.toJson<String>(supplierName),
      'branchId': serializer.toJson<String>(branchId),
      'warehouseId': serializer.toJson<String>(warehouseId),
      'userId': serializer.toJson<String>(userId),
      'subtotal': serializer.toJson<double>(subtotal),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'amountBeforeVat': serializer.toJson<double>(amountBeforeVat),
      'vatAmount': serializer.toJson<double>(vatAmount),
      'totalAmount': serializer.toJson<double>(totalAmount),
      'status': serializer.toJson<String>(status),
      'remark': serializer.toJson<String?>(remark),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  PurchaseOrder copyWith({
    String? poId,
    String? poNo,
    DateTime? poDate,
    String? poType,
    String? supplierId,
    String? supplierName,
    String? branchId,
    String? warehouseId,
    String? userId,
    double? subtotal,
    double? discountAmount,
    double? amountBeforeVat,
    double? vatAmount,
    double? totalAmount,
    String? status,
    Value<String?> remark = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => PurchaseOrder(
    poId: poId ?? this.poId,
    poNo: poNo ?? this.poNo,
    poDate: poDate ?? this.poDate,
    poType: poType ?? this.poType,
    supplierId: supplierId ?? this.supplierId,
    supplierName: supplierName ?? this.supplierName,
    branchId: branchId ?? this.branchId,
    warehouseId: warehouseId ?? this.warehouseId,
    userId: userId ?? this.userId,
    subtotal: subtotal ?? this.subtotal,
    discountAmount: discountAmount ?? this.discountAmount,
    amountBeforeVat: amountBeforeVat ?? this.amountBeforeVat,
    vatAmount: vatAmount ?? this.vatAmount,
    totalAmount: totalAmount ?? this.totalAmount,
    status: status ?? this.status,
    remark: remark.present ? remark.value : this.remark,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  PurchaseOrder copyWithCompanion(PurchaseOrdersCompanion data) {
    return PurchaseOrder(
      poId: data.poId.present ? data.poId.value : this.poId,
      poNo: data.poNo.present ? data.poNo.value : this.poNo,
      poDate: data.poDate.present ? data.poDate.value : this.poDate,
      poType: data.poType.present ? data.poType.value : this.poType,
      supplierId: data.supplierId.present
          ? data.supplierId.value
          : this.supplierId,
      supplierName: data.supplierName.present
          ? data.supplierName.value
          : this.supplierName,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      warehouseId: data.warehouseId.present
          ? data.warehouseId.value
          : this.warehouseId,
      userId: data.userId.present ? data.userId.value : this.userId,
      subtotal: data.subtotal.present ? data.subtotal.value : this.subtotal,
      discountAmount: data.discountAmount.present
          ? data.discountAmount.value
          : this.discountAmount,
      amountBeforeVat: data.amountBeforeVat.present
          ? data.amountBeforeVat.value
          : this.amountBeforeVat,
      vatAmount: data.vatAmount.present ? data.vatAmount.value : this.vatAmount,
      totalAmount: data.totalAmount.present
          ? data.totalAmount.value
          : this.totalAmount,
      status: data.status.present ? data.status.value : this.status,
      remark: data.remark.present ? data.remark.value : this.remark,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrder(')
          ..write('poId: $poId, ')
          ..write('poNo: $poNo, ')
          ..write('poDate: $poDate, ')
          ..write('poType: $poType, ')
          ..write('supplierId: $supplierId, ')
          ..write('supplierName: $supplierName, ')
          ..write('branchId: $branchId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('userId: $userId, ')
          ..write('subtotal: $subtotal, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('amountBeforeVat: $amountBeforeVat, ')
          ..write('vatAmount: $vatAmount, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('status: $status, ')
          ..write('remark: $remark, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    poId,
    poNo,
    poDate,
    poType,
    supplierId,
    supplierName,
    branchId,
    warehouseId,
    userId,
    subtotal,
    discountAmount,
    amountBeforeVat,
    vatAmount,
    totalAmount,
    status,
    remark,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PurchaseOrder &&
          other.poId == this.poId &&
          other.poNo == this.poNo &&
          other.poDate == this.poDate &&
          other.poType == this.poType &&
          other.supplierId == this.supplierId &&
          other.supplierName == this.supplierName &&
          other.branchId == this.branchId &&
          other.warehouseId == this.warehouseId &&
          other.userId == this.userId &&
          other.subtotal == this.subtotal &&
          other.discountAmount == this.discountAmount &&
          other.amountBeforeVat == this.amountBeforeVat &&
          other.vatAmount == this.vatAmount &&
          other.totalAmount == this.totalAmount &&
          other.status == this.status &&
          other.remark == this.remark &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class PurchaseOrdersCompanion extends UpdateCompanion<PurchaseOrder> {
  final Value<String> poId;
  final Value<String> poNo;
  final Value<DateTime> poDate;
  final Value<String> poType;
  final Value<String> supplierId;
  final Value<String> supplierName;
  final Value<String> branchId;
  final Value<String> warehouseId;
  final Value<String> userId;
  final Value<double> subtotal;
  final Value<double> discountAmount;
  final Value<double> amountBeforeVat;
  final Value<double> vatAmount;
  final Value<double> totalAmount;
  final Value<String> status;
  final Value<String?> remark;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const PurchaseOrdersCompanion({
    this.poId = const Value.absent(),
    this.poNo = const Value.absent(),
    this.poDate = const Value.absent(),
    this.poType = const Value.absent(),
    this.supplierId = const Value.absent(),
    this.supplierName = const Value.absent(),
    this.branchId = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.userId = const Value.absent(),
    this.subtotal = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.amountBeforeVat = const Value.absent(),
    this.vatAmount = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.status = const Value.absent(),
    this.remark = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PurchaseOrdersCompanion.insert({
    required String poId,
    required String poNo,
    required DateTime poDate,
    this.poType = const Value.absent(),
    required String supplierId,
    required String supplierName,
    required String branchId,
    required String warehouseId,
    required String userId,
    this.subtotal = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.amountBeforeVat = const Value.absent(),
    this.vatAmount = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.status = const Value.absent(),
    this.remark = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : poId = Value(poId),
       poNo = Value(poNo),
       poDate = Value(poDate),
       supplierId = Value(supplierId),
       supplierName = Value(supplierName),
       branchId = Value(branchId),
       warehouseId = Value(warehouseId),
       userId = Value(userId);
  static Insertable<PurchaseOrder> custom({
    Expression<String>? poId,
    Expression<String>? poNo,
    Expression<DateTime>? poDate,
    Expression<String>? poType,
    Expression<String>? supplierId,
    Expression<String>? supplierName,
    Expression<String>? branchId,
    Expression<String>? warehouseId,
    Expression<String>? userId,
    Expression<double>? subtotal,
    Expression<double>? discountAmount,
    Expression<double>? amountBeforeVat,
    Expression<double>? vatAmount,
    Expression<double>? totalAmount,
    Expression<String>? status,
    Expression<String>? remark,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (poId != null) 'po_id': poId,
      if (poNo != null) 'po_no': poNo,
      if (poDate != null) 'po_date': poDate,
      if (poType != null) 'po_type': poType,
      if (supplierId != null) 'supplier_id': supplierId,
      if (supplierName != null) 'supplier_name': supplierName,
      if (branchId != null) 'branch_id': branchId,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (userId != null) 'user_id': userId,
      if (subtotal != null) 'subtotal': subtotal,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (amountBeforeVat != null) 'amount_before_vat': amountBeforeVat,
      if (vatAmount != null) 'vat_amount': vatAmount,
      if (totalAmount != null) 'total_amount': totalAmount,
      if (status != null) 'status': status,
      if (remark != null) 'remark': remark,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PurchaseOrdersCompanion copyWith({
    Value<String>? poId,
    Value<String>? poNo,
    Value<DateTime>? poDate,
    Value<String>? poType,
    Value<String>? supplierId,
    Value<String>? supplierName,
    Value<String>? branchId,
    Value<String>? warehouseId,
    Value<String>? userId,
    Value<double>? subtotal,
    Value<double>? discountAmount,
    Value<double>? amountBeforeVat,
    Value<double>? vatAmount,
    Value<double>? totalAmount,
    Value<String>? status,
    Value<String?>? remark,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return PurchaseOrdersCompanion(
      poId: poId ?? this.poId,
      poNo: poNo ?? this.poNo,
      poDate: poDate ?? this.poDate,
      poType: poType ?? this.poType,
      supplierId: supplierId ?? this.supplierId,
      supplierName: supplierName ?? this.supplierName,
      branchId: branchId ?? this.branchId,
      warehouseId: warehouseId ?? this.warehouseId,
      userId: userId ?? this.userId,
      subtotal: subtotal ?? this.subtotal,
      discountAmount: discountAmount ?? this.discountAmount,
      amountBeforeVat: amountBeforeVat ?? this.amountBeforeVat,
      vatAmount: vatAmount ?? this.vatAmount,
      totalAmount: totalAmount ?? this.totalAmount,
      status: status ?? this.status,
      remark: remark ?? this.remark,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (poId.present) {
      map['po_id'] = Variable<String>(poId.value);
    }
    if (poNo.present) {
      map['po_no'] = Variable<String>(poNo.value);
    }
    if (poDate.present) {
      map['po_date'] = Variable<DateTime>(poDate.value);
    }
    if (poType.present) {
      map['po_type'] = Variable<String>(poType.value);
    }
    if (supplierId.present) {
      map['supplier_id'] = Variable<String>(supplierId.value);
    }
    if (supplierName.present) {
      map['supplier_name'] = Variable<String>(supplierName.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<String>(warehouseId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (subtotal.present) {
      map['subtotal'] = Variable<double>(subtotal.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (amountBeforeVat.present) {
      map['amount_before_vat'] = Variable<double>(amountBeforeVat.value);
    }
    if (vatAmount.present) {
      map['vat_amount'] = Variable<double>(vatAmount.value);
    }
    if (totalAmount.present) {
      map['total_amount'] = Variable<double>(totalAmount.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (remark.present) {
      map['remark'] = Variable<String>(remark.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrdersCompanion(')
          ..write('poId: $poId, ')
          ..write('poNo: $poNo, ')
          ..write('poDate: $poDate, ')
          ..write('poType: $poType, ')
          ..write('supplierId: $supplierId, ')
          ..write('supplierName: $supplierName, ')
          ..write('branchId: $branchId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('userId: $userId, ')
          ..write('subtotal: $subtotal, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('amountBeforeVat: $amountBeforeVat, ')
          ..write('vatAmount: $vatAmount, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('status: $status, ')
          ..write('remark: $remark, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PurchaseOrderItemsTable extends PurchaseOrderItems
    with TableInfo<$PurchaseOrderItemsTable, PurchaseOrderItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PurchaseOrderItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
    'item_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _poIdMeta = const VerificationMeta('poId');
  @override
  late final GeneratedColumn<String> poId = GeneratedColumn<String>(
    'po_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES purchase_orders (po_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _lineNoMeta = const VerificationMeta('lineNo');
  @override
  late final GeneratedColumn<int> lineNo = GeneratedColumn<int>(
    'line_no',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES products (product_id)',
    ),
  );
  static const VerificationMeta _productCodeMeta = const VerificationMeta(
    'productCode',
  );
  @override
  late final GeneratedColumn<String> productCode = GeneratedColumn<String>(
    'product_code',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productNameMeta = const VerificationMeta(
    'productName',
  );
  @override
  late final GeneratedColumn<String> productName = GeneratedColumn<String>(
    'product_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 500),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _unitMeta = const VerificationMeta('unit');
  @override
  late final GeneratedColumn<String> unit = GeneratedColumn<String>(
    'unit',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _unitPriceMeta = const VerificationMeta(
    'unitPrice',
  );
  @override
  late final GeneratedColumn<double> unitPrice = GeneratedColumn<double>(
    'unit_price',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _discountPercentMeta = const VerificationMeta(
    'discountPercent',
  );
  @override
  late final GeneratedColumn<double> discountPercent = GeneratedColumn<double>(
    'discount_percent',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _discountAmountMeta = const VerificationMeta(
    'discountAmount',
  );
  @override
  late final GeneratedColumn<double> discountAmount = GeneratedColumn<double>(
    'discount_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
    'amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _receivedQtyMeta = const VerificationMeta(
    'receivedQty',
  );
  @override
  late final GeneratedColumn<double> receivedQty = GeneratedColumn<double>(
    'received_qty',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    itemId,
    poId,
    lineNo,
    productId,
    productCode,
    productName,
    unit,
    quantity,
    unitPrice,
    discountPercent,
    discountAmount,
    amount,
    receivedQty,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'purchase_order_items';
  @override
  VerificationContext validateIntegrity(
    Insertable<PurchaseOrderItem> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('item_id')) {
      context.handle(
        _itemIdMeta,
        itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta),
      );
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('po_id')) {
      context.handle(
        _poIdMeta,
        poId.isAcceptableOrUnknown(data['po_id']!, _poIdMeta),
      );
    } else if (isInserting) {
      context.missing(_poIdMeta);
    }
    if (data.containsKey('line_no')) {
      context.handle(
        _lineNoMeta,
        lineNo.isAcceptableOrUnknown(data['line_no']!, _lineNoMeta),
      );
    } else if (isInserting) {
      context.missing(_lineNoMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('product_code')) {
      context.handle(
        _productCodeMeta,
        productCode.isAcceptableOrUnknown(
          data['product_code']!,
          _productCodeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_productCodeMeta);
    }
    if (data.containsKey('product_name')) {
      context.handle(
        _productNameMeta,
        productName.isAcceptableOrUnknown(
          data['product_name']!,
          _productNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_productNameMeta);
    }
    if (data.containsKey('unit')) {
      context.handle(
        _unitMeta,
        unit.isAcceptableOrUnknown(data['unit']!, _unitMeta),
      );
    } else if (isInserting) {
      context.missing(_unitMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('unit_price')) {
      context.handle(
        _unitPriceMeta,
        unitPrice.isAcceptableOrUnknown(data['unit_price']!, _unitPriceMeta),
      );
    } else if (isInserting) {
      context.missing(_unitPriceMeta);
    }
    if (data.containsKey('discount_percent')) {
      context.handle(
        _discountPercentMeta,
        discountPercent.isAcceptableOrUnknown(
          data['discount_percent']!,
          _discountPercentMeta,
        ),
      );
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
        _discountAmountMeta,
        discountAmount.isAcceptableOrUnknown(
          data['discount_amount']!,
          _discountAmountMeta,
        ),
      );
    }
    if (data.containsKey('amount')) {
      context.handle(
        _amountMeta,
        amount.isAcceptableOrUnknown(data['amount']!, _amountMeta),
      );
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('received_qty')) {
      context.handle(
        _receivedQtyMeta,
        receivedQty.isAcceptableOrUnknown(
          data['received_qty']!,
          _receivedQtyMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {itemId};
  @override
  PurchaseOrderItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PurchaseOrderItem(
      itemId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}item_id'],
      )!,
      poId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}po_id'],
      )!,
      lineNo: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}line_no'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_id'],
      )!,
      productCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_code'],
      )!,
      productName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_name'],
      )!,
      unit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}unit'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}quantity'],
      )!,
      unitPrice: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}unit_price'],
      )!,
      discountPercent: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}discount_percent'],
      )!,
      discountAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}discount_amount'],
      )!,
      amount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}amount'],
      )!,
      receivedQty: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}received_qty'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $PurchaseOrderItemsTable createAlias(String alias) {
    return $PurchaseOrderItemsTable(attachedDatabase, alias);
  }
}

class PurchaseOrderItem extends DataClass
    implements Insertable<PurchaseOrderItem> {
  final String itemId;
  final String poId;
  final int lineNo;
  final String productId;
  final String productCode;
  final String productName;
  final String unit;
  final double quantity;
  final double unitPrice;
  final double discountPercent;
  final double discountAmount;
  final double amount;
  final double receivedQty;
  final DateTime createdAt;
  const PurchaseOrderItem({
    required this.itemId,
    required this.poId,
    required this.lineNo,
    required this.productId,
    required this.productCode,
    required this.productName,
    required this.unit,
    required this.quantity,
    required this.unitPrice,
    required this.discountPercent,
    required this.discountAmount,
    required this.amount,
    required this.receivedQty,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['item_id'] = Variable<String>(itemId);
    map['po_id'] = Variable<String>(poId);
    map['line_no'] = Variable<int>(lineNo);
    map['product_id'] = Variable<String>(productId);
    map['product_code'] = Variable<String>(productCode);
    map['product_name'] = Variable<String>(productName);
    map['unit'] = Variable<String>(unit);
    map['quantity'] = Variable<double>(quantity);
    map['unit_price'] = Variable<double>(unitPrice);
    map['discount_percent'] = Variable<double>(discountPercent);
    map['discount_amount'] = Variable<double>(discountAmount);
    map['amount'] = Variable<double>(amount);
    map['received_qty'] = Variable<double>(receivedQty);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  PurchaseOrderItemsCompanion toCompanion(bool nullToAbsent) {
    return PurchaseOrderItemsCompanion(
      itemId: Value(itemId),
      poId: Value(poId),
      lineNo: Value(lineNo),
      productId: Value(productId),
      productCode: Value(productCode),
      productName: Value(productName),
      unit: Value(unit),
      quantity: Value(quantity),
      unitPrice: Value(unitPrice),
      discountPercent: Value(discountPercent),
      discountAmount: Value(discountAmount),
      amount: Value(amount),
      receivedQty: Value(receivedQty),
      createdAt: Value(createdAt),
    );
  }

  factory PurchaseOrderItem.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PurchaseOrderItem(
      itemId: serializer.fromJson<String>(json['itemId']),
      poId: serializer.fromJson<String>(json['poId']),
      lineNo: serializer.fromJson<int>(json['lineNo']),
      productId: serializer.fromJson<String>(json['productId']),
      productCode: serializer.fromJson<String>(json['productCode']),
      productName: serializer.fromJson<String>(json['productName']),
      unit: serializer.fromJson<String>(json['unit']),
      quantity: serializer.fromJson<double>(json['quantity']),
      unitPrice: serializer.fromJson<double>(json['unitPrice']),
      discountPercent: serializer.fromJson<double>(json['discountPercent']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      amount: serializer.fromJson<double>(json['amount']),
      receivedQty: serializer.fromJson<double>(json['receivedQty']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'itemId': serializer.toJson<String>(itemId),
      'poId': serializer.toJson<String>(poId),
      'lineNo': serializer.toJson<int>(lineNo),
      'productId': serializer.toJson<String>(productId),
      'productCode': serializer.toJson<String>(productCode),
      'productName': serializer.toJson<String>(productName),
      'unit': serializer.toJson<String>(unit),
      'quantity': serializer.toJson<double>(quantity),
      'unitPrice': serializer.toJson<double>(unitPrice),
      'discountPercent': serializer.toJson<double>(discountPercent),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'amount': serializer.toJson<double>(amount),
      'receivedQty': serializer.toJson<double>(receivedQty),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  PurchaseOrderItem copyWith({
    String? itemId,
    String? poId,
    int? lineNo,
    String? productId,
    String? productCode,
    String? productName,
    String? unit,
    double? quantity,
    double? unitPrice,
    double? discountPercent,
    double? discountAmount,
    double? amount,
    double? receivedQty,
    DateTime? createdAt,
  }) => PurchaseOrderItem(
    itemId: itemId ?? this.itemId,
    poId: poId ?? this.poId,
    lineNo: lineNo ?? this.lineNo,
    productId: productId ?? this.productId,
    productCode: productCode ?? this.productCode,
    productName: productName ?? this.productName,
    unit: unit ?? this.unit,
    quantity: quantity ?? this.quantity,
    unitPrice: unitPrice ?? this.unitPrice,
    discountPercent: discountPercent ?? this.discountPercent,
    discountAmount: discountAmount ?? this.discountAmount,
    amount: amount ?? this.amount,
    receivedQty: receivedQty ?? this.receivedQty,
    createdAt: createdAt ?? this.createdAt,
  );
  PurchaseOrderItem copyWithCompanion(PurchaseOrderItemsCompanion data) {
    return PurchaseOrderItem(
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      poId: data.poId.present ? data.poId.value : this.poId,
      lineNo: data.lineNo.present ? data.lineNo.value : this.lineNo,
      productId: data.productId.present ? data.productId.value : this.productId,
      productCode: data.productCode.present
          ? data.productCode.value
          : this.productCode,
      productName: data.productName.present
          ? data.productName.value
          : this.productName,
      unit: data.unit.present ? data.unit.value : this.unit,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      unitPrice: data.unitPrice.present ? data.unitPrice.value : this.unitPrice,
      discountPercent: data.discountPercent.present
          ? data.discountPercent.value
          : this.discountPercent,
      discountAmount: data.discountAmount.present
          ? data.discountAmount.value
          : this.discountAmount,
      amount: data.amount.present ? data.amount.value : this.amount,
      receivedQty: data.receivedQty.present
          ? data.receivedQty.value
          : this.receivedQty,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrderItem(')
          ..write('itemId: $itemId, ')
          ..write('poId: $poId, ')
          ..write('lineNo: $lineNo, ')
          ..write('productId: $productId, ')
          ..write('productCode: $productCode, ')
          ..write('productName: $productName, ')
          ..write('unit: $unit, ')
          ..write('quantity: $quantity, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('discountPercent: $discountPercent, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('amount: $amount, ')
          ..write('receivedQty: $receivedQty, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    itemId,
    poId,
    lineNo,
    productId,
    productCode,
    productName,
    unit,
    quantity,
    unitPrice,
    discountPercent,
    discountAmount,
    amount,
    receivedQty,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PurchaseOrderItem &&
          other.itemId == this.itemId &&
          other.poId == this.poId &&
          other.lineNo == this.lineNo &&
          other.productId == this.productId &&
          other.productCode == this.productCode &&
          other.productName == this.productName &&
          other.unit == this.unit &&
          other.quantity == this.quantity &&
          other.unitPrice == this.unitPrice &&
          other.discountPercent == this.discountPercent &&
          other.discountAmount == this.discountAmount &&
          other.amount == this.amount &&
          other.receivedQty == this.receivedQty &&
          other.createdAt == this.createdAt);
}

class PurchaseOrderItemsCompanion extends UpdateCompanion<PurchaseOrderItem> {
  final Value<String> itemId;
  final Value<String> poId;
  final Value<int> lineNo;
  final Value<String> productId;
  final Value<String> productCode;
  final Value<String> productName;
  final Value<String> unit;
  final Value<double> quantity;
  final Value<double> unitPrice;
  final Value<double> discountPercent;
  final Value<double> discountAmount;
  final Value<double> amount;
  final Value<double> receivedQty;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const PurchaseOrderItemsCompanion({
    this.itemId = const Value.absent(),
    this.poId = const Value.absent(),
    this.lineNo = const Value.absent(),
    this.productId = const Value.absent(),
    this.productCode = const Value.absent(),
    this.productName = const Value.absent(),
    this.unit = const Value.absent(),
    this.quantity = const Value.absent(),
    this.unitPrice = const Value.absent(),
    this.discountPercent = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.amount = const Value.absent(),
    this.receivedQty = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PurchaseOrderItemsCompanion.insert({
    required String itemId,
    required String poId,
    required int lineNo,
    required String productId,
    required String productCode,
    required String productName,
    required String unit,
    required double quantity,
    required double unitPrice,
    this.discountPercent = const Value.absent(),
    this.discountAmount = const Value.absent(),
    required double amount,
    this.receivedQty = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : itemId = Value(itemId),
       poId = Value(poId),
       lineNo = Value(lineNo),
       productId = Value(productId),
       productCode = Value(productCode),
       productName = Value(productName),
       unit = Value(unit),
       quantity = Value(quantity),
       unitPrice = Value(unitPrice),
       amount = Value(amount);
  static Insertable<PurchaseOrderItem> custom({
    Expression<String>? itemId,
    Expression<String>? poId,
    Expression<int>? lineNo,
    Expression<String>? productId,
    Expression<String>? productCode,
    Expression<String>? productName,
    Expression<String>? unit,
    Expression<double>? quantity,
    Expression<double>? unitPrice,
    Expression<double>? discountPercent,
    Expression<double>? discountAmount,
    Expression<double>? amount,
    Expression<double>? receivedQty,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (itemId != null) 'item_id': itemId,
      if (poId != null) 'po_id': poId,
      if (lineNo != null) 'line_no': lineNo,
      if (productId != null) 'product_id': productId,
      if (productCode != null) 'product_code': productCode,
      if (productName != null) 'product_name': productName,
      if (unit != null) 'unit': unit,
      if (quantity != null) 'quantity': quantity,
      if (unitPrice != null) 'unit_price': unitPrice,
      if (discountPercent != null) 'discount_percent': discountPercent,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (amount != null) 'amount': amount,
      if (receivedQty != null) 'received_qty': receivedQty,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PurchaseOrderItemsCompanion copyWith({
    Value<String>? itemId,
    Value<String>? poId,
    Value<int>? lineNo,
    Value<String>? productId,
    Value<String>? productCode,
    Value<String>? productName,
    Value<String>? unit,
    Value<double>? quantity,
    Value<double>? unitPrice,
    Value<double>? discountPercent,
    Value<double>? discountAmount,
    Value<double>? amount,
    Value<double>? receivedQty,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return PurchaseOrderItemsCompanion(
      itemId: itemId ?? this.itemId,
      poId: poId ?? this.poId,
      lineNo: lineNo ?? this.lineNo,
      productId: productId ?? this.productId,
      productCode: productCode ?? this.productCode,
      productName: productName ?? this.productName,
      unit: unit ?? this.unit,
      quantity: quantity ?? this.quantity,
      unitPrice: unitPrice ?? this.unitPrice,
      discountPercent: discountPercent ?? this.discountPercent,
      discountAmount: discountAmount ?? this.discountAmount,
      amount: amount ?? this.amount,
      receivedQty: receivedQty ?? this.receivedQty,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (poId.present) {
      map['po_id'] = Variable<String>(poId.value);
    }
    if (lineNo.present) {
      map['line_no'] = Variable<int>(lineNo.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (productCode.present) {
      map['product_code'] = Variable<String>(productCode.value);
    }
    if (productName.present) {
      map['product_name'] = Variable<String>(productName.value);
    }
    if (unit.present) {
      map['unit'] = Variable<String>(unit.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (unitPrice.present) {
      map['unit_price'] = Variable<double>(unitPrice.value);
    }
    if (discountPercent.present) {
      map['discount_percent'] = Variable<double>(discountPercent.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (receivedQty.present) {
      map['received_qty'] = Variable<double>(receivedQty.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrderItemsCompanion(')
          ..write('itemId: $itemId, ')
          ..write('poId: $poId, ')
          ..write('lineNo: $lineNo, ')
          ..write('productId: $productId, ')
          ..write('productCode: $productCode, ')
          ..write('productName: $productName, ')
          ..write('unit: $unit, ')
          ..write('quantity: $quantity, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('discountPercent: $discountPercent, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('amount: $amount, ')
          ..write('receivedQty: $receivedQty, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StockMovementsTable extends StockMovements
    with TableInfo<$StockMovementsTable, StockMovement> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockMovementsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _movementIdMeta = const VerificationMeta(
    'movementId',
  );
  @override
  late final GeneratedColumn<String> movementId = GeneratedColumn<String>(
    'movement_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _movementNoMeta = const VerificationMeta(
    'movementNo',
  );
  @override
  late final GeneratedColumn<String> movementNo = GeneratedColumn<String>(
    'movement_no',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _movementDateMeta = const VerificationMeta(
    'movementDate',
  );
  @override
  late final GeneratedColumn<DateTime> movementDate = GeneratedColumn<DateTime>(
    'movement_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _movementTypeMeta = const VerificationMeta(
    'movementType',
  );
  @override
  late final GeneratedColumn<String> movementType = GeneratedColumn<String>(
    'movement_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES products (product_id)',
    ),
  );
  static const VerificationMeta _warehouseIdMeta = const VerificationMeta(
    'warehouseId',
  );
  @override
  late final GeneratedColumn<String> warehouseId = GeneratedColumn<String>(
    'warehouse_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES warehouses (warehouse_id)',
    ),
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _unitCostMeta = const VerificationMeta(
    'unitCost',
  );
  @override
  late final GeneratedColumn<double> unitCost = GeneratedColumn<double>(
    'unit_cost',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _referenceTypeMeta = const VerificationMeta(
    'referenceType',
  );
  @override
  late final GeneratedColumn<String> referenceType = GeneratedColumn<String>(
    'reference_type',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _referenceIdMeta = const VerificationMeta(
    'referenceId',
  );
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
    'reference_id',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (user_id)',
    ),
  );
  static const VerificationMeta _remarkMeta = const VerificationMeta('remark');
  @override
  late final GeneratedColumn<String> remark = GeneratedColumn<String>(
    'remark',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    movementId,
    movementNo,
    movementDate,
    movementType,
    productId,
    warehouseId,
    quantity,
    unitCost,
    referenceType,
    referenceId,
    userId,
    remark,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_movements';
  @override
  VerificationContext validateIntegrity(
    Insertable<StockMovement> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('movement_id')) {
      context.handle(
        _movementIdMeta,
        movementId.isAcceptableOrUnknown(data['movement_id']!, _movementIdMeta),
      );
    } else if (isInserting) {
      context.missing(_movementIdMeta);
    }
    if (data.containsKey('movement_no')) {
      context.handle(
        _movementNoMeta,
        movementNo.isAcceptableOrUnknown(data['movement_no']!, _movementNoMeta),
      );
    } else if (isInserting) {
      context.missing(_movementNoMeta);
    }
    if (data.containsKey('movement_date')) {
      context.handle(
        _movementDateMeta,
        movementDate.isAcceptableOrUnknown(
          data['movement_date']!,
          _movementDateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_movementDateMeta);
    }
    if (data.containsKey('movement_type')) {
      context.handle(
        _movementTypeMeta,
        movementType.isAcceptableOrUnknown(
          data['movement_type']!,
          _movementTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_movementTypeMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
        _warehouseIdMeta,
        warehouseId.isAcceptableOrUnknown(
          data['warehouse_id']!,
          _warehouseIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('unit_cost')) {
      context.handle(
        _unitCostMeta,
        unitCost.isAcceptableOrUnknown(data['unit_cost']!, _unitCostMeta),
      );
    }
    if (data.containsKey('reference_type')) {
      context.handle(
        _referenceTypeMeta,
        referenceType.isAcceptableOrUnknown(
          data['reference_type']!,
          _referenceTypeMeta,
        ),
      );
    }
    if (data.containsKey('reference_id')) {
      context.handle(
        _referenceIdMeta,
        referenceId.isAcceptableOrUnknown(
          data['reference_id']!,
          _referenceIdMeta,
        ),
      );
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('remark')) {
      context.handle(
        _remarkMeta,
        remark.isAcceptableOrUnknown(data['remark']!, _remarkMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {movementId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {movementNo},
  ];
  @override
  StockMovement map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockMovement(
      movementId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}movement_id'],
      )!,
      movementNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}movement_no'],
      )!,
      movementDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}movement_date'],
      )!,
      movementType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}movement_type'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_id'],
      )!,
      warehouseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}warehouse_id'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}quantity'],
      )!,
      unitCost: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}unit_cost'],
      )!,
      referenceType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reference_type'],
      ),
      referenceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reference_id'],
      ),
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      remark: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}remark'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $StockMovementsTable createAlias(String alias) {
    return $StockMovementsTable(attachedDatabase, alias);
  }
}

class StockMovement extends DataClass implements Insertable<StockMovement> {
  final String movementId;
  final String movementNo;
  final DateTime movementDate;
  final String movementType;
  final String productId;
  final String warehouseId;
  final double quantity;
  final double unitCost;
  final String? referenceType;
  final String? referenceId;
  final String userId;
  final String? remark;
  final DateTime createdAt;
  const StockMovement({
    required this.movementId,
    required this.movementNo,
    required this.movementDate,
    required this.movementType,
    required this.productId,
    required this.warehouseId,
    required this.quantity,
    required this.unitCost,
    this.referenceType,
    this.referenceId,
    required this.userId,
    this.remark,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['movement_id'] = Variable<String>(movementId);
    map['movement_no'] = Variable<String>(movementNo);
    map['movement_date'] = Variable<DateTime>(movementDate);
    map['movement_type'] = Variable<String>(movementType);
    map['product_id'] = Variable<String>(productId);
    map['warehouse_id'] = Variable<String>(warehouseId);
    map['quantity'] = Variable<double>(quantity);
    map['unit_cost'] = Variable<double>(unitCost);
    if (!nullToAbsent || referenceType != null) {
      map['reference_type'] = Variable<String>(referenceType);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || remark != null) {
      map['remark'] = Variable<String>(remark);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  StockMovementsCompanion toCompanion(bool nullToAbsent) {
    return StockMovementsCompanion(
      movementId: Value(movementId),
      movementNo: Value(movementNo),
      movementDate: Value(movementDate),
      movementType: Value(movementType),
      productId: Value(productId),
      warehouseId: Value(warehouseId),
      quantity: Value(quantity),
      unitCost: Value(unitCost),
      referenceType: referenceType == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceType),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      userId: Value(userId),
      remark: remark == null && nullToAbsent
          ? const Value.absent()
          : Value(remark),
      createdAt: Value(createdAt),
    );
  }

  factory StockMovement.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockMovement(
      movementId: serializer.fromJson<String>(json['movementId']),
      movementNo: serializer.fromJson<String>(json['movementNo']),
      movementDate: serializer.fromJson<DateTime>(json['movementDate']),
      movementType: serializer.fromJson<String>(json['movementType']),
      productId: serializer.fromJson<String>(json['productId']),
      warehouseId: serializer.fromJson<String>(json['warehouseId']),
      quantity: serializer.fromJson<double>(json['quantity']),
      unitCost: serializer.fromJson<double>(json['unitCost']),
      referenceType: serializer.fromJson<String?>(json['referenceType']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      userId: serializer.fromJson<String>(json['userId']),
      remark: serializer.fromJson<String?>(json['remark']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'movementId': serializer.toJson<String>(movementId),
      'movementNo': serializer.toJson<String>(movementNo),
      'movementDate': serializer.toJson<DateTime>(movementDate),
      'movementType': serializer.toJson<String>(movementType),
      'productId': serializer.toJson<String>(productId),
      'warehouseId': serializer.toJson<String>(warehouseId),
      'quantity': serializer.toJson<double>(quantity),
      'unitCost': serializer.toJson<double>(unitCost),
      'referenceType': serializer.toJson<String?>(referenceType),
      'referenceId': serializer.toJson<String?>(referenceId),
      'userId': serializer.toJson<String>(userId),
      'remark': serializer.toJson<String?>(remark),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  StockMovement copyWith({
    String? movementId,
    String? movementNo,
    DateTime? movementDate,
    String? movementType,
    String? productId,
    String? warehouseId,
    double? quantity,
    double? unitCost,
    Value<String?> referenceType = const Value.absent(),
    Value<String?> referenceId = const Value.absent(),
    String? userId,
    Value<String?> remark = const Value.absent(),
    DateTime? createdAt,
  }) => StockMovement(
    movementId: movementId ?? this.movementId,
    movementNo: movementNo ?? this.movementNo,
    movementDate: movementDate ?? this.movementDate,
    movementType: movementType ?? this.movementType,
    productId: productId ?? this.productId,
    warehouseId: warehouseId ?? this.warehouseId,
    quantity: quantity ?? this.quantity,
    unitCost: unitCost ?? this.unitCost,
    referenceType: referenceType.present
        ? referenceType.value
        : this.referenceType,
    referenceId: referenceId.present ? referenceId.value : this.referenceId,
    userId: userId ?? this.userId,
    remark: remark.present ? remark.value : this.remark,
    createdAt: createdAt ?? this.createdAt,
  );
  StockMovement copyWithCompanion(StockMovementsCompanion data) {
    return StockMovement(
      movementId: data.movementId.present
          ? data.movementId.value
          : this.movementId,
      movementNo: data.movementNo.present
          ? data.movementNo.value
          : this.movementNo,
      movementDate: data.movementDate.present
          ? data.movementDate.value
          : this.movementDate,
      movementType: data.movementType.present
          ? data.movementType.value
          : this.movementType,
      productId: data.productId.present ? data.productId.value : this.productId,
      warehouseId: data.warehouseId.present
          ? data.warehouseId.value
          : this.warehouseId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      unitCost: data.unitCost.present ? data.unitCost.value : this.unitCost,
      referenceType: data.referenceType.present
          ? data.referenceType.value
          : this.referenceType,
      referenceId: data.referenceId.present
          ? data.referenceId.value
          : this.referenceId,
      userId: data.userId.present ? data.userId.value : this.userId,
      remark: data.remark.present ? data.remark.value : this.remark,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockMovement(')
          ..write('movementId: $movementId, ')
          ..write('movementNo: $movementNo, ')
          ..write('movementDate: $movementDate, ')
          ..write('movementType: $movementType, ')
          ..write('productId: $productId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('quantity: $quantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('referenceType: $referenceType, ')
          ..write('referenceId: $referenceId, ')
          ..write('userId: $userId, ')
          ..write('remark: $remark, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    movementId,
    movementNo,
    movementDate,
    movementType,
    productId,
    warehouseId,
    quantity,
    unitCost,
    referenceType,
    referenceId,
    userId,
    remark,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockMovement &&
          other.movementId == this.movementId &&
          other.movementNo == this.movementNo &&
          other.movementDate == this.movementDate &&
          other.movementType == this.movementType &&
          other.productId == this.productId &&
          other.warehouseId == this.warehouseId &&
          other.quantity == this.quantity &&
          other.unitCost == this.unitCost &&
          other.referenceType == this.referenceType &&
          other.referenceId == this.referenceId &&
          other.userId == this.userId &&
          other.remark == this.remark &&
          other.createdAt == this.createdAt);
}

class StockMovementsCompanion extends UpdateCompanion<StockMovement> {
  final Value<String> movementId;
  final Value<String> movementNo;
  final Value<DateTime> movementDate;
  final Value<String> movementType;
  final Value<String> productId;
  final Value<String> warehouseId;
  final Value<double> quantity;
  final Value<double> unitCost;
  final Value<String?> referenceType;
  final Value<String?> referenceId;
  final Value<String> userId;
  final Value<String?> remark;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const StockMovementsCompanion({
    this.movementId = const Value.absent(),
    this.movementNo = const Value.absent(),
    this.movementDate = const Value.absent(),
    this.movementType = const Value.absent(),
    this.productId = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.unitCost = const Value.absent(),
    this.referenceType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.userId = const Value.absent(),
    this.remark = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StockMovementsCompanion.insert({
    required String movementId,
    required String movementNo,
    required DateTime movementDate,
    required String movementType,
    required String productId,
    required String warehouseId,
    required double quantity,
    this.unitCost = const Value.absent(),
    this.referenceType = const Value.absent(),
    this.referenceId = const Value.absent(),
    required String userId,
    this.remark = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : movementId = Value(movementId),
       movementNo = Value(movementNo),
       movementDate = Value(movementDate),
       movementType = Value(movementType),
       productId = Value(productId),
       warehouseId = Value(warehouseId),
       quantity = Value(quantity),
       userId = Value(userId);
  static Insertable<StockMovement> custom({
    Expression<String>? movementId,
    Expression<String>? movementNo,
    Expression<DateTime>? movementDate,
    Expression<String>? movementType,
    Expression<String>? productId,
    Expression<String>? warehouseId,
    Expression<double>? quantity,
    Expression<double>? unitCost,
    Expression<String>? referenceType,
    Expression<String>? referenceId,
    Expression<String>? userId,
    Expression<String>? remark,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (movementId != null) 'movement_id': movementId,
      if (movementNo != null) 'movement_no': movementNo,
      if (movementDate != null) 'movement_date': movementDate,
      if (movementType != null) 'movement_type': movementType,
      if (productId != null) 'product_id': productId,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (quantity != null) 'quantity': quantity,
      if (unitCost != null) 'unit_cost': unitCost,
      if (referenceType != null) 'reference_type': referenceType,
      if (referenceId != null) 'reference_id': referenceId,
      if (userId != null) 'user_id': userId,
      if (remark != null) 'remark': remark,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StockMovementsCompanion copyWith({
    Value<String>? movementId,
    Value<String>? movementNo,
    Value<DateTime>? movementDate,
    Value<String>? movementType,
    Value<String>? productId,
    Value<String>? warehouseId,
    Value<double>? quantity,
    Value<double>? unitCost,
    Value<String?>? referenceType,
    Value<String?>? referenceId,
    Value<String>? userId,
    Value<String?>? remark,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return StockMovementsCompanion(
      movementId: movementId ?? this.movementId,
      movementNo: movementNo ?? this.movementNo,
      movementDate: movementDate ?? this.movementDate,
      movementType: movementType ?? this.movementType,
      productId: productId ?? this.productId,
      warehouseId: warehouseId ?? this.warehouseId,
      quantity: quantity ?? this.quantity,
      unitCost: unitCost ?? this.unitCost,
      referenceType: referenceType ?? this.referenceType,
      referenceId: referenceId ?? this.referenceId,
      userId: userId ?? this.userId,
      remark: remark ?? this.remark,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (movementId.present) {
      map['movement_id'] = Variable<String>(movementId.value);
    }
    if (movementNo.present) {
      map['movement_no'] = Variable<String>(movementNo.value);
    }
    if (movementDate.present) {
      map['movement_date'] = Variable<DateTime>(movementDate.value);
    }
    if (movementType.present) {
      map['movement_type'] = Variable<String>(movementType.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<String>(warehouseId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (unitCost.present) {
      map['unit_cost'] = Variable<double>(unitCost.value);
    }
    if (referenceType.present) {
      map['reference_type'] = Variable<String>(referenceType.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (remark.present) {
      map['remark'] = Variable<String>(remark.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockMovementsCompanion(')
          ..write('movementId: $movementId, ')
          ..write('movementNo: $movementNo, ')
          ..write('movementDate: $movementDate, ')
          ..write('movementType: $movementType, ')
          ..write('productId: $productId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('quantity: $quantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('referenceType: $referenceType, ')
          ..write('referenceId: $referenceId, ')
          ..write('userId: $userId, ')
          ..write('remark: $remark, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PromotionsTable extends Promotions
    with TableInfo<$PromotionsTable, Promotion> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PromotionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _promotionIdMeta = const VerificationMeta(
    'promotionId',
  );
  @override
  late final GeneratedColumn<String> promotionId = GeneratedColumn<String>(
    'promotion_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _promotionCodeMeta = const VerificationMeta(
    'promotionCode',
  );
  @override
  late final GeneratedColumn<String> promotionCode = GeneratedColumn<String>(
    'promotion_code',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _promotionNameMeta = const VerificationMeta(
    'promotionName',
  );
  @override
  late final GeneratedColumn<String> promotionName = GeneratedColumn<String>(
    'promotion_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _promotionTypeMeta = const VerificationMeta(
    'promotionType',
  );
  @override
  late final GeneratedColumn<String> promotionType = GeneratedColumn<String>(
    'promotion_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _discountTypeMeta = const VerificationMeta(
    'discountType',
  );
  @override
  late final GeneratedColumn<String> discountType = GeneratedColumn<String>(
    'discount_type',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _discountValueMeta = const VerificationMeta(
    'discountValue',
  );
  @override
  late final GeneratedColumn<double> discountValue = GeneratedColumn<double>(
    'discount_value',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _maxDiscountAmountMeta = const VerificationMeta(
    'maxDiscountAmount',
  );
  @override
  late final GeneratedColumn<double> maxDiscountAmount =
      GeneratedColumn<double>(
        'max_discount_amount',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _buyQtyMeta = const VerificationMeta('buyQty');
  @override
  late final GeneratedColumn<int> buyQty = GeneratedColumn<int>(
    'buy_qty',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _getQtyMeta = const VerificationMeta('getQty');
  @override
  late final GeneratedColumn<int> getQty = GeneratedColumn<int>(
    'get_qty',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _getProductIdMeta = const VerificationMeta(
    'getProductId',
  );
  @override
  late final GeneratedColumn<String> getProductId = GeneratedColumn<String>(
    'get_product_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _minAmountMeta = const VerificationMeta(
    'minAmount',
  );
  @override
  late final GeneratedColumn<double> minAmount = GeneratedColumn<double>(
    'min_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _minQtyMeta = const VerificationMeta('minQty');
  @override
  late final GeneratedColumn<double> minQty = GeneratedColumn<double>(
    'min_qty',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _applyToMeta = const VerificationMeta(
    'applyTo',
  );
  @override
  late final GeneratedColumn<String> applyTo = GeneratedColumn<String>(
    'apply_to',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  applyToIds =
      GeneratedColumn<String>(
        'apply_to_ids',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Map<String, dynamic>?>(
        $PromotionsTable.$converterapplyToIdsn,
      );
  static const VerificationMeta _startDateMeta = const VerificationMeta(
    'startDate',
  );
  @override
  late final GeneratedColumn<DateTime> startDate = GeneratedColumn<DateTime>(
    'start_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endDateMeta = const VerificationMeta(
    'endDate',
  );
  @override
  late final GeneratedColumn<DateTime> endDate = GeneratedColumn<DateTime>(
    'end_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _startTimeMeta = const VerificationMeta(
    'startTime',
  );
  @override
  late final GeneratedColumn<String> startTime = GeneratedColumn<String>(
    'start_time',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 8),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _endTimeMeta = const VerificationMeta(
    'endTime',
  );
  @override
  late final GeneratedColumn<String> endTime = GeneratedColumn<String>(
    'end_time',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 8),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  applyDays = GeneratedColumn<String>(
    'apply_days',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($PromotionsTable.$converterapplyDaysn);
  static const VerificationMeta _maxUsesMeta = const VerificationMeta(
    'maxUses',
  );
  @override
  late final GeneratedColumn<int> maxUses = GeneratedColumn<int>(
    'max_uses',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _maxUsesPerCustomerMeta =
      const VerificationMeta('maxUsesPerCustomer');
  @override
  late final GeneratedColumn<int> maxUsesPerCustomer = GeneratedColumn<int>(
    'max_uses_per_customer',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _currentUsesMeta = const VerificationMeta(
    'currentUses',
  );
  @override
  late final GeneratedColumn<int> currentUses = GeneratedColumn<int>(
    'current_uses',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isExclusiveMeta = const VerificationMeta(
    'isExclusive',
  );
  @override
  late final GeneratedColumn<bool> isExclusive = GeneratedColumn<bool>(
    'is_exclusive',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_exclusive" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdByMeta = const VerificationMeta(
    'createdBy',
  );
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
    'created_by',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (user_id)',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    promotionId,
    promotionCode,
    promotionName,
    promotionType,
    discountType,
    discountValue,
    maxDiscountAmount,
    buyQty,
    getQty,
    getProductId,
    minAmount,
    minQty,
    applyTo,
    applyToIds,
    startDate,
    endDate,
    startTime,
    endTime,
    applyDays,
    maxUses,
    maxUsesPerCustomer,
    currentUses,
    isExclusive,
    isActive,
    createdBy,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'promotions';
  @override
  VerificationContext validateIntegrity(
    Insertable<Promotion> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('promotion_id')) {
      context.handle(
        _promotionIdMeta,
        promotionId.isAcceptableOrUnknown(
          data['promotion_id']!,
          _promotionIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_promotionIdMeta);
    }
    if (data.containsKey('promotion_code')) {
      context.handle(
        _promotionCodeMeta,
        promotionCode.isAcceptableOrUnknown(
          data['promotion_code']!,
          _promotionCodeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_promotionCodeMeta);
    }
    if (data.containsKey('promotion_name')) {
      context.handle(
        _promotionNameMeta,
        promotionName.isAcceptableOrUnknown(
          data['promotion_name']!,
          _promotionNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_promotionNameMeta);
    }
    if (data.containsKey('promotion_type')) {
      context.handle(
        _promotionTypeMeta,
        promotionType.isAcceptableOrUnknown(
          data['promotion_type']!,
          _promotionTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_promotionTypeMeta);
    }
    if (data.containsKey('discount_type')) {
      context.handle(
        _discountTypeMeta,
        discountType.isAcceptableOrUnknown(
          data['discount_type']!,
          _discountTypeMeta,
        ),
      );
    }
    if (data.containsKey('discount_value')) {
      context.handle(
        _discountValueMeta,
        discountValue.isAcceptableOrUnknown(
          data['discount_value']!,
          _discountValueMeta,
        ),
      );
    }
    if (data.containsKey('max_discount_amount')) {
      context.handle(
        _maxDiscountAmountMeta,
        maxDiscountAmount.isAcceptableOrUnknown(
          data['max_discount_amount']!,
          _maxDiscountAmountMeta,
        ),
      );
    }
    if (data.containsKey('buy_qty')) {
      context.handle(
        _buyQtyMeta,
        buyQty.isAcceptableOrUnknown(data['buy_qty']!, _buyQtyMeta),
      );
    }
    if (data.containsKey('get_qty')) {
      context.handle(
        _getQtyMeta,
        getQty.isAcceptableOrUnknown(data['get_qty']!, _getQtyMeta),
      );
    }
    if (data.containsKey('get_product_id')) {
      context.handle(
        _getProductIdMeta,
        getProductId.isAcceptableOrUnknown(
          data['get_product_id']!,
          _getProductIdMeta,
        ),
      );
    }
    if (data.containsKey('min_amount')) {
      context.handle(
        _minAmountMeta,
        minAmount.isAcceptableOrUnknown(data['min_amount']!, _minAmountMeta),
      );
    }
    if (data.containsKey('min_qty')) {
      context.handle(
        _minQtyMeta,
        minQty.isAcceptableOrUnknown(data['min_qty']!, _minQtyMeta),
      );
    }
    if (data.containsKey('apply_to')) {
      context.handle(
        _applyToMeta,
        applyTo.isAcceptableOrUnknown(data['apply_to']!, _applyToMeta),
      );
    } else if (isInserting) {
      context.missing(_applyToMeta);
    }
    if (data.containsKey('start_date')) {
      context.handle(
        _startDateMeta,
        startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta),
      );
    } else if (isInserting) {
      context.missing(_startDateMeta);
    }
    if (data.containsKey('end_date')) {
      context.handle(
        _endDateMeta,
        endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta),
      );
    } else if (isInserting) {
      context.missing(_endDateMeta);
    }
    if (data.containsKey('start_time')) {
      context.handle(
        _startTimeMeta,
        startTime.isAcceptableOrUnknown(data['start_time']!, _startTimeMeta),
      );
    }
    if (data.containsKey('end_time')) {
      context.handle(
        _endTimeMeta,
        endTime.isAcceptableOrUnknown(data['end_time']!, _endTimeMeta),
      );
    }
    if (data.containsKey('max_uses')) {
      context.handle(
        _maxUsesMeta,
        maxUses.isAcceptableOrUnknown(data['max_uses']!, _maxUsesMeta),
      );
    }
    if (data.containsKey('max_uses_per_customer')) {
      context.handle(
        _maxUsesPerCustomerMeta,
        maxUsesPerCustomer.isAcceptableOrUnknown(
          data['max_uses_per_customer']!,
          _maxUsesPerCustomerMeta,
        ),
      );
    }
    if (data.containsKey('current_uses')) {
      context.handle(
        _currentUsesMeta,
        currentUses.isAcceptableOrUnknown(
          data['current_uses']!,
          _currentUsesMeta,
        ),
      );
    }
    if (data.containsKey('is_exclusive')) {
      context.handle(
        _isExclusiveMeta,
        isExclusive.isAcceptableOrUnknown(
          data['is_exclusive']!,
          _isExclusiveMeta,
        ),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_by')) {
      context.handle(
        _createdByMeta,
        createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {promotionId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {promotionCode},
  ];
  @override
  Promotion map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Promotion(
      promotionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}promotion_id'],
      )!,
      promotionCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}promotion_code'],
      )!,
      promotionName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}promotion_name'],
      )!,
      promotionType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}promotion_type'],
      )!,
      discountType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}discount_type'],
      ),
      discountValue: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}discount_value'],
      )!,
      maxDiscountAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}max_discount_amount'],
      ),
      buyQty: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}buy_qty'],
      ),
      getQty: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}get_qty'],
      ),
      getProductId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}get_product_id'],
      ),
      minAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}min_amount'],
      )!,
      minQty: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}min_qty'],
      )!,
      applyTo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}apply_to'],
      )!,
      applyToIds: $PromotionsTable.$converterapplyToIdsn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}apply_to_ids'],
        ),
      ),
      startDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}start_date'],
      )!,
      endDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}end_date'],
      )!,
      startTime: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}start_time'],
      ),
      endTime: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}end_time'],
      ),
      applyDays: $PromotionsTable.$converterapplyDaysn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}apply_days'],
        ),
      ),
      maxUses: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_uses'],
      ),
      maxUsesPerCustomer: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_uses_per_customer'],
      ),
      currentUses: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}current_uses'],
      )!,
      isExclusive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_exclusive'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}created_by'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $PromotionsTable createAlias(String alias) {
    return $PromotionsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $converterapplyToIds =
      const JsonConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $converterapplyToIdsn =
      NullAwareTypeConverter.wrap($converterapplyToIds);
  static TypeConverter<Map<String, dynamic>, String> $converterapplyDays =
      const JsonConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $converterapplyDaysn =
      NullAwareTypeConverter.wrap($converterapplyDays);
}

class Promotion extends DataClass implements Insertable<Promotion> {
  final String promotionId;
  final String promotionCode;
  final String promotionName;
  final String promotionType;
  final String? discountType;
  final double discountValue;
  final double? maxDiscountAmount;
  final int? buyQty;
  final int? getQty;
  final String? getProductId;
  final double minAmount;
  final double minQty;
  final String applyTo;
  final Map<String, dynamic>? applyToIds;
  final DateTime startDate;
  final DateTime endDate;
  final String? startTime;
  final String? endTime;
  final Map<String, dynamic>? applyDays;
  final int? maxUses;
  final int? maxUsesPerCustomer;
  final int currentUses;
  final bool isExclusive;
  final bool isActive;
  final String? createdBy;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Promotion({
    required this.promotionId,
    required this.promotionCode,
    required this.promotionName,
    required this.promotionType,
    this.discountType,
    required this.discountValue,
    this.maxDiscountAmount,
    this.buyQty,
    this.getQty,
    this.getProductId,
    required this.minAmount,
    required this.minQty,
    required this.applyTo,
    this.applyToIds,
    required this.startDate,
    required this.endDate,
    this.startTime,
    this.endTime,
    this.applyDays,
    this.maxUses,
    this.maxUsesPerCustomer,
    required this.currentUses,
    required this.isExclusive,
    required this.isActive,
    this.createdBy,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['promotion_id'] = Variable<String>(promotionId);
    map['promotion_code'] = Variable<String>(promotionCode);
    map['promotion_name'] = Variable<String>(promotionName);
    map['promotion_type'] = Variable<String>(promotionType);
    if (!nullToAbsent || discountType != null) {
      map['discount_type'] = Variable<String>(discountType);
    }
    map['discount_value'] = Variable<double>(discountValue);
    if (!nullToAbsent || maxDiscountAmount != null) {
      map['max_discount_amount'] = Variable<double>(maxDiscountAmount);
    }
    if (!nullToAbsent || buyQty != null) {
      map['buy_qty'] = Variable<int>(buyQty);
    }
    if (!nullToAbsent || getQty != null) {
      map['get_qty'] = Variable<int>(getQty);
    }
    if (!nullToAbsent || getProductId != null) {
      map['get_product_id'] = Variable<String>(getProductId);
    }
    map['min_amount'] = Variable<double>(minAmount);
    map['min_qty'] = Variable<double>(minQty);
    map['apply_to'] = Variable<String>(applyTo);
    if (!nullToAbsent || applyToIds != null) {
      map['apply_to_ids'] = Variable<String>(
        $PromotionsTable.$converterapplyToIdsn.toSql(applyToIds),
      );
    }
    map['start_date'] = Variable<DateTime>(startDate);
    map['end_date'] = Variable<DateTime>(endDate);
    if (!nullToAbsent || startTime != null) {
      map['start_time'] = Variable<String>(startTime);
    }
    if (!nullToAbsent || endTime != null) {
      map['end_time'] = Variable<String>(endTime);
    }
    if (!nullToAbsent || applyDays != null) {
      map['apply_days'] = Variable<String>(
        $PromotionsTable.$converterapplyDaysn.toSql(applyDays),
      );
    }
    if (!nullToAbsent || maxUses != null) {
      map['max_uses'] = Variable<int>(maxUses);
    }
    if (!nullToAbsent || maxUsesPerCustomer != null) {
      map['max_uses_per_customer'] = Variable<int>(maxUsesPerCustomer);
    }
    map['current_uses'] = Variable<int>(currentUses);
    map['is_exclusive'] = Variable<bool>(isExclusive);
    map['is_active'] = Variable<bool>(isActive);
    if (!nullToAbsent || createdBy != null) {
      map['created_by'] = Variable<String>(createdBy);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  PromotionsCompanion toCompanion(bool nullToAbsent) {
    return PromotionsCompanion(
      promotionId: Value(promotionId),
      promotionCode: Value(promotionCode),
      promotionName: Value(promotionName),
      promotionType: Value(promotionType),
      discountType: discountType == null && nullToAbsent
          ? const Value.absent()
          : Value(discountType),
      discountValue: Value(discountValue),
      maxDiscountAmount: maxDiscountAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(maxDiscountAmount),
      buyQty: buyQty == null && nullToAbsent
          ? const Value.absent()
          : Value(buyQty),
      getQty: getQty == null && nullToAbsent
          ? const Value.absent()
          : Value(getQty),
      getProductId: getProductId == null && nullToAbsent
          ? const Value.absent()
          : Value(getProductId),
      minAmount: Value(minAmount),
      minQty: Value(minQty),
      applyTo: Value(applyTo),
      applyToIds: applyToIds == null && nullToAbsent
          ? const Value.absent()
          : Value(applyToIds),
      startDate: Value(startDate),
      endDate: Value(endDate),
      startTime: startTime == null && nullToAbsent
          ? const Value.absent()
          : Value(startTime),
      endTime: endTime == null && nullToAbsent
          ? const Value.absent()
          : Value(endTime),
      applyDays: applyDays == null && nullToAbsent
          ? const Value.absent()
          : Value(applyDays),
      maxUses: maxUses == null && nullToAbsent
          ? const Value.absent()
          : Value(maxUses),
      maxUsesPerCustomer: maxUsesPerCustomer == null && nullToAbsent
          ? const Value.absent()
          : Value(maxUsesPerCustomer),
      currentUses: Value(currentUses),
      isExclusive: Value(isExclusive),
      isActive: Value(isActive),
      createdBy: createdBy == null && nullToAbsent
          ? const Value.absent()
          : Value(createdBy),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Promotion.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Promotion(
      promotionId: serializer.fromJson<String>(json['promotionId']),
      promotionCode: serializer.fromJson<String>(json['promotionCode']),
      promotionName: serializer.fromJson<String>(json['promotionName']),
      promotionType: serializer.fromJson<String>(json['promotionType']),
      discountType: serializer.fromJson<String?>(json['discountType']),
      discountValue: serializer.fromJson<double>(json['discountValue']),
      maxDiscountAmount: serializer.fromJson<double?>(
        json['maxDiscountAmount'],
      ),
      buyQty: serializer.fromJson<int?>(json['buyQty']),
      getQty: serializer.fromJson<int?>(json['getQty']),
      getProductId: serializer.fromJson<String?>(json['getProductId']),
      minAmount: serializer.fromJson<double>(json['minAmount']),
      minQty: serializer.fromJson<double>(json['minQty']),
      applyTo: serializer.fromJson<String>(json['applyTo']),
      applyToIds: serializer.fromJson<Map<String, dynamic>?>(
        json['applyToIds'],
      ),
      startDate: serializer.fromJson<DateTime>(json['startDate']),
      endDate: serializer.fromJson<DateTime>(json['endDate']),
      startTime: serializer.fromJson<String?>(json['startTime']),
      endTime: serializer.fromJson<String?>(json['endTime']),
      applyDays: serializer.fromJson<Map<String, dynamic>?>(json['applyDays']),
      maxUses: serializer.fromJson<int?>(json['maxUses']),
      maxUsesPerCustomer: serializer.fromJson<int?>(json['maxUsesPerCustomer']),
      currentUses: serializer.fromJson<int>(json['currentUses']),
      isExclusive: serializer.fromJson<bool>(json['isExclusive']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdBy: serializer.fromJson<String?>(json['createdBy']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'promotionId': serializer.toJson<String>(promotionId),
      'promotionCode': serializer.toJson<String>(promotionCode),
      'promotionName': serializer.toJson<String>(promotionName),
      'promotionType': serializer.toJson<String>(promotionType),
      'discountType': serializer.toJson<String?>(discountType),
      'discountValue': serializer.toJson<double>(discountValue),
      'maxDiscountAmount': serializer.toJson<double?>(maxDiscountAmount),
      'buyQty': serializer.toJson<int?>(buyQty),
      'getQty': serializer.toJson<int?>(getQty),
      'getProductId': serializer.toJson<String?>(getProductId),
      'minAmount': serializer.toJson<double>(minAmount),
      'minQty': serializer.toJson<double>(minQty),
      'applyTo': serializer.toJson<String>(applyTo),
      'applyToIds': serializer.toJson<Map<String, dynamic>?>(applyToIds),
      'startDate': serializer.toJson<DateTime>(startDate),
      'endDate': serializer.toJson<DateTime>(endDate),
      'startTime': serializer.toJson<String?>(startTime),
      'endTime': serializer.toJson<String?>(endTime),
      'applyDays': serializer.toJson<Map<String, dynamic>?>(applyDays),
      'maxUses': serializer.toJson<int?>(maxUses),
      'maxUsesPerCustomer': serializer.toJson<int?>(maxUsesPerCustomer),
      'currentUses': serializer.toJson<int>(currentUses),
      'isExclusive': serializer.toJson<bool>(isExclusive),
      'isActive': serializer.toJson<bool>(isActive),
      'createdBy': serializer.toJson<String?>(createdBy),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Promotion copyWith({
    String? promotionId,
    String? promotionCode,
    String? promotionName,
    String? promotionType,
    Value<String?> discountType = const Value.absent(),
    double? discountValue,
    Value<double?> maxDiscountAmount = const Value.absent(),
    Value<int?> buyQty = const Value.absent(),
    Value<int?> getQty = const Value.absent(),
    Value<String?> getProductId = const Value.absent(),
    double? minAmount,
    double? minQty,
    String? applyTo,
    Value<Map<String, dynamic>?> applyToIds = const Value.absent(),
    DateTime? startDate,
    DateTime? endDate,
    Value<String?> startTime = const Value.absent(),
    Value<String?> endTime = const Value.absent(),
    Value<Map<String, dynamic>?> applyDays = const Value.absent(),
    Value<int?> maxUses = const Value.absent(),
    Value<int?> maxUsesPerCustomer = const Value.absent(),
    int? currentUses,
    bool? isExclusive,
    bool? isActive,
    Value<String?> createdBy = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Promotion(
    promotionId: promotionId ?? this.promotionId,
    promotionCode: promotionCode ?? this.promotionCode,
    promotionName: promotionName ?? this.promotionName,
    promotionType: promotionType ?? this.promotionType,
    discountType: discountType.present ? discountType.value : this.discountType,
    discountValue: discountValue ?? this.discountValue,
    maxDiscountAmount: maxDiscountAmount.present
        ? maxDiscountAmount.value
        : this.maxDiscountAmount,
    buyQty: buyQty.present ? buyQty.value : this.buyQty,
    getQty: getQty.present ? getQty.value : this.getQty,
    getProductId: getProductId.present ? getProductId.value : this.getProductId,
    minAmount: minAmount ?? this.minAmount,
    minQty: minQty ?? this.minQty,
    applyTo: applyTo ?? this.applyTo,
    applyToIds: applyToIds.present ? applyToIds.value : this.applyToIds,
    startDate: startDate ?? this.startDate,
    endDate: endDate ?? this.endDate,
    startTime: startTime.present ? startTime.value : this.startTime,
    endTime: endTime.present ? endTime.value : this.endTime,
    applyDays: applyDays.present ? applyDays.value : this.applyDays,
    maxUses: maxUses.present ? maxUses.value : this.maxUses,
    maxUsesPerCustomer: maxUsesPerCustomer.present
        ? maxUsesPerCustomer.value
        : this.maxUsesPerCustomer,
    currentUses: currentUses ?? this.currentUses,
    isExclusive: isExclusive ?? this.isExclusive,
    isActive: isActive ?? this.isActive,
    createdBy: createdBy.present ? createdBy.value : this.createdBy,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Promotion copyWithCompanion(PromotionsCompanion data) {
    return Promotion(
      promotionId: data.promotionId.present
          ? data.promotionId.value
          : this.promotionId,
      promotionCode: data.promotionCode.present
          ? data.promotionCode.value
          : this.promotionCode,
      promotionName: data.promotionName.present
          ? data.promotionName.value
          : this.promotionName,
      promotionType: data.promotionType.present
          ? data.promotionType.value
          : this.promotionType,
      discountType: data.discountType.present
          ? data.discountType.value
          : this.discountType,
      discountValue: data.discountValue.present
          ? data.discountValue.value
          : this.discountValue,
      maxDiscountAmount: data.maxDiscountAmount.present
          ? data.maxDiscountAmount.value
          : this.maxDiscountAmount,
      buyQty: data.buyQty.present ? data.buyQty.value : this.buyQty,
      getQty: data.getQty.present ? data.getQty.value : this.getQty,
      getProductId: data.getProductId.present
          ? data.getProductId.value
          : this.getProductId,
      minAmount: data.minAmount.present ? data.minAmount.value : this.minAmount,
      minQty: data.minQty.present ? data.minQty.value : this.minQty,
      applyTo: data.applyTo.present ? data.applyTo.value : this.applyTo,
      applyToIds: data.applyToIds.present
          ? data.applyToIds.value
          : this.applyToIds,
      startDate: data.startDate.present ? data.startDate.value : this.startDate,
      endDate: data.endDate.present ? data.endDate.value : this.endDate,
      startTime: data.startTime.present ? data.startTime.value : this.startTime,
      endTime: data.endTime.present ? data.endTime.value : this.endTime,
      applyDays: data.applyDays.present ? data.applyDays.value : this.applyDays,
      maxUses: data.maxUses.present ? data.maxUses.value : this.maxUses,
      maxUsesPerCustomer: data.maxUsesPerCustomer.present
          ? data.maxUsesPerCustomer.value
          : this.maxUsesPerCustomer,
      currentUses: data.currentUses.present
          ? data.currentUses.value
          : this.currentUses,
      isExclusive: data.isExclusive.present
          ? data.isExclusive.value
          : this.isExclusive,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Promotion(')
          ..write('promotionId: $promotionId, ')
          ..write('promotionCode: $promotionCode, ')
          ..write('promotionName: $promotionName, ')
          ..write('promotionType: $promotionType, ')
          ..write('discountType: $discountType, ')
          ..write('discountValue: $discountValue, ')
          ..write('maxDiscountAmount: $maxDiscountAmount, ')
          ..write('buyQty: $buyQty, ')
          ..write('getQty: $getQty, ')
          ..write('getProductId: $getProductId, ')
          ..write('minAmount: $minAmount, ')
          ..write('minQty: $minQty, ')
          ..write('applyTo: $applyTo, ')
          ..write('applyToIds: $applyToIds, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('startTime: $startTime, ')
          ..write('endTime: $endTime, ')
          ..write('applyDays: $applyDays, ')
          ..write('maxUses: $maxUses, ')
          ..write('maxUsesPerCustomer: $maxUsesPerCustomer, ')
          ..write('currentUses: $currentUses, ')
          ..write('isExclusive: $isExclusive, ')
          ..write('isActive: $isActive, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    promotionId,
    promotionCode,
    promotionName,
    promotionType,
    discountType,
    discountValue,
    maxDiscountAmount,
    buyQty,
    getQty,
    getProductId,
    minAmount,
    minQty,
    applyTo,
    applyToIds,
    startDate,
    endDate,
    startTime,
    endTime,
    applyDays,
    maxUses,
    maxUsesPerCustomer,
    currentUses,
    isExclusive,
    isActive,
    createdBy,
    createdAt,
    updatedAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Promotion &&
          other.promotionId == this.promotionId &&
          other.promotionCode == this.promotionCode &&
          other.promotionName == this.promotionName &&
          other.promotionType == this.promotionType &&
          other.discountType == this.discountType &&
          other.discountValue == this.discountValue &&
          other.maxDiscountAmount == this.maxDiscountAmount &&
          other.buyQty == this.buyQty &&
          other.getQty == this.getQty &&
          other.getProductId == this.getProductId &&
          other.minAmount == this.minAmount &&
          other.minQty == this.minQty &&
          other.applyTo == this.applyTo &&
          other.applyToIds == this.applyToIds &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.startTime == this.startTime &&
          other.endTime == this.endTime &&
          other.applyDays == this.applyDays &&
          other.maxUses == this.maxUses &&
          other.maxUsesPerCustomer == this.maxUsesPerCustomer &&
          other.currentUses == this.currentUses &&
          other.isExclusive == this.isExclusive &&
          other.isActive == this.isActive &&
          other.createdBy == this.createdBy &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class PromotionsCompanion extends UpdateCompanion<Promotion> {
  final Value<String> promotionId;
  final Value<String> promotionCode;
  final Value<String> promotionName;
  final Value<String> promotionType;
  final Value<String?> discountType;
  final Value<double> discountValue;
  final Value<double?> maxDiscountAmount;
  final Value<int?> buyQty;
  final Value<int?> getQty;
  final Value<String?> getProductId;
  final Value<double> minAmount;
  final Value<double> minQty;
  final Value<String> applyTo;
  final Value<Map<String, dynamic>?> applyToIds;
  final Value<DateTime> startDate;
  final Value<DateTime> endDate;
  final Value<String?> startTime;
  final Value<String?> endTime;
  final Value<Map<String, dynamic>?> applyDays;
  final Value<int?> maxUses;
  final Value<int?> maxUsesPerCustomer;
  final Value<int> currentUses;
  final Value<bool> isExclusive;
  final Value<bool> isActive;
  final Value<String?> createdBy;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const PromotionsCompanion({
    this.promotionId = const Value.absent(),
    this.promotionCode = const Value.absent(),
    this.promotionName = const Value.absent(),
    this.promotionType = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountValue = const Value.absent(),
    this.maxDiscountAmount = const Value.absent(),
    this.buyQty = const Value.absent(),
    this.getQty = const Value.absent(),
    this.getProductId = const Value.absent(),
    this.minAmount = const Value.absent(),
    this.minQty = const Value.absent(),
    this.applyTo = const Value.absent(),
    this.applyToIds = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.startTime = const Value.absent(),
    this.endTime = const Value.absent(),
    this.applyDays = const Value.absent(),
    this.maxUses = const Value.absent(),
    this.maxUsesPerCustomer = const Value.absent(),
    this.currentUses = const Value.absent(),
    this.isExclusive = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PromotionsCompanion.insert({
    required String promotionId,
    required String promotionCode,
    required String promotionName,
    required String promotionType,
    this.discountType = const Value.absent(),
    this.discountValue = const Value.absent(),
    this.maxDiscountAmount = const Value.absent(),
    this.buyQty = const Value.absent(),
    this.getQty = const Value.absent(),
    this.getProductId = const Value.absent(),
    this.minAmount = const Value.absent(),
    this.minQty = const Value.absent(),
    required String applyTo,
    this.applyToIds = const Value.absent(),
    required DateTime startDate,
    required DateTime endDate,
    this.startTime = const Value.absent(),
    this.endTime = const Value.absent(),
    this.applyDays = const Value.absent(),
    this.maxUses = const Value.absent(),
    this.maxUsesPerCustomer = const Value.absent(),
    this.currentUses = const Value.absent(),
    this.isExclusive = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : promotionId = Value(promotionId),
       promotionCode = Value(promotionCode),
       promotionName = Value(promotionName),
       promotionType = Value(promotionType),
       applyTo = Value(applyTo),
       startDate = Value(startDate),
       endDate = Value(endDate);
  static Insertable<Promotion> custom({
    Expression<String>? promotionId,
    Expression<String>? promotionCode,
    Expression<String>? promotionName,
    Expression<String>? promotionType,
    Expression<String>? discountType,
    Expression<double>? discountValue,
    Expression<double>? maxDiscountAmount,
    Expression<int>? buyQty,
    Expression<int>? getQty,
    Expression<String>? getProductId,
    Expression<double>? minAmount,
    Expression<double>? minQty,
    Expression<String>? applyTo,
    Expression<String>? applyToIds,
    Expression<DateTime>? startDate,
    Expression<DateTime>? endDate,
    Expression<String>? startTime,
    Expression<String>? endTime,
    Expression<String>? applyDays,
    Expression<int>? maxUses,
    Expression<int>? maxUsesPerCustomer,
    Expression<int>? currentUses,
    Expression<bool>? isExclusive,
    Expression<bool>? isActive,
    Expression<String>? createdBy,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (promotionId != null) 'promotion_id': promotionId,
      if (promotionCode != null) 'promotion_code': promotionCode,
      if (promotionName != null) 'promotion_name': promotionName,
      if (promotionType != null) 'promotion_type': promotionType,
      if (discountType != null) 'discount_type': discountType,
      if (discountValue != null) 'discount_value': discountValue,
      if (maxDiscountAmount != null) 'max_discount_amount': maxDiscountAmount,
      if (buyQty != null) 'buy_qty': buyQty,
      if (getQty != null) 'get_qty': getQty,
      if (getProductId != null) 'get_product_id': getProductId,
      if (minAmount != null) 'min_amount': minAmount,
      if (minQty != null) 'min_qty': minQty,
      if (applyTo != null) 'apply_to': applyTo,
      if (applyToIds != null) 'apply_to_ids': applyToIds,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (startTime != null) 'start_time': startTime,
      if (endTime != null) 'end_time': endTime,
      if (applyDays != null) 'apply_days': applyDays,
      if (maxUses != null) 'max_uses': maxUses,
      if (maxUsesPerCustomer != null)
        'max_uses_per_customer': maxUsesPerCustomer,
      if (currentUses != null) 'current_uses': currentUses,
      if (isExclusive != null) 'is_exclusive': isExclusive,
      if (isActive != null) 'is_active': isActive,
      if (createdBy != null) 'created_by': createdBy,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PromotionsCompanion copyWith({
    Value<String>? promotionId,
    Value<String>? promotionCode,
    Value<String>? promotionName,
    Value<String>? promotionType,
    Value<String?>? discountType,
    Value<double>? discountValue,
    Value<double?>? maxDiscountAmount,
    Value<int?>? buyQty,
    Value<int?>? getQty,
    Value<String?>? getProductId,
    Value<double>? minAmount,
    Value<double>? minQty,
    Value<String>? applyTo,
    Value<Map<String, dynamic>?>? applyToIds,
    Value<DateTime>? startDate,
    Value<DateTime>? endDate,
    Value<String?>? startTime,
    Value<String?>? endTime,
    Value<Map<String, dynamic>?>? applyDays,
    Value<int?>? maxUses,
    Value<int?>? maxUsesPerCustomer,
    Value<int>? currentUses,
    Value<bool>? isExclusive,
    Value<bool>? isActive,
    Value<String?>? createdBy,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return PromotionsCompanion(
      promotionId: promotionId ?? this.promotionId,
      promotionCode: promotionCode ?? this.promotionCode,
      promotionName: promotionName ?? this.promotionName,
      promotionType: promotionType ?? this.promotionType,
      discountType: discountType ?? this.discountType,
      discountValue: discountValue ?? this.discountValue,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
      buyQty: buyQty ?? this.buyQty,
      getQty: getQty ?? this.getQty,
      getProductId: getProductId ?? this.getProductId,
      minAmount: minAmount ?? this.minAmount,
      minQty: minQty ?? this.minQty,
      applyTo: applyTo ?? this.applyTo,
      applyToIds: applyToIds ?? this.applyToIds,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      applyDays: applyDays ?? this.applyDays,
      maxUses: maxUses ?? this.maxUses,
      maxUsesPerCustomer: maxUsesPerCustomer ?? this.maxUsesPerCustomer,
      currentUses: currentUses ?? this.currentUses,
      isExclusive: isExclusive ?? this.isExclusive,
      isActive: isActive ?? this.isActive,
      createdBy: createdBy ?? this.createdBy,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (promotionId.present) {
      map['promotion_id'] = Variable<String>(promotionId.value);
    }
    if (promotionCode.present) {
      map['promotion_code'] = Variable<String>(promotionCode.value);
    }
    if (promotionName.present) {
      map['promotion_name'] = Variable<String>(promotionName.value);
    }
    if (promotionType.present) {
      map['promotion_type'] = Variable<String>(promotionType.value);
    }
    if (discountType.present) {
      map['discount_type'] = Variable<String>(discountType.value);
    }
    if (discountValue.present) {
      map['discount_value'] = Variable<double>(discountValue.value);
    }
    if (maxDiscountAmount.present) {
      map['max_discount_amount'] = Variable<double>(maxDiscountAmount.value);
    }
    if (buyQty.present) {
      map['buy_qty'] = Variable<int>(buyQty.value);
    }
    if (getQty.present) {
      map['get_qty'] = Variable<int>(getQty.value);
    }
    if (getProductId.present) {
      map['get_product_id'] = Variable<String>(getProductId.value);
    }
    if (minAmount.present) {
      map['min_amount'] = Variable<double>(minAmount.value);
    }
    if (minQty.present) {
      map['min_qty'] = Variable<double>(minQty.value);
    }
    if (applyTo.present) {
      map['apply_to'] = Variable<String>(applyTo.value);
    }
    if (applyToIds.present) {
      map['apply_to_ids'] = Variable<String>(
        $PromotionsTable.$converterapplyToIdsn.toSql(applyToIds.value),
      );
    }
    if (startDate.present) {
      map['start_date'] = Variable<DateTime>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<DateTime>(endDate.value);
    }
    if (startTime.present) {
      map['start_time'] = Variable<String>(startTime.value);
    }
    if (endTime.present) {
      map['end_time'] = Variable<String>(endTime.value);
    }
    if (applyDays.present) {
      map['apply_days'] = Variable<String>(
        $PromotionsTable.$converterapplyDaysn.toSql(applyDays.value),
      );
    }
    if (maxUses.present) {
      map['max_uses'] = Variable<int>(maxUses.value);
    }
    if (maxUsesPerCustomer.present) {
      map['max_uses_per_customer'] = Variable<int>(maxUsesPerCustomer.value);
    }
    if (currentUses.present) {
      map['current_uses'] = Variable<int>(currentUses.value);
    }
    if (isExclusive.present) {
      map['is_exclusive'] = Variable<bool>(isExclusive.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PromotionsCompanion(')
          ..write('promotionId: $promotionId, ')
          ..write('promotionCode: $promotionCode, ')
          ..write('promotionName: $promotionName, ')
          ..write('promotionType: $promotionType, ')
          ..write('discountType: $discountType, ')
          ..write('discountValue: $discountValue, ')
          ..write('maxDiscountAmount: $maxDiscountAmount, ')
          ..write('buyQty: $buyQty, ')
          ..write('getQty: $getQty, ')
          ..write('getProductId: $getProductId, ')
          ..write('minAmount: $minAmount, ')
          ..write('minQty: $minQty, ')
          ..write('applyTo: $applyTo, ')
          ..write('applyToIds: $applyToIds, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('startTime: $startTime, ')
          ..write('endTime: $endTime, ')
          ..write('applyDays: $applyDays, ')
          ..write('maxUses: $maxUses, ')
          ..write('maxUsesPerCustomer: $maxUsesPerCustomer, ')
          ..write('currentUses: $currentUses, ')
          ..write('isExclusive: $isExclusive, ')
          ..write('isActive: $isActive, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PromotionUsagesTable extends PromotionUsages
    with TableInfo<$PromotionUsagesTable, PromotionUsage> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PromotionUsagesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _usageIdMeta = const VerificationMeta(
    'usageId',
  );
  @override
  late final GeneratedColumn<String> usageId = GeneratedColumn<String>(
    'usage_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _promotionIdMeta = const VerificationMeta(
    'promotionId',
  );
  @override
  late final GeneratedColumn<String> promotionId = GeneratedColumn<String>(
    'promotion_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES promotions (promotion_id)',
    ),
  );
  static const VerificationMeta _orderIdMeta = const VerificationMeta(
    'orderId',
  );
  @override
  late final GeneratedColumn<String> orderId = GeneratedColumn<String>(
    'order_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sales_orders (order_id)',
    ),
  );
  static const VerificationMeta _customerIdMeta = const VerificationMeta(
    'customerId',
  );
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
    'customer_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES customers (customer_id)',
    ),
  );
  static const VerificationMeta _discountAmountMeta = const VerificationMeta(
    'discountAmount',
  );
  @override
  late final GeneratedColumn<double> discountAmount = GeneratedColumn<double>(
    'discount_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _usedAtMeta = const VerificationMeta('usedAt');
  @override
  late final GeneratedColumn<DateTime> usedAt = GeneratedColumn<DateTime>(
    'used_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    usageId,
    promotionId,
    orderId,
    customerId,
    discountAmount,
    usedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'promotion_usages';
  @override
  VerificationContext validateIntegrity(
    Insertable<PromotionUsage> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('usage_id')) {
      context.handle(
        _usageIdMeta,
        usageId.isAcceptableOrUnknown(data['usage_id']!, _usageIdMeta),
      );
    } else if (isInserting) {
      context.missing(_usageIdMeta);
    }
    if (data.containsKey('promotion_id')) {
      context.handle(
        _promotionIdMeta,
        promotionId.isAcceptableOrUnknown(
          data['promotion_id']!,
          _promotionIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_promotionIdMeta);
    }
    if (data.containsKey('order_id')) {
      context.handle(
        _orderIdMeta,
        orderId.isAcceptableOrUnknown(data['order_id']!, _orderIdMeta),
      );
    } else if (isInserting) {
      context.missing(_orderIdMeta);
    }
    if (data.containsKey('customer_id')) {
      context.handle(
        _customerIdMeta,
        customerId.isAcceptableOrUnknown(data['customer_id']!, _customerIdMeta),
      );
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
        _discountAmountMeta,
        discountAmount.isAcceptableOrUnknown(
          data['discount_amount']!,
          _discountAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_discountAmountMeta);
    }
    if (data.containsKey('used_at')) {
      context.handle(
        _usedAtMeta,
        usedAt.isAcceptableOrUnknown(data['used_at']!, _usedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {usageId};
  @override
  PromotionUsage map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PromotionUsage(
      usageId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}usage_id'],
      )!,
      promotionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}promotion_id'],
      )!,
      orderId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_id'],
      )!,
      customerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_id'],
      ),
      discountAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}discount_amount'],
      )!,
      usedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}used_at'],
      )!,
    );
  }

  @override
  $PromotionUsagesTable createAlias(String alias) {
    return $PromotionUsagesTable(attachedDatabase, alias);
  }
}

class PromotionUsage extends DataClass implements Insertable<PromotionUsage> {
  final String usageId;
  final String promotionId;
  final String orderId;
  final String? customerId;
  final double discountAmount;
  final DateTime usedAt;
  const PromotionUsage({
    required this.usageId,
    required this.promotionId,
    required this.orderId,
    this.customerId,
    required this.discountAmount,
    required this.usedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['usage_id'] = Variable<String>(usageId);
    map['promotion_id'] = Variable<String>(promotionId);
    map['order_id'] = Variable<String>(orderId);
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    map['discount_amount'] = Variable<double>(discountAmount);
    map['used_at'] = Variable<DateTime>(usedAt);
    return map;
  }

  PromotionUsagesCompanion toCompanion(bool nullToAbsent) {
    return PromotionUsagesCompanion(
      usageId: Value(usageId),
      promotionId: Value(promotionId),
      orderId: Value(orderId),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      discountAmount: Value(discountAmount),
      usedAt: Value(usedAt),
    );
  }

  factory PromotionUsage.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PromotionUsage(
      usageId: serializer.fromJson<String>(json['usageId']),
      promotionId: serializer.fromJson<String>(json['promotionId']),
      orderId: serializer.fromJson<String>(json['orderId']),
      customerId: serializer.fromJson<String?>(json['customerId']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      usedAt: serializer.fromJson<DateTime>(json['usedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'usageId': serializer.toJson<String>(usageId),
      'promotionId': serializer.toJson<String>(promotionId),
      'orderId': serializer.toJson<String>(orderId),
      'customerId': serializer.toJson<String?>(customerId),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'usedAt': serializer.toJson<DateTime>(usedAt),
    };
  }

  PromotionUsage copyWith({
    String? usageId,
    String? promotionId,
    String? orderId,
    Value<String?> customerId = const Value.absent(),
    double? discountAmount,
    DateTime? usedAt,
  }) => PromotionUsage(
    usageId: usageId ?? this.usageId,
    promotionId: promotionId ?? this.promotionId,
    orderId: orderId ?? this.orderId,
    customerId: customerId.present ? customerId.value : this.customerId,
    discountAmount: discountAmount ?? this.discountAmount,
    usedAt: usedAt ?? this.usedAt,
  );
  PromotionUsage copyWithCompanion(PromotionUsagesCompanion data) {
    return PromotionUsage(
      usageId: data.usageId.present ? data.usageId.value : this.usageId,
      promotionId: data.promotionId.present
          ? data.promotionId.value
          : this.promotionId,
      orderId: data.orderId.present ? data.orderId.value : this.orderId,
      customerId: data.customerId.present
          ? data.customerId.value
          : this.customerId,
      discountAmount: data.discountAmount.present
          ? data.discountAmount.value
          : this.discountAmount,
      usedAt: data.usedAt.present ? data.usedAt.value : this.usedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PromotionUsage(')
          ..write('usageId: $usageId, ')
          ..write('promotionId: $promotionId, ')
          ..write('orderId: $orderId, ')
          ..write('customerId: $customerId, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('usedAt: $usedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    usageId,
    promotionId,
    orderId,
    customerId,
    discountAmount,
    usedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PromotionUsage &&
          other.usageId == this.usageId &&
          other.promotionId == this.promotionId &&
          other.orderId == this.orderId &&
          other.customerId == this.customerId &&
          other.discountAmount == this.discountAmount &&
          other.usedAt == this.usedAt);
}

class PromotionUsagesCompanion extends UpdateCompanion<PromotionUsage> {
  final Value<String> usageId;
  final Value<String> promotionId;
  final Value<String> orderId;
  final Value<String?> customerId;
  final Value<double> discountAmount;
  final Value<DateTime> usedAt;
  final Value<int> rowid;
  const PromotionUsagesCompanion({
    this.usageId = const Value.absent(),
    this.promotionId = const Value.absent(),
    this.orderId = const Value.absent(),
    this.customerId = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.usedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PromotionUsagesCompanion.insert({
    required String usageId,
    required String promotionId,
    required String orderId,
    this.customerId = const Value.absent(),
    required double discountAmount,
    this.usedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : usageId = Value(usageId),
       promotionId = Value(promotionId),
       orderId = Value(orderId),
       discountAmount = Value(discountAmount);
  static Insertable<PromotionUsage> custom({
    Expression<String>? usageId,
    Expression<String>? promotionId,
    Expression<String>? orderId,
    Expression<String>? customerId,
    Expression<double>? discountAmount,
    Expression<DateTime>? usedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (usageId != null) 'usage_id': usageId,
      if (promotionId != null) 'promotion_id': promotionId,
      if (orderId != null) 'order_id': orderId,
      if (customerId != null) 'customer_id': customerId,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (usedAt != null) 'used_at': usedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PromotionUsagesCompanion copyWith({
    Value<String>? usageId,
    Value<String>? promotionId,
    Value<String>? orderId,
    Value<String?>? customerId,
    Value<double>? discountAmount,
    Value<DateTime>? usedAt,
    Value<int>? rowid,
  }) {
    return PromotionUsagesCompanion(
      usageId: usageId ?? this.usageId,
      promotionId: promotionId ?? this.promotionId,
      orderId: orderId ?? this.orderId,
      customerId: customerId ?? this.customerId,
      discountAmount: discountAmount ?? this.discountAmount,
      usedAt: usedAt ?? this.usedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (usageId.present) {
      map['usage_id'] = Variable<String>(usageId.value);
    }
    if (promotionId.present) {
      map['promotion_id'] = Variable<String>(promotionId.value);
    }
    if (orderId.present) {
      map['order_id'] = Variable<String>(orderId.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (usedAt.present) {
      map['used_at'] = Variable<DateTime>(usedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PromotionUsagesCompanion(')
          ..write('usageId: $usageId, ')
          ..write('promotionId: $promotionId, ')
          ..write('orderId: $orderId, ')
          ..write('customerId: $customerId, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('usedAt: $usedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CouponsTable extends Coupons with TableInfo<$CouponsTable, Coupon> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CouponsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _couponIdMeta = const VerificationMeta(
    'couponId',
  );
  @override
  late final GeneratedColumn<String> couponId = GeneratedColumn<String>(
    'coupon_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _couponCodeMeta = const VerificationMeta(
    'couponCode',
  );
  @override
  late final GeneratedColumn<String> couponCode = GeneratedColumn<String>(
    'coupon_code',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _promotionIdMeta = const VerificationMeta(
    'promotionId',
  );
  @override
  late final GeneratedColumn<String> promotionId = GeneratedColumn<String>(
    'promotion_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES promotions (promotion_id)',
    ),
  );
  static const VerificationMeta _isUsedMeta = const VerificationMeta('isUsed');
  @override
  late final GeneratedColumn<bool> isUsed = GeneratedColumn<bool>(
    'is_used',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_used" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _usedByMeta = const VerificationMeta('usedBy');
  @override
  late final GeneratedColumn<String> usedBy = GeneratedColumn<String>(
    'used_by',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES customers (customer_id)',
    ),
  );
  static const VerificationMeta _usedAtMeta = const VerificationMeta('usedAt');
  @override
  late final GeneratedColumn<DateTime> usedAt = GeneratedColumn<DateTime>(
    'used_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
    'expires_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    couponId,
    couponCode,
    promotionId,
    isUsed,
    usedBy,
    usedAt,
    expiresAt,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'coupons';
  @override
  VerificationContext validateIntegrity(
    Insertable<Coupon> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('coupon_id')) {
      context.handle(
        _couponIdMeta,
        couponId.isAcceptableOrUnknown(data['coupon_id']!, _couponIdMeta),
      );
    } else if (isInserting) {
      context.missing(_couponIdMeta);
    }
    if (data.containsKey('coupon_code')) {
      context.handle(
        _couponCodeMeta,
        couponCode.isAcceptableOrUnknown(data['coupon_code']!, _couponCodeMeta),
      );
    } else if (isInserting) {
      context.missing(_couponCodeMeta);
    }
    if (data.containsKey('promotion_id')) {
      context.handle(
        _promotionIdMeta,
        promotionId.isAcceptableOrUnknown(
          data['promotion_id']!,
          _promotionIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_promotionIdMeta);
    }
    if (data.containsKey('is_used')) {
      context.handle(
        _isUsedMeta,
        isUsed.isAcceptableOrUnknown(data['is_used']!, _isUsedMeta),
      );
    }
    if (data.containsKey('used_by')) {
      context.handle(
        _usedByMeta,
        usedBy.isAcceptableOrUnknown(data['used_by']!, _usedByMeta),
      );
    }
    if (data.containsKey('used_at')) {
      context.handle(
        _usedAtMeta,
        usedAt.isAcceptableOrUnknown(data['used_at']!, _usedAtMeta),
      );
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {couponId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {couponCode},
  ];
  @override
  Coupon map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Coupon(
      couponId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}coupon_id'],
      )!,
      couponCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}coupon_code'],
      )!,
      promotionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}promotion_id'],
      )!,
      isUsed: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_used'],
      )!,
      usedBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}used_by'],
      ),
      usedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}used_at'],
      ),
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expires_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $CouponsTable createAlias(String alias) {
    return $CouponsTable(attachedDatabase, alias);
  }
}

class Coupon extends DataClass implements Insertable<Coupon> {
  final String couponId;
  final String couponCode;
  final String promotionId;
  final bool isUsed;
  final String? usedBy;
  final DateTime? usedAt;
  final DateTime? expiresAt;
  final DateTime createdAt;
  const Coupon({
    required this.couponId,
    required this.couponCode,
    required this.promotionId,
    required this.isUsed,
    this.usedBy,
    this.usedAt,
    this.expiresAt,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['coupon_id'] = Variable<String>(couponId);
    map['coupon_code'] = Variable<String>(couponCode);
    map['promotion_id'] = Variable<String>(promotionId);
    map['is_used'] = Variable<bool>(isUsed);
    if (!nullToAbsent || usedBy != null) {
      map['used_by'] = Variable<String>(usedBy);
    }
    if (!nullToAbsent || usedAt != null) {
      map['used_at'] = Variable<DateTime>(usedAt);
    }
    if (!nullToAbsent || expiresAt != null) {
      map['expires_at'] = Variable<DateTime>(expiresAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  CouponsCompanion toCompanion(bool nullToAbsent) {
    return CouponsCompanion(
      couponId: Value(couponId),
      couponCode: Value(couponCode),
      promotionId: Value(promotionId),
      isUsed: Value(isUsed),
      usedBy: usedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(usedBy),
      usedAt: usedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(usedAt),
      expiresAt: expiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(expiresAt),
      createdAt: Value(createdAt),
    );
  }

  factory Coupon.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Coupon(
      couponId: serializer.fromJson<String>(json['couponId']),
      couponCode: serializer.fromJson<String>(json['couponCode']),
      promotionId: serializer.fromJson<String>(json['promotionId']),
      isUsed: serializer.fromJson<bool>(json['isUsed']),
      usedBy: serializer.fromJson<String?>(json['usedBy']),
      usedAt: serializer.fromJson<DateTime?>(json['usedAt']),
      expiresAt: serializer.fromJson<DateTime?>(json['expiresAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'couponId': serializer.toJson<String>(couponId),
      'couponCode': serializer.toJson<String>(couponCode),
      'promotionId': serializer.toJson<String>(promotionId),
      'isUsed': serializer.toJson<bool>(isUsed),
      'usedBy': serializer.toJson<String?>(usedBy),
      'usedAt': serializer.toJson<DateTime?>(usedAt),
      'expiresAt': serializer.toJson<DateTime?>(expiresAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Coupon copyWith({
    String? couponId,
    String? couponCode,
    String? promotionId,
    bool? isUsed,
    Value<String?> usedBy = const Value.absent(),
    Value<DateTime?> usedAt = const Value.absent(),
    Value<DateTime?> expiresAt = const Value.absent(),
    DateTime? createdAt,
  }) => Coupon(
    couponId: couponId ?? this.couponId,
    couponCode: couponCode ?? this.couponCode,
    promotionId: promotionId ?? this.promotionId,
    isUsed: isUsed ?? this.isUsed,
    usedBy: usedBy.present ? usedBy.value : this.usedBy,
    usedAt: usedAt.present ? usedAt.value : this.usedAt,
    expiresAt: expiresAt.present ? expiresAt.value : this.expiresAt,
    createdAt: createdAt ?? this.createdAt,
  );
  Coupon copyWithCompanion(CouponsCompanion data) {
    return Coupon(
      couponId: data.couponId.present ? data.couponId.value : this.couponId,
      couponCode: data.couponCode.present
          ? data.couponCode.value
          : this.couponCode,
      promotionId: data.promotionId.present
          ? data.promotionId.value
          : this.promotionId,
      isUsed: data.isUsed.present ? data.isUsed.value : this.isUsed,
      usedBy: data.usedBy.present ? data.usedBy.value : this.usedBy,
      usedAt: data.usedAt.present ? data.usedAt.value : this.usedAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Coupon(')
          ..write('couponId: $couponId, ')
          ..write('couponCode: $couponCode, ')
          ..write('promotionId: $promotionId, ')
          ..write('isUsed: $isUsed, ')
          ..write('usedBy: $usedBy, ')
          ..write('usedAt: $usedAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    couponId,
    couponCode,
    promotionId,
    isUsed,
    usedBy,
    usedAt,
    expiresAt,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Coupon &&
          other.couponId == this.couponId &&
          other.couponCode == this.couponCode &&
          other.promotionId == this.promotionId &&
          other.isUsed == this.isUsed &&
          other.usedBy == this.usedBy &&
          other.usedAt == this.usedAt &&
          other.expiresAt == this.expiresAt &&
          other.createdAt == this.createdAt);
}

class CouponsCompanion extends UpdateCompanion<Coupon> {
  final Value<String> couponId;
  final Value<String> couponCode;
  final Value<String> promotionId;
  final Value<bool> isUsed;
  final Value<String?> usedBy;
  final Value<DateTime?> usedAt;
  final Value<DateTime?> expiresAt;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const CouponsCompanion({
    this.couponId = const Value.absent(),
    this.couponCode = const Value.absent(),
    this.promotionId = const Value.absent(),
    this.isUsed = const Value.absent(),
    this.usedBy = const Value.absent(),
    this.usedAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CouponsCompanion.insert({
    required String couponId,
    required String couponCode,
    required String promotionId,
    this.isUsed = const Value.absent(),
    this.usedBy = const Value.absent(),
    this.usedAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : couponId = Value(couponId),
       couponCode = Value(couponCode),
       promotionId = Value(promotionId);
  static Insertable<Coupon> custom({
    Expression<String>? couponId,
    Expression<String>? couponCode,
    Expression<String>? promotionId,
    Expression<bool>? isUsed,
    Expression<String>? usedBy,
    Expression<DateTime>? usedAt,
    Expression<DateTime>? expiresAt,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (couponId != null) 'coupon_id': couponId,
      if (couponCode != null) 'coupon_code': couponCode,
      if (promotionId != null) 'promotion_id': promotionId,
      if (isUsed != null) 'is_used': isUsed,
      if (usedBy != null) 'used_by': usedBy,
      if (usedAt != null) 'used_at': usedAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CouponsCompanion copyWith({
    Value<String>? couponId,
    Value<String>? couponCode,
    Value<String>? promotionId,
    Value<bool>? isUsed,
    Value<String?>? usedBy,
    Value<DateTime?>? usedAt,
    Value<DateTime?>? expiresAt,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return CouponsCompanion(
      couponId: couponId ?? this.couponId,
      couponCode: couponCode ?? this.couponCode,
      promotionId: promotionId ?? this.promotionId,
      isUsed: isUsed ?? this.isUsed,
      usedBy: usedBy ?? this.usedBy,
      usedAt: usedAt ?? this.usedAt,
      expiresAt: expiresAt ?? this.expiresAt,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (couponId.present) {
      map['coupon_id'] = Variable<String>(couponId.value);
    }
    if (couponCode.present) {
      map['coupon_code'] = Variable<String>(couponCode.value);
    }
    if (promotionId.present) {
      map['promotion_id'] = Variable<String>(promotionId.value);
    }
    if (isUsed.present) {
      map['is_used'] = Variable<bool>(isUsed.value);
    }
    if (usedBy.present) {
      map['used_by'] = Variable<String>(usedBy.value);
    }
    if (usedAt.present) {
      map['used_at'] = Variable<DateTime>(usedAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CouponsCompanion(')
          ..write('couponId: $couponId, ')
          ..write('couponCode: $couponCode, ')
          ..write('promotionId: $promotionId, ')
          ..write('isUsed: $isUsed, ')
          ..write('usedBy: $usedBy, ')
          ..write('usedAt: $usedAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ArInvoicesTable extends ArInvoices
    with TableInfo<$ArInvoicesTable, ArInvoice> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ArInvoicesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _invoiceIdMeta = const VerificationMeta(
    'invoiceId',
  );
  @override
  late final GeneratedColumn<String> invoiceId = GeneratedColumn<String>(
    'invoice_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _invoiceNoMeta = const VerificationMeta(
    'invoiceNo',
  );
  @override
  late final GeneratedColumn<String> invoiceNo = GeneratedColumn<String>(
    'invoice_no',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _invoiceDateMeta = const VerificationMeta(
    'invoiceDate',
  );
  @override
  late final GeneratedColumn<DateTime> invoiceDate = GeneratedColumn<DateTime>(
    'invoice_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dueDateMeta = const VerificationMeta(
    'dueDate',
  );
  @override
  late final GeneratedColumn<DateTime> dueDate = GeneratedColumn<DateTime>(
    'due_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _customerIdMeta = const VerificationMeta(
    'customerId',
  );
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
    'customer_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES customers (customer_id)',
    ),
  );
  static const VerificationMeta _customerNameMeta = const VerificationMeta(
    'customerName',
  );
  @override
  late final GeneratedColumn<String> customerName = GeneratedColumn<String>(
    'customer_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 300),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalAmountMeta = const VerificationMeta(
    'totalAmount',
  );
  @override
  late final GeneratedColumn<double> totalAmount = GeneratedColumn<double>(
    'total_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _paidAmountMeta = const VerificationMeta(
    'paidAmount',
  );
  @override
  late final GeneratedColumn<double> paidAmount = GeneratedColumn<double>(
    'paid_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _referenceTypeMeta = const VerificationMeta(
    'referenceType',
  );
  @override
  late final GeneratedColumn<String> referenceType = GeneratedColumn<String>(
    'reference_type',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _referenceIdMeta = const VerificationMeta(
    'referenceId',
  );
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
    'reference_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('UNPAID'),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    invoiceId,
    invoiceNo,
    invoiceDate,
    dueDate,
    customerId,
    customerName,
    totalAmount,
    paidAmount,
    referenceType,
    referenceId,
    status,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ar_invoices';
  @override
  VerificationContext validateIntegrity(
    Insertable<ArInvoice> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('invoice_id')) {
      context.handle(
        _invoiceIdMeta,
        invoiceId.isAcceptableOrUnknown(data['invoice_id']!, _invoiceIdMeta),
      );
    } else if (isInserting) {
      context.missing(_invoiceIdMeta);
    }
    if (data.containsKey('invoice_no')) {
      context.handle(
        _invoiceNoMeta,
        invoiceNo.isAcceptableOrUnknown(data['invoice_no']!, _invoiceNoMeta),
      );
    } else if (isInserting) {
      context.missing(_invoiceNoMeta);
    }
    if (data.containsKey('invoice_date')) {
      context.handle(
        _invoiceDateMeta,
        invoiceDate.isAcceptableOrUnknown(
          data['invoice_date']!,
          _invoiceDateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_invoiceDateMeta);
    }
    if (data.containsKey('due_date')) {
      context.handle(
        _dueDateMeta,
        dueDate.isAcceptableOrUnknown(data['due_date']!, _dueDateMeta),
      );
    }
    if (data.containsKey('customer_id')) {
      context.handle(
        _customerIdMeta,
        customerId.isAcceptableOrUnknown(data['customer_id']!, _customerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('customer_name')) {
      context.handle(
        _customerNameMeta,
        customerName.isAcceptableOrUnknown(
          data['customer_name']!,
          _customerNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_customerNameMeta);
    }
    if (data.containsKey('total_amount')) {
      context.handle(
        _totalAmountMeta,
        totalAmount.isAcceptableOrUnknown(
          data['total_amount']!,
          _totalAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalAmountMeta);
    }
    if (data.containsKey('paid_amount')) {
      context.handle(
        _paidAmountMeta,
        paidAmount.isAcceptableOrUnknown(data['paid_amount']!, _paidAmountMeta),
      );
    }
    if (data.containsKey('reference_type')) {
      context.handle(
        _referenceTypeMeta,
        referenceType.isAcceptableOrUnknown(
          data['reference_type']!,
          _referenceTypeMeta,
        ),
      );
    }
    if (data.containsKey('reference_id')) {
      context.handle(
        _referenceIdMeta,
        referenceId.isAcceptableOrUnknown(
          data['reference_id']!,
          _referenceIdMeta,
        ),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {invoiceId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {invoiceNo},
  ];
  @override
  ArInvoice map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ArInvoice(
      invoiceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}invoice_id'],
      )!,
      invoiceNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}invoice_no'],
      )!,
      invoiceDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}invoice_date'],
      )!,
      dueDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}due_date'],
      ),
      customerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_id'],
      )!,
      customerName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_name'],
      )!,
      totalAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_amount'],
      )!,
      paidAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}paid_amount'],
      )!,
      referenceType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reference_type'],
      ),
      referenceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reference_id'],
      ),
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ArInvoicesTable createAlias(String alias) {
    return $ArInvoicesTable(attachedDatabase, alias);
  }
}

class ArInvoice extends DataClass implements Insertable<ArInvoice> {
  final String invoiceId;
  final String invoiceNo;
  final DateTime invoiceDate;
  final DateTime? dueDate;
  final String customerId;
  final String customerName;
  final double totalAmount;
  final double paidAmount;
  final String? referenceType;
  final String? referenceId;
  final String status;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ArInvoice({
    required this.invoiceId,
    required this.invoiceNo,
    required this.invoiceDate,
    this.dueDate,
    required this.customerId,
    required this.customerName,
    required this.totalAmount,
    required this.paidAmount,
    this.referenceType,
    this.referenceId,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['invoice_id'] = Variable<String>(invoiceId);
    map['invoice_no'] = Variable<String>(invoiceNo);
    map['invoice_date'] = Variable<DateTime>(invoiceDate);
    if (!nullToAbsent || dueDate != null) {
      map['due_date'] = Variable<DateTime>(dueDate);
    }
    map['customer_id'] = Variable<String>(customerId);
    map['customer_name'] = Variable<String>(customerName);
    map['total_amount'] = Variable<double>(totalAmount);
    map['paid_amount'] = Variable<double>(paidAmount);
    if (!nullToAbsent || referenceType != null) {
      map['reference_type'] = Variable<String>(referenceType);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    map['status'] = Variable<String>(status);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ArInvoicesCompanion toCompanion(bool nullToAbsent) {
    return ArInvoicesCompanion(
      invoiceId: Value(invoiceId),
      invoiceNo: Value(invoiceNo),
      invoiceDate: Value(invoiceDate),
      dueDate: dueDate == null && nullToAbsent
          ? const Value.absent()
          : Value(dueDate),
      customerId: Value(customerId),
      customerName: Value(customerName),
      totalAmount: Value(totalAmount),
      paidAmount: Value(paidAmount),
      referenceType: referenceType == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceType),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      status: Value(status),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ArInvoice.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ArInvoice(
      invoiceId: serializer.fromJson<String>(json['invoiceId']),
      invoiceNo: serializer.fromJson<String>(json['invoiceNo']),
      invoiceDate: serializer.fromJson<DateTime>(json['invoiceDate']),
      dueDate: serializer.fromJson<DateTime?>(json['dueDate']),
      customerId: serializer.fromJson<String>(json['customerId']),
      customerName: serializer.fromJson<String>(json['customerName']),
      totalAmount: serializer.fromJson<double>(json['totalAmount']),
      paidAmount: serializer.fromJson<double>(json['paidAmount']),
      referenceType: serializer.fromJson<String?>(json['referenceType']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      status: serializer.fromJson<String>(json['status']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'invoiceId': serializer.toJson<String>(invoiceId),
      'invoiceNo': serializer.toJson<String>(invoiceNo),
      'invoiceDate': serializer.toJson<DateTime>(invoiceDate),
      'dueDate': serializer.toJson<DateTime?>(dueDate),
      'customerId': serializer.toJson<String>(customerId),
      'customerName': serializer.toJson<String>(customerName),
      'totalAmount': serializer.toJson<double>(totalAmount),
      'paidAmount': serializer.toJson<double>(paidAmount),
      'referenceType': serializer.toJson<String?>(referenceType),
      'referenceId': serializer.toJson<String?>(referenceId),
      'status': serializer.toJson<String>(status),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ArInvoice copyWith({
    String? invoiceId,
    String? invoiceNo,
    DateTime? invoiceDate,
    Value<DateTime?> dueDate = const Value.absent(),
    String? customerId,
    String? customerName,
    double? totalAmount,
    double? paidAmount,
    Value<String?> referenceType = const Value.absent(),
    Value<String?> referenceId = const Value.absent(),
    String? status,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => ArInvoice(
    invoiceId: invoiceId ?? this.invoiceId,
    invoiceNo: invoiceNo ?? this.invoiceNo,
    invoiceDate: invoiceDate ?? this.invoiceDate,
    dueDate: dueDate.present ? dueDate.value : this.dueDate,
    customerId: customerId ?? this.customerId,
    customerName: customerName ?? this.customerName,
    totalAmount: totalAmount ?? this.totalAmount,
    paidAmount: paidAmount ?? this.paidAmount,
    referenceType: referenceType.present
        ? referenceType.value
        : this.referenceType,
    referenceId: referenceId.present ? referenceId.value : this.referenceId,
    status: status ?? this.status,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ArInvoice copyWithCompanion(ArInvoicesCompanion data) {
    return ArInvoice(
      invoiceId: data.invoiceId.present ? data.invoiceId.value : this.invoiceId,
      invoiceNo: data.invoiceNo.present ? data.invoiceNo.value : this.invoiceNo,
      invoiceDate: data.invoiceDate.present
          ? data.invoiceDate.value
          : this.invoiceDate,
      dueDate: data.dueDate.present ? data.dueDate.value : this.dueDate,
      customerId: data.customerId.present
          ? data.customerId.value
          : this.customerId,
      customerName: data.customerName.present
          ? data.customerName.value
          : this.customerName,
      totalAmount: data.totalAmount.present
          ? data.totalAmount.value
          : this.totalAmount,
      paidAmount: data.paidAmount.present
          ? data.paidAmount.value
          : this.paidAmount,
      referenceType: data.referenceType.present
          ? data.referenceType.value
          : this.referenceType,
      referenceId: data.referenceId.present
          ? data.referenceId.value
          : this.referenceId,
      status: data.status.present ? data.status.value : this.status,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ArInvoice(')
          ..write('invoiceId: $invoiceId, ')
          ..write('invoiceNo: $invoiceNo, ')
          ..write('invoiceDate: $invoiceDate, ')
          ..write('dueDate: $dueDate, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('paidAmount: $paidAmount, ')
          ..write('referenceType: $referenceType, ')
          ..write('referenceId: $referenceId, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    invoiceId,
    invoiceNo,
    invoiceDate,
    dueDate,
    customerId,
    customerName,
    totalAmount,
    paidAmount,
    referenceType,
    referenceId,
    status,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ArInvoice &&
          other.invoiceId == this.invoiceId &&
          other.invoiceNo == this.invoiceNo &&
          other.invoiceDate == this.invoiceDate &&
          other.dueDate == this.dueDate &&
          other.customerId == this.customerId &&
          other.customerName == this.customerName &&
          other.totalAmount == this.totalAmount &&
          other.paidAmount == this.paidAmount &&
          other.referenceType == this.referenceType &&
          other.referenceId == this.referenceId &&
          other.status == this.status &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ArInvoicesCompanion extends UpdateCompanion<ArInvoice> {
  final Value<String> invoiceId;
  final Value<String> invoiceNo;
  final Value<DateTime> invoiceDate;
  final Value<DateTime?> dueDate;
  final Value<String> customerId;
  final Value<String> customerName;
  final Value<double> totalAmount;
  final Value<double> paidAmount;
  final Value<String?> referenceType;
  final Value<String?> referenceId;
  final Value<String> status;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const ArInvoicesCompanion({
    this.invoiceId = const Value.absent(),
    this.invoiceNo = const Value.absent(),
    this.invoiceDate = const Value.absent(),
    this.dueDate = const Value.absent(),
    this.customerId = const Value.absent(),
    this.customerName = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.paidAmount = const Value.absent(),
    this.referenceType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ArInvoicesCompanion.insert({
    required String invoiceId,
    required String invoiceNo,
    required DateTime invoiceDate,
    this.dueDate = const Value.absent(),
    required String customerId,
    required String customerName,
    required double totalAmount,
    this.paidAmount = const Value.absent(),
    this.referenceType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : invoiceId = Value(invoiceId),
       invoiceNo = Value(invoiceNo),
       invoiceDate = Value(invoiceDate),
       customerId = Value(customerId),
       customerName = Value(customerName),
       totalAmount = Value(totalAmount);
  static Insertable<ArInvoice> custom({
    Expression<String>? invoiceId,
    Expression<String>? invoiceNo,
    Expression<DateTime>? invoiceDate,
    Expression<DateTime>? dueDate,
    Expression<String>? customerId,
    Expression<String>? customerName,
    Expression<double>? totalAmount,
    Expression<double>? paidAmount,
    Expression<String>? referenceType,
    Expression<String>? referenceId,
    Expression<String>? status,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (invoiceId != null) 'invoice_id': invoiceId,
      if (invoiceNo != null) 'invoice_no': invoiceNo,
      if (invoiceDate != null) 'invoice_date': invoiceDate,
      if (dueDate != null) 'due_date': dueDate,
      if (customerId != null) 'customer_id': customerId,
      if (customerName != null) 'customer_name': customerName,
      if (totalAmount != null) 'total_amount': totalAmount,
      if (paidAmount != null) 'paid_amount': paidAmount,
      if (referenceType != null) 'reference_type': referenceType,
      if (referenceId != null) 'reference_id': referenceId,
      if (status != null) 'status': status,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ArInvoicesCompanion copyWith({
    Value<String>? invoiceId,
    Value<String>? invoiceNo,
    Value<DateTime>? invoiceDate,
    Value<DateTime?>? dueDate,
    Value<String>? customerId,
    Value<String>? customerName,
    Value<double>? totalAmount,
    Value<double>? paidAmount,
    Value<String?>? referenceType,
    Value<String?>? referenceId,
    Value<String>? status,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return ArInvoicesCompanion(
      invoiceId: invoiceId ?? this.invoiceId,
      invoiceNo: invoiceNo ?? this.invoiceNo,
      invoiceDate: invoiceDate ?? this.invoiceDate,
      dueDate: dueDate ?? this.dueDate,
      customerId: customerId ?? this.customerId,
      customerName: customerName ?? this.customerName,
      totalAmount: totalAmount ?? this.totalAmount,
      paidAmount: paidAmount ?? this.paidAmount,
      referenceType: referenceType ?? this.referenceType,
      referenceId: referenceId ?? this.referenceId,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (invoiceId.present) {
      map['invoice_id'] = Variable<String>(invoiceId.value);
    }
    if (invoiceNo.present) {
      map['invoice_no'] = Variable<String>(invoiceNo.value);
    }
    if (invoiceDate.present) {
      map['invoice_date'] = Variable<DateTime>(invoiceDate.value);
    }
    if (dueDate.present) {
      map['due_date'] = Variable<DateTime>(dueDate.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (customerName.present) {
      map['customer_name'] = Variable<String>(customerName.value);
    }
    if (totalAmount.present) {
      map['total_amount'] = Variable<double>(totalAmount.value);
    }
    if (paidAmount.present) {
      map['paid_amount'] = Variable<double>(paidAmount.value);
    }
    if (referenceType.present) {
      map['reference_type'] = Variable<String>(referenceType.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ArInvoicesCompanion(')
          ..write('invoiceId: $invoiceId, ')
          ..write('invoiceNo: $invoiceNo, ')
          ..write('invoiceDate: $invoiceDate, ')
          ..write('dueDate: $dueDate, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('paidAmount: $paidAmount, ')
          ..write('referenceType: $referenceType, ')
          ..write('referenceId: $referenceId, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ArReceiptsTable extends ArReceipts
    with TableInfo<$ArReceiptsTable, ArReceipt> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ArReceiptsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _receiptIdMeta = const VerificationMeta(
    'receiptId',
  );
  @override
  late final GeneratedColumn<String> receiptId = GeneratedColumn<String>(
    'receipt_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _receiptNoMeta = const VerificationMeta(
    'receiptNo',
  );
  @override
  late final GeneratedColumn<String> receiptNo = GeneratedColumn<String>(
    'receipt_no',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _receiptDateMeta = const VerificationMeta(
    'receiptDate',
  );
  @override
  late final GeneratedColumn<DateTime> receiptDate = GeneratedColumn<DateTime>(
    'receipt_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _customerIdMeta = const VerificationMeta(
    'customerId',
  );
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
    'customer_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES customers (customer_id)',
    ),
  );
  static const VerificationMeta _totalAmountMeta = const VerificationMeta(
    'totalAmount',
  );
  @override
  late final GeneratedColumn<double> totalAmount = GeneratedColumn<double>(
    'total_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _paymentMethodMeta = const VerificationMeta(
    'paymentMethod',
  );
  @override
  late final GeneratedColumn<String> paymentMethod = GeneratedColumn<String>(
    'payment_method',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('CASH'),
  );
  static const VerificationMeta _bankNameMeta = const VerificationMeta(
    'bankName',
  );
  @override
  late final GeneratedColumn<String> bankName = GeneratedColumn<String>(
    'bank_name',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _chequeNoMeta = const VerificationMeta(
    'chequeNo',
  );
  @override
  late final GeneratedColumn<String> chequeNo = GeneratedColumn<String>(
    'cheque_no',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _chequeDateMeta = const VerificationMeta(
    'chequeDate',
  );
  @override
  late final GeneratedColumn<DateTime> chequeDate = GeneratedColumn<DateTime>(
    'cheque_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _transferRefMeta = const VerificationMeta(
    'transferRef',
  );
  @override
  late final GeneratedColumn<String> transferRef = GeneratedColumn<String>(
    'transfer_ref',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (user_id)',
    ),
  );
  static const VerificationMeta _remarkMeta = const VerificationMeta('remark');
  @override
  late final GeneratedColumn<String> remark = GeneratedColumn<String>(
    'remark',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    receiptId,
    receiptNo,
    receiptDate,
    customerId,
    totalAmount,
    paymentMethod,
    bankName,
    chequeNo,
    chequeDate,
    transferRef,
    userId,
    remark,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ar_receipts';
  @override
  VerificationContext validateIntegrity(
    Insertable<ArReceipt> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('receipt_id')) {
      context.handle(
        _receiptIdMeta,
        receiptId.isAcceptableOrUnknown(data['receipt_id']!, _receiptIdMeta),
      );
    } else if (isInserting) {
      context.missing(_receiptIdMeta);
    }
    if (data.containsKey('receipt_no')) {
      context.handle(
        _receiptNoMeta,
        receiptNo.isAcceptableOrUnknown(data['receipt_no']!, _receiptNoMeta),
      );
    } else if (isInserting) {
      context.missing(_receiptNoMeta);
    }
    if (data.containsKey('receipt_date')) {
      context.handle(
        _receiptDateMeta,
        receiptDate.isAcceptableOrUnknown(
          data['receipt_date']!,
          _receiptDateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_receiptDateMeta);
    }
    if (data.containsKey('customer_id')) {
      context.handle(
        _customerIdMeta,
        customerId.isAcceptableOrUnknown(data['customer_id']!, _customerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('total_amount')) {
      context.handle(
        _totalAmountMeta,
        totalAmount.isAcceptableOrUnknown(
          data['total_amount']!,
          _totalAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalAmountMeta);
    }
    if (data.containsKey('payment_method')) {
      context.handle(
        _paymentMethodMeta,
        paymentMethod.isAcceptableOrUnknown(
          data['payment_method']!,
          _paymentMethodMeta,
        ),
      );
    }
    if (data.containsKey('bank_name')) {
      context.handle(
        _bankNameMeta,
        bankName.isAcceptableOrUnknown(data['bank_name']!, _bankNameMeta),
      );
    }
    if (data.containsKey('cheque_no')) {
      context.handle(
        _chequeNoMeta,
        chequeNo.isAcceptableOrUnknown(data['cheque_no']!, _chequeNoMeta),
      );
    }
    if (data.containsKey('cheque_date')) {
      context.handle(
        _chequeDateMeta,
        chequeDate.isAcceptableOrUnknown(data['cheque_date']!, _chequeDateMeta),
      );
    }
    if (data.containsKey('transfer_ref')) {
      context.handle(
        _transferRefMeta,
        transferRef.isAcceptableOrUnknown(
          data['transfer_ref']!,
          _transferRefMeta,
        ),
      );
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('remark')) {
      context.handle(
        _remarkMeta,
        remark.isAcceptableOrUnknown(data['remark']!, _remarkMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {receiptId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {receiptNo},
  ];
  @override
  ArReceipt map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ArReceipt(
      receiptId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receipt_id'],
      )!,
      receiptNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receipt_no'],
      )!,
      receiptDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}receipt_date'],
      )!,
      customerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_id'],
      )!,
      totalAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_amount'],
      )!,
      paymentMethod: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payment_method'],
      )!,
      bankName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bank_name'],
      ),
      chequeNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cheque_no'],
      ),
      chequeDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}cheque_date'],
      ),
      transferRef: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}transfer_ref'],
      ),
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      remark: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}remark'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ArReceiptsTable createAlias(String alias) {
    return $ArReceiptsTable(attachedDatabase, alias);
  }
}

class ArReceipt extends DataClass implements Insertable<ArReceipt> {
  final String receiptId;
  final String receiptNo;
  final DateTime receiptDate;
  final String customerId;
  final double totalAmount;
  final String paymentMethod;
  final String? bankName;
  final String? chequeNo;
  final DateTime? chequeDate;
  final String? transferRef;
  final String userId;
  final String? remark;
  final DateTime createdAt;
  const ArReceipt({
    required this.receiptId,
    required this.receiptNo,
    required this.receiptDate,
    required this.customerId,
    required this.totalAmount,
    required this.paymentMethod,
    this.bankName,
    this.chequeNo,
    this.chequeDate,
    this.transferRef,
    required this.userId,
    this.remark,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['receipt_id'] = Variable<String>(receiptId);
    map['receipt_no'] = Variable<String>(receiptNo);
    map['receipt_date'] = Variable<DateTime>(receiptDate);
    map['customer_id'] = Variable<String>(customerId);
    map['total_amount'] = Variable<double>(totalAmount);
    map['payment_method'] = Variable<String>(paymentMethod);
    if (!nullToAbsent || bankName != null) {
      map['bank_name'] = Variable<String>(bankName);
    }
    if (!nullToAbsent || chequeNo != null) {
      map['cheque_no'] = Variable<String>(chequeNo);
    }
    if (!nullToAbsent || chequeDate != null) {
      map['cheque_date'] = Variable<DateTime>(chequeDate);
    }
    if (!nullToAbsent || transferRef != null) {
      map['transfer_ref'] = Variable<String>(transferRef);
    }
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || remark != null) {
      map['remark'] = Variable<String>(remark);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ArReceiptsCompanion toCompanion(bool nullToAbsent) {
    return ArReceiptsCompanion(
      receiptId: Value(receiptId),
      receiptNo: Value(receiptNo),
      receiptDate: Value(receiptDate),
      customerId: Value(customerId),
      totalAmount: Value(totalAmount),
      paymentMethod: Value(paymentMethod),
      bankName: bankName == null && nullToAbsent
          ? const Value.absent()
          : Value(bankName),
      chequeNo: chequeNo == null && nullToAbsent
          ? const Value.absent()
          : Value(chequeNo),
      chequeDate: chequeDate == null && nullToAbsent
          ? const Value.absent()
          : Value(chequeDate),
      transferRef: transferRef == null && nullToAbsent
          ? const Value.absent()
          : Value(transferRef),
      userId: Value(userId),
      remark: remark == null && nullToAbsent
          ? const Value.absent()
          : Value(remark),
      createdAt: Value(createdAt),
    );
  }

  factory ArReceipt.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ArReceipt(
      receiptId: serializer.fromJson<String>(json['receiptId']),
      receiptNo: serializer.fromJson<String>(json['receiptNo']),
      receiptDate: serializer.fromJson<DateTime>(json['receiptDate']),
      customerId: serializer.fromJson<String>(json['customerId']),
      totalAmount: serializer.fromJson<double>(json['totalAmount']),
      paymentMethod: serializer.fromJson<String>(json['paymentMethod']),
      bankName: serializer.fromJson<String?>(json['bankName']),
      chequeNo: serializer.fromJson<String?>(json['chequeNo']),
      chequeDate: serializer.fromJson<DateTime?>(json['chequeDate']),
      transferRef: serializer.fromJson<String?>(json['transferRef']),
      userId: serializer.fromJson<String>(json['userId']),
      remark: serializer.fromJson<String?>(json['remark']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'receiptId': serializer.toJson<String>(receiptId),
      'receiptNo': serializer.toJson<String>(receiptNo),
      'receiptDate': serializer.toJson<DateTime>(receiptDate),
      'customerId': serializer.toJson<String>(customerId),
      'totalAmount': serializer.toJson<double>(totalAmount),
      'paymentMethod': serializer.toJson<String>(paymentMethod),
      'bankName': serializer.toJson<String?>(bankName),
      'chequeNo': serializer.toJson<String?>(chequeNo),
      'chequeDate': serializer.toJson<DateTime?>(chequeDate),
      'transferRef': serializer.toJson<String?>(transferRef),
      'userId': serializer.toJson<String>(userId),
      'remark': serializer.toJson<String?>(remark),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  ArReceipt copyWith({
    String? receiptId,
    String? receiptNo,
    DateTime? receiptDate,
    String? customerId,
    double? totalAmount,
    String? paymentMethod,
    Value<String?> bankName = const Value.absent(),
    Value<String?> chequeNo = const Value.absent(),
    Value<DateTime?> chequeDate = const Value.absent(),
    Value<String?> transferRef = const Value.absent(),
    String? userId,
    Value<String?> remark = const Value.absent(),
    DateTime? createdAt,
  }) => ArReceipt(
    receiptId: receiptId ?? this.receiptId,
    receiptNo: receiptNo ?? this.receiptNo,
    receiptDate: receiptDate ?? this.receiptDate,
    customerId: customerId ?? this.customerId,
    totalAmount: totalAmount ?? this.totalAmount,
    paymentMethod: paymentMethod ?? this.paymentMethod,
    bankName: bankName.present ? bankName.value : this.bankName,
    chequeNo: chequeNo.present ? chequeNo.value : this.chequeNo,
    chequeDate: chequeDate.present ? chequeDate.value : this.chequeDate,
    transferRef: transferRef.present ? transferRef.value : this.transferRef,
    userId: userId ?? this.userId,
    remark: remark.present ? remark.value : this.remark,
    createdAt: createdAt ?? this.createdAt,
  );
  ArReceipt copyWithCompanion(ArReceiptsCompanion data) {
    return ArReceipt(
      receiptId: data.receiptId.present ? data.receiptId.value : this.receiptId,
      receiptNo: data.receiptNo.present ? data.receiptNo.value : this.receiptNo,
      receiptDate: data.receiptDate.present
          ? data.receiptDate.value
          : this.receiptDate,
      customerId: data.customerId.present
          ? data.customerId.value
          : this.customerId,
      totalAmount: data.totalAmount.present
          ? data.totalAmount.value
          : this.totalAmount,
      paymentMethod: data.paymentMethod.present
          ? data.paymentMethod.value
          : this.paymentMethod,
      bankName: data.bankName.present ? data.bankName.value : this.bankName,
      chequeNo: data.chequeNo.present ? data.chequeNo.value : this.chequeNo,
      chequeDate: data.chequeDate.present
          ? data.chequeDate.value
          : this.chequeDate,
      transferRef: data.transferRef.present
          ? data.transferRef.value
          : this.transferRef,
      userId: data.userId.present ? data.userId.value : this.userId,
      remark: data.remark.present ? data.remark.value : this.remark,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ArReceipt(')
          ..write('receiptId: $receiptId, ')
          ..write('receiptNo: $receiptNo, ')
          ..write('receiptDate: $receiptDate, ')
          ..write('customerId: $customerId, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('bankName: $bankName, ')
          ..write('chequeNo: $chequeNo, ')
          ..write('chequeDate: $chequeDate, ')
          ..write('transferRef: $transferRef, ')
          ..write('userId: $userId, ')
          ..write('remark: $remark, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    receiptId,
    receiptNo,
    receiptDate,
    customerId,
    totalAmount,
    paymentMethod,
    bankName,
    chequeNo,
    chequeDate,
    transferRef,
    userId,
    remark,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ArReceipt &&
          other.receiptId == this.receiptId &&
          other.receiptNo == this.receiptNo &&
          other.receiptDate == this.receiptDate &&
          other.customerId == this.customerId &&
          other.totalAmount == this.totalAmount &&
          other.paymentMethod == this.paymentMethod &&
          other.bankName == this.bankName &&
          other.chequeNo == this.chequeNo &&
          other.chequeDate == this.chequeDate &&
          other.transferRef == this.transferRef &&
          other.userId == this.userId &&
          other.remark == this.remark &&
          other.createdAt == this.createdAt);
}

class ArReceiptsCompanion extends UpdateCompanion<ArReceipt> {
  final Value<String> receiptId;
  final Value<String> receiptNo;
  final Value<DateTime> receiptDate;
  final Value<String> customerId;
  final Value<double> totalAmount;
  final Value<String> paymentMethod;
  final Value<String?> bankName;
  final Value<String?> chequeNo;
  final Value<DateTime?> chequeDate;
  final Value<String?> transferRef;
  final Value<String> userId;
  final Value<String?> remark;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ArReceiptsCompanion({
    this.receiptId = const Value.absent(),
    this.receiptNo = const Value.absent(),
    this.receiptDate = const Value.absent(),
    this.customerId = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.paymentMethod = const Value.absent(),
    this.bankName = const Value.absent(),
    this.chequeNo = const Value.absent(),
    this.chequeDate = const Value.absent(),
    this.transferRef = const Value.absent(),
    this.userId = const Value.absent(),
    this.remark = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ArReceiptsCompanion.insert({
    required String receiptId,
    required String receiptNo,
    required DateTime receiptDate,
    required String customerId,
    required double totalAmount,
    this.paymentMethod = const Value.absent(),
    this.bankName = const Value.absent(),
    this.chequeNo = const Value.absent(),
    this.chequeDate = const Value.absent(),
    this.transferRef = const Value.absent(),
    required String userId,
    this.remark = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : receiptId = Value(receiptId),
       receiptNo = Value(receiptNo),
       receiptDate = Value(receiptDate),
       customerId = Value(customerId),
       totalAmount = Value(totalAmount),
       userId = Value(userId);
  static Insertable<ArReceipt> custom({
    Expression<String>? receiptId,
    Expression<String>? receiptNo,
    Expression<DateTime>? receiptDate,
    Expression<String>? customerId,
    Expression<double>? totalAmount,
    Expression<String>? paymentMethod,
    Expression<String>? bankName,
    Expression<String>? chequeNo,
    Expression<DateTime>? chequeDate,
    Expression<String>? transferRef,
    Expression<String>? userId,
    Expression<String>? remark,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (receiptId != null) 'receipt_id': receiptId,
      if (receiptNo != null) 'receipt_no': receiptNo,
      if (receiptDate != null) 'receipt_date': receiptDate,
      if (customerId != null) 'customer_id': customerId,
      if (totalAmount != null) 'total_amount': totalAmount,
      if (paymentMethod != null) 'payment_method': paymentMethod,
      if (bankName != null) 'bank_name': bankName,
      if (chequeNo != null) 'cheque_no': chequeNo,
      if (chequeDate != null) 'cheque_date': chequeDate,
      if (transferRef != null) 'transfer_ref': transferRef,
      if (userId != null) 'user_id': userId,
      if (remark != null) 'remark': remark,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ArReceiptsCompanion copyWith({
    Value<String>? receiptId,
    Value<String>? receiptNo,
    Value<DateTime>? receiptDate,
    Value<String>? customerId,
    Value<double>? totalAmount,
    Value<String>? paymentMethod,
    Value<String?>? bankName,
    Value<String?>? chequeNo,
    Value<DateTime?>? chequeDate,
    Value<String?>? transferRef,
    Value<String>? userId,
    Value<String?>? remark,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ArReceiptsCompanion(
      receiptId: receiptId ?? this.receiptId,
      receiptNo: receiptNo ?? this.receiptNo,
      receiptDate: receiptDate ?? this.receiptDate,
      customerId: customerId ?? this.customerId,
      totalAmount: totalAmount ?? this.totalAmount,
      paymentMethod: paymentMethod ?? this.paymentMethod,
      bankName: bankName ?? this.bankName,
      chequeNo: chequeNo ?? this.chequeNo,
      chequeDate: chequeDate ?? this.chequeDate,
      transferRef: transferRef ?? this.transferRef,
      userId: userId ?? this.userId,
      remark: remark ?? this.remark,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (receiptId.present) {
      map['receipt_id'] = Variable<String>(receiptId.value);
    }
    if (receiptNo.present) {
      map['receipt_no'] = Variable<String>(receiptNo.value);
    }
    if (receiptDate.present) {
      map['receipt_date'] = Variable<DateTime>(receiptDate.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (totalAmount.present) {
      map['total_amount'] = Variable<double>(totalAmount.value);
    }
    if (paymentMethod.present) {
      map['payment_method'] = Variable<String>(paymentMethod.value);
    }
    if (bankName.present) {
      map['bank_name'] = Variable<String>(bankName.value);
    }
    if (chequeNo.present) {
      map['cheque_no'] = Variable<String>(chequeNo.value);
    }
    if (chequeDate.present) {
      map['cheque_date'] = Variable<DateTime>(chequeDate.value);
    }
    if (transferRef.present) {
      map['transfer_ref'] = Variable<String>(transferRef.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (remark.present) {
      map['remark'] = Variable<String>(remark.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ArReceiptsCompanion(')
          ..write('receiptId: $receiptId, ')
          ..write('receiptNo: $receiptNo, ')
          ..write('receiptDate: $receiptDate, ')
          ..write('customerId: $customerId, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('bankName: $bankName, ')
          ..write('chequeNo: $chequeNo, ')
          ..write('chequeDate: $chequeDate, ')
          ..write('transferRef: $transferRef, ')
          ..write('userId: $userId, ')
          ..write('remark: $remark, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ArReceiptAllocationsTable extends ArReceiptAllocations
    with TableInfo<$ArReceiptAllocationsTable, ArReceiptAllocation> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ArReceiptAllocationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _allocationIdMeta = const VerificationMeta(
    'allocationId',
  );
  @override
  late final GeneratedColumn<String> allocationId = GeneratedColumn<String>(
    'allocation_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _receiptIdMeta = const VerificationMeta(
    'receiptId',
  );
  @override
  late final GeneratedColumn<String> receiptId = GeneratedColumn<String>(
    'receipt_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES ar_receipts (receipt_id)',
    ),
  );
  static const VerificationMeta _invoiceIdMeta = const VerificationMeta(
    'invoiceId',
  );
  @override
  late final GeneratedColumn<String> invoiceId = GeneratedColumn<String>(
    'invoice_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES ar_invoices (invoice_id)',
    ),
  );
  static const VerificationMeta _allocatedAmountMeta = const VerificationMeta(
    'allocatedAmount',
  );
  @override
  late final GeneratedColumn<double> allocatedAmount = GeneratedColumn<double>(
    'allocated_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    allocationId,
    receiptId,
    invoiceId,
    allocatedAmount,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ar_receipt_allocations';
  @override
  VerificationContext validateIntegrity(
    Insertable<ArReceiptAllocation> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('allocation_id')) {
      context.handle(
        _allocationIdMeta,
        allocationId.isAcceptableOrUnknown(
          data['allocation_id']!,
          _allocationIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_allocationIdMeta);
    }
    if (data.containsKey('receipt_id')) {
      context.handle(
        _receiptIdMeta,
        receiptId.isAcceptableOrUnknown(data['receipt_id']!, _receiptIdMeta),
      );
    } else if (isInserting) {
      context.missing(_receiptIdMeta);
    }
    if (data.containsKey('invoice_id')) {
      context.handle(
        _invoiceIdMeta,
        invoiceId.isAcceptableOrUnknown(data['invoice_id']!, _invoiceIdMeta),
      );
    } else if (isInserting) {
      context.missing(_invoiceIdMeta);
    }
    if (data.containsKey('allocated_amount')) {
      context.handle(
        _allocatedAmountMeta,
        allocatedAmount.isAcceptableOrUnknown(
          data['allocated_amount']!,
          _allocatedAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_allocatedAmountMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {allocationId};
  @override
  ArReceiptAllocation map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ArReceiptAllocation(
      allocationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}allocation_id'],
      )!,
      receiptId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receipt_id'],
      )!,
      invoiceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}invoice_id'],
      )!,
      allocatedAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}allocated_amount'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ArReceiptAllocationsTable createAlias(String alias) {
    return $ArReceiptAllocationsTable(attachedDatabase, alias);
  }
}

class ArReceiptAllocation extends DataClass
    implements Insertable<ArReceiptAllocation> {
  final String allocationId;
  final String receiptId;
  final String invoiceId;
  final double allocatedAmount;
  final DateTime createdAt;
  const ArReceiptAllocation({
    required this.allocationId,
    required this.receiptId,
    required this.invoiceId,
    required this.allocatedAmount,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['allocation_id'] = Variable<String>(allocationId);
    map['receipt_id'] = Variable<String>(receiptId);
    map['invoice_id'] = Variable<String>(invoiceId);
    map['allocated_amount'] = Variable<double>(allocatedAmount);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ArReceiptAllocationsCompanion toCompanion(bool nullToAbsent) {
    return ArReceiptAllocationsCompanion(
      allocationId: Value(allocationId),
      receiptId: Value(receiptId),
      invoiceId: Value(invoiceId),
      allocatedAmount: Value(allocatedAmount),
      createdAt: Value(createdAt),
    );
  }

  factory ArReceiptAllocation.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ArReceiptAllocation(
      allocationId: serializer.fromJson<String>(json['allocationId']),
      receiptId: serializer.fromJson<String>(json['receiptId']),
      invoiceId: serializer.fromJson<String>(json['invoiceId']),
      allocatedAmount: serializer.fromJson<double>(json['allocatedAmount']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'allocationId': serializer.toJson<String>(allocationId),
      'receiptId': serializer.toJson<String>(receiptId),
      'invoiceId': serializer.toJson<String>(invoiceId),
      'allocatedAmount': serializer.toJson<double>(allocatedAmount),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  ArReceiptAllocation copyWith({
    String? allocationId,
    String? receiptId,
    String? invoiceId,
    double? allocatedAmount,
    DateTime? createdAt,
  }) => ArReceiptAllocation(
    allocationId: allocationId ?? this.allocationId,
    receiptId: receiptId ?? this.receiptId,
    invoiceId: invoiceId ?? this.invoiceId,
    allocatedAmount: allocatedAmount ?? this.allocatedAmount,
    createdAt: createdAt ?? this.createdAt,
  );
  ArReceiptAllocation copyWithCompanion(ArReceiptAllocationsCompanion data) {
    return ArReceiptAllocation(
      allocationId: data.allocationId.present
          ? data.allocationId.value
          : this.allocationId,
      receiptId: data.receiptId.present ? data.receiptId.value : this.receiptId,
      invoiceId: data.invoiceId.present ? data.invoiceId.value : this.invoiceId,
      allocatedAmount: data.allocatedAmount.present
          ? data.allocatedAmount.value
          : this.allocatedAmount,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ArReceiptAllocation(')
          ..write('allocationId: $allocationId, ')
          ..write('receiptId: $receiptId, ')
          ..write('invoiceId: $invoiceId, ')
          ..write('allocatedAmount: $allocatedAmount, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    allocationId,
    receiptId,
    invoiceId,
    allocatedAmount,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ArReceiptAllocation &&
          other.allocationId == this.allocationId &&
          other.receiptId == this.receiptId &&
          other.invoiceId == this.invoiceId &&
          other.allocatedAmount == this.allocatedAmount &&
          other.createdAt == this.createdAt);
}

class ArReceiptAllocationsCompanion
    extends UpdateCompanion<ArReceiptAllocation> {
  final Value<String> allocationId;
  final Value<String> receiptId;
  final Value<String> invoiceId;
  final Value<double> allocatedAmount;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ArReceiptAllocationsCompanion({
    this.allocationId = const Value.absent(),
    this.receiptId = const Value.absent(),
    this.invoiceId = const Value.absent(),
    this.allocatedAmount = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ArReceiptAllocationsCompanion.insert({
    required String allocationId,
    required String receiptId,
    required String invoiceId,
    required double allocatedAmount,
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : allocationId = Value(allocationId),
       receiptId = Value(receiptId),
       invoiceId = Value(invoiceId),
       allocatedAmount = Value(allocatedAmount);
  static Insertable<ArReceiptAllocation> custom({
    Expression<String>? allocationId,
    Expression<String>? receiptId,
    Expression<String>? invoiceId,
    Expression<double>? allocatedAmount,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (allocationId != null) 'allocation_id': allocationId,
      if (receiptId != null) 'receipt_id': receiptId,
      if (invoiceId != null) 'invoice_id': invoiceId,
      if (allocatedAmount != null) 'allocated_amount': allocatedAmount,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ArReceiptAllocationsCompanion copyWith({
    Value<String>? allocationId,
    Value<String>? receiptId,
    Value<String>? invoiceId,
    Value<double>? allocatedAmount,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ArReceiptAllocationsCompanion(
      allocationId: allocationId ?? this.allocationId,
      receiptId: receiptId ?? this.receiptId,
      invoiceId: invoiceId ?? this.invoiceId,
      allocatedAmount: allocatedAmount ?? this.allocatedAmount,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (allocationId.present) {
      map['allocation_id'] = Variable<String>(allocationId.value);
    }
    if (receiptId.present) {
      map['receipt_id'] = Variable<String>(receiptId.value);
    }
    if (invoiceId.present) {
      map['invoice_id'] = Variable<String>(invoiceId.value);
    }
    if (allocatedAmount.present) {
      map['allocated_amount'] = Variable<double>(allocatedAmount.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ArReceiptAllocationsCompanion(')
          ..write('allocationId: $allocationId, ')
          ..write('receiptId: $receiptId, ')
          ..write('invoiceId: $invoiceId, ')
          ..write('allocatedAmount: $allocatedAmount, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ApInvoicesTable extends ApInvoices
    with TableInfo<$ApInvoicesTable, ApInvoice> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ApInvoicesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _invoiceIdMeta = const VerificationMeta(
    'invoiceId',
  );
  @override
  late final GeneratedColumn<String> invoiceId = GeneratedColumn<String>(
    'invoice_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _invoiceNoMeta = const VerificationMeta(
    'invoiceNo',
  );
  @override
  late final GeneratedColumn<String> invoiceNo = GeneratedColumn<String>(
    'invoice_no',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _invoiceDateMeta = const VerificationMeta(
    'invoiceDate',
  );
  @override
  late final GeneratedColumn<DateTime> invoiceDate = GeneratedColumn<DateTime>(
    'invoice_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dueDateMeta = const VerificationMeta(
    'dueDate',
  );
  @override
  late final GeneratedColumn<DateTime> dueDate = GeneratedColumn<DateTime>(
    'due_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _supplierIdMeta = const VerificationMeta(
    'supplierId',
  );
  @override
  late final GeneratedColumn<String> supplierId = GeneratedColumn<String>(
    'supplier_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES suppliers (supplier_id)',
    ),
  );
  static const VerificationMeta _supplierNameMeta = const VerificationMeta(
    'supplierName',
  );
  @override
  late final GeneratedColumn<String> supplierName = GeneratedColumn<String>(
    'supplier_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 300),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalAmountMeta = const VerificationMeta(
    'totalAmount',
  );
  @override
  late final GeneratedColumn<double> totalAmount = GeneratedColumn<double>(
    'total_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _paidAmountMeta = const VerificationMeta(
    'paidAmount',
  );
  @override
  late final GeneratedColumn<double> paidAmount = GeneratedColumn<double>(
    'paid_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _referenceTypeMeta = const VerificationMeta(
    'referenceType',
  );
  @override
  late final GeneratedColumn<String> referenceType = GeneratedColumn<String>(
    'reference_type',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _referenceIdMeta = const VerificationMeta(
    'referenceId',
  );
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
    'reference_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('UNPAID'),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    invoiceId,
    invoiceNo,
    invoiceDate,
    dueDate,
    supplierId,
    supplierName,
    totalAmount,
    paidAmount,
    referenceType,
    referenceId,
    status,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ap_invoices';
  @override
  VerificationContext validateIntegrity(
    Insertable<ApInvoice> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('invoice_id')) {
      context.handle(
        _invoiceIdMeta,
        invoiceId.isAcceptableOrUnknown(data['invoice_id']!, _invoiceIdMeta),
      );
    } else if (isInserting) {
      context.missing(_invoiceIdMeta);
    }
    if (data.containsKey('invoice_no')) {
      context.handle(
        _invoiceNoMeta,
        invoiceNo.isAcceptableOrUnknown(data['invoice_no']!, _invoiceNoMeta),
      );
    } else if (isInserting) {
      context.missing(_invoiceNoMeta);
    }
    if (data.containsKey('invoice_date')) {
      context.handle(
        _invoiceDateMeta,
        invoiceDate.isAcceptableOrUnknown(
          data['invoice_date']!,
          _invoiceDateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_invoiceDateMeta);
    }
    if (data.containsKey('due_date')) {
      context.handle(
        _dueDateMeta,
        dueDate.isAcceptableOrUnknown(data['due_date']!, _dueDateMeta),
      );
    }
    if (data.containsKey('supplier_id')) {
      context.handle(
        _supplierIdMeta,
        supplierId.isAcceptableOrUnknown(data['supplier_id']!, _supplierIdMeta),
      );
    } else if (isInserting) {
      context.missing(_supplierIdMeta);
    }
    if (data.containsKey('supplier_name')) {
      context.handle(
        _supplierNameMeta,
        supplierName.isAcceptableOrUnknown(
          data['supplier_name']!,
          _supplierNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_supplierNameMeta);
    }
    if (data.containsKey('total_amount')) {
      context.handle(
        _totalAmountMeta,
        totalAmount.isAcceptableOrUnknown(
          data['total_amount']!,
          _totalAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalAmountMeta);
    }
    if (data.containsKey('paid_amount')) {
      context.handle(
        _paidAmountMeta,
        paidAmount.isAcceptableOrUnknown(data['paid_amount']!, _paidAmountMeta),
      );
    }
    if (data.containsKey('reference_type')) {
      context.handle(
        _referenceTypeMeta,
        referenceType.isAcceptableOrUnknown(
          data['reference_type']!,
          _referenceTypeMeta,
        ),
      );
    }
    if (data.containsKey('reference_id')) {
      context.handle(
        _referenceIdMeta,
        referenceId.isAcceptableOrUnknown(
          data['reference_id']!,
          _referenceIdMeta,
        ),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {invoiceId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {invoiceNo},
  ];
  @override
  ApInvoice map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ApInvoice(
      invoiceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}invoice_id'],
      )!,
      invoiceNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}invoice_no'],
      )!,
      invoiceDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}invoice_date'],
      )!,
      dueDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}due_date'],
      ),
      supplierId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}supplier_id'],
      )!,
      supplierName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}supplier_name'],
      )!,
      totalAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_amount'],
      )!,
      paidAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}paid_amount'],
      )!,
      referenceType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reference_type'],
      ),
      referenceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reference_id'],
      ),
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ApInvoicesTable createAlias(String alias) {
    return $ApInvoicesTable(attachedDatabase, alias);
  }
}

class ApInvoice extends DataClass implements Insertable<ApInvoice> {
  final String invoiceId;
  final String invoiceNo;
  final DateTime invoiceDate;
  final DateTime? dueDate;
  final String supplierId;
  final String supplierName;
  final double totalAmount;
  final double paidAmount;
  final String? referenceType;
  final String? referenceId;
  final String status;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ApInvoice({
    required this.invoiceId,
    required this.invoiceNo,
    required this.invoiceDate,
    this.dueDate,
    required this.supplierId,
    required this.supplierName,
    required this.totalAmount,
    required this.paidAmount,
    this.referenceType,
    this.referenceId,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['invoice_id'] = Variable<String>(invoiceId);
    map['invoice_no'] = Variable<String>(invoiceNo);
    map['invoice_date'] = Variable<DateTime>(invoiceDate);
    if (!nullToAbsent || dueDate != null) {
      map['due_date'] = Variable<DateTime>(dueDate);
    }
    map['supplier_id'] = Variable<String>(supplierId);
    map['supplier_name'] = Variable<String>(supplierName);
    map['total_amount'] = Variable<double>(totalAmount);
    map['paid_amount'] = Variable<double>(paidAmount);
    if (!nullToAbsent || referenceType != null) {
      map['reference_type'] = Variable<String>(referenceType);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    map['status'] = Variable<String>(status);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ApInvoicesCompanion toCompanion(bool nullToAbsent) {
    return ApInvoicesCompanion(
      invoiceId: Value(invoiceId),
      invoiceNo: Value(invoiceNo),
      invoiceDate: Value(invoiceDate),
      dueDate: dueDate == null && nullToAbsent
          ? const Value.absent()
          : Value(dueDate),
      supplierId: Value(supplierId),
      supplierName: Value(supplierName),
      totalAmount: Value(totalAmount),
      paidAmount: Value(paidAmount),
      referenceType: referenceType == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceType),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      status: Value(status),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ApInvoice.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ApInvoice(
      invoiceId: serializer.fromJson<String>(json['invoiceId']),
      invoiceNo: serializer.fromJson<String>(json['invoiceNo']),
      invoiceDate: serializer.fromJson<DateTime>(json['invoiceDate']),
      dueDate: serializer.fromJson<DateTime?>(json['dueDate']),
      supplierId: serializer.fromJson<String>(json['supplierId']),
      supplierName: serializer.fromJson<String>(json['supplierName']),
      totalAmount: serializer.fromJson<double>(json['totalAmount']),
      paidAmount: serializer.fromJson<double>(json['paidAmount']),
      referenceType: serializer.fromJson<String?>(json['referenceType']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      status: serializer.fromJson<String>(json['status']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'invoiceId': serializer.toJson<String>(invoiceId),
      'invoiceNo': serializer.toJson<String>(invoiceNo),
      'invoiceDate': serializer.toJson<DateTime>(invoiceDate),
      'dueDate': serializer.toJson<DateTime?>(dueDate),
      'supplierId': serializer.toJson<String>(supplierId),
      'supplierName': serializer.toJson<String>(supplierName),
      'totalAmount': serializer.toJson<double>(totalAmount),
      'paidAmount': serializer.toJson<double>(paidAmount),
      'referenceType': serializer.toJson<String?>(referenceType),
      'referenceId': serializer.toJson<String?>(referenceId),
      'status': serializer.toJson<String>(status),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ApInvoice copyWith({
    String? invoiceId,
    String? invoiceNo,
    DateTime? invoiceDate,
    Value<DateTime?> dueDate = const Value.absent(),
    String? supplierId,
    String? supplierName,
    double? totalAmount,
    double? paidAmount,
    Value<String?> referenceType = const Value.absent(),
    Value<String?> referenceId = const Value.absent(),
    String? status,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => ApInvoice(
    invoiceId: invoiceId ?? this.invoiceId,
    invoiceNo: invoiceNo ?? this.invoiceNo,
    invoiceDate: invoiceDate ?? this.invoiceDate,
    dueDate: dueDate.present ? dueDate.value : this.dueDate,
    supplierId: supplierId ?? this.supplierId,
    supplierName: supplierName ?? this.supplierName,
    totalAmount: totalAmount ?? this.totalAmount,
    paidAmount: paidAmount ?? this.paidAmount,
    referenceType: referenceType.present
        ? referenceType.value
        : this.referenceType,
    referenceId: referenceId.present ? referenceId.value : this.referenceId,
    status: status ?? this.status,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ApInvoice copyWithCompanion(ApInvoicesCompanion data) {
    return ApInvoice(
      invoiceId: data.invoiceId.present ? data.invoiceId.value : this.invoiceId,
      invoiceNo: data.invoiceNo.present ? data.invoiceNo.value : this.invoiceNo,
      invoiceDate: data.invoiceDate.present
          ? data.invoiceDate.value
          : this.invoiceDate,
      dueDate: data.dueDate.present ? data.dueDate.value : this.dueDate,
      supplierId: data.supplierId.present
          ? data.supplierId.value
          : this.supplierId,
      supplierName: data.supplierName.present
          ? data.supplierName.value
          : this.supplierName,
      totalAmount: data.totalAmount.present
          ? data.totalAmount.value
          : this.totalAmount,
      paidAmount: data.paidAmount.present
          ? data.paidAmount.value
          : this.paidAmount,
      referenceType: data.referenceType.present
          ? data.referenceType.value
          : this.referenceType,
      referenceId: data.referenceId.present
          ? data.referenceId.value
          : this.referenceId,
      status: data.status.present ? data.status.value : this.status,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ApInvoice(')
          ..write('invoiceId: $invoiceId, ')
          ..write('invoiceNo: $invoiceNo, ')
          ..write('invoiceDate: $invoiceDate, ')
          ..write('dueDate: $dueDate, ')
          ..write('supplierId: $supplierId, ')
          ..write('supplierName: $supplierName, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('paidAmount: $paidAmount, ')
          ..write('referenceType: $referenceType, ')
          ..write('referenceId: $referenceId, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    invoiceId,
    invoiceNo,
    invoiceDate,
    dueDate,
    supplierId,
    supplierName,
    totalAmount,
    paidAmount,
    referenceType,
    referenceId,
    status,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ApInvoice &&
          other.invoiceId == this.invoiceId &&
          other.invoiceNo == this.invoiceNo &&
          other.invoiceDate == this.invoiceDate &&
          other.dueDate == this.dueDate &&
          other.supplierId == this.supplierId &&
          other.supplierName == this.supplierName &&
          other.totalAmount == this.totalAmount &&
          other.paidAmount == this.paidAmount &&
          other.referenceType == this.referenceType &&
          other.referenceId == this.referenceId &&
          other.status == this.status &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ApInvoicesCompanion extends UpdateCompanion<ApInvoice> {
  final Value<String> invoiceId;
  final Value<String> invoiceNo;
  final Value<DateTime> invoiceDate;
  final Value<DateTime?> dueDate;
  final Value<String> supplierId;
  final Value<String> supplierName;
  final Value<double> totalAmount;
  final Value<double> paidAmount;
  final Value<String?> referenceType;
  final Value<String?> referenceId;
  final Value<String> status;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const ApInvoicesCompanion({
    this.invoiceId = const Value.absent(),
    this.invoiceNo = const Value.absent(),
    this.invoiceDate = const Value.absent(),
    this.dueDate = const Value.absent(),
    this.supplierId = const Value.absent(),
    this.supplierName = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.paidAmount = const Value.absent(),
    this.referenceType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ApInvoicesCompanion.insert({
    required String invoiceId,
    required String invoiceNo,
    required DateTime invoiceDate,
    this.dueDate = const Value.absent(),
    required String supplierId,
    required String supplierName,
    required double totalAmount,
    this.paidAmount = const Value.absent(),
    this.referenceType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : invoiceId = Value(invoiceId),
       invoiceNo = Value(invoiceNo),
       invoiceDate = Value(invoiceDate),
       supplierId = Value(supplierId),
       supplierName = Value(supplierName),
       totalAmount = Value(totalAmount);
  static Insertable<ApInvoice> custom({
    Expression<String>? invoiceId,
    Expression<String>? invoiceNo,
    Expression<DateTime>? invoiceDate,
    Expression<DateTime>? dueDate,
    Expression<String>? supplierId,
    Expression<String>? supplierName,
    Expression<double>? totalAmount,
    Expression<double>? paidAmount,
    Expression<String>? referenceType,
    Expression<String>? referenceId,
    Expression<String>? status,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (invoiceId != null) 'invoice_id': invoiceId,
      if (invoiceNo != null) 'invoice_no': invoiceNo,
      if (invoiceDate != null) 'invoice_date': invoiceDate,
      if (dueDate != null) 'due_date': dueDate,
      if (supplierId != null) 'supplier_id': supplierId,
      if (supplierName != null) 'supplier_name': supplierName,
      if (totalAmount != null) 'total_amount': totalAmount,
      if (paidAmount != null) 'paid_amount': paidAmount,
      if (referenceType != null) 'reference_type': referenceType,
      if (referenceId != null) 'reference_id': referenceId,
      if (status != null) 'status': status,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ApInvoicesCompanion copyWith({
    Value<String>? invoiceId,
    Value<String>? invoiceNo,
    Value<DateTime>? invoiceDate,
    Value<DateTime?>? dueDate,
    Value<String>? supplierId,
    Value<String>? supplierName,
    Value<double>? totalAmount,
    Value<double>? paidAmount,
    Value<String?>? referenceType,
    Value<String?>? referenceId,
    Value<String>? status,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return ApInvoicesCompanion(
      invoiceId: invoiceId ?? this.invoiceId,
      invoiceNo: invoiceNo ?? this.invoiceNo,
      invoiceDate: invoiceDate ?? this.invoiceDate,
      dueDate: dueDate ?? this.dueDate,
      supplierId: supplierId ?? this.supplierId,
      supplierName: supplierName ?? this.supplierName,
      totalAmount: totalAmount ?? this.totalAmount,
      paidAmount: paidAmount ?? this.paidAmount,
      referenceType: referenceType ?? this.referenceType,
      referenceId: referenceId ?? this.referenceId,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (invoiceId.present) {
      map['invoice_id'] = Variable<String>(invoiceId.value);
    }
    if (invoiceNo.present) {
      map['invoice_no'] = Variable<String>(invoiceNo.value);
    }
    if (invoiceDate.present) {
      map['invoice_date'] = Variable<DateTime>(invoiceDate.value);
    }
    if (dueDate.present) {
      map['due_date'] = Variable<DateTime>(dueDate.value);
    }
    if (supplierId.present) {
      map['supplier_id'] = Variable<String>(supplierId.value);
    }
    if (supplierName.present) {
      map['supplier_name'] = Variable<String>(supplierName.value);
    }
    if (totalAmount.present) {
      map['total_amount'] = Variable<double>(totalAmount.value);
    }
    if (paidAmount.present) {
      map['paid_amount'] = Variable<double>(paidAmount.value);
    }
    if (referenceType.present) {
      map['reference_type'] = Variable<String>(referenceType.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ApInvoicesCompanion(')
          ..write('invoiceId: $invoiceId, ')
          ..write('invoiceNo: $invoiceNo, ')
          ..write('invoiceDate: $invoiceDate, ')
          ..write('dueDate: $dueDate, ')
          ..write('supplierId: $supplierId, ')
          ..write('supplierName: $supplierName, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('paidAmount: $paidAmount, ')
          ..write('referenceType: $referenceType, ')
          ..write('referenceId: $referenceId, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ApPaymentsTable extends ApPayments
    with TableInfo<$ApPaymentsTable, ApPayment> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ApPaymentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _paymentIdMeta = const VerificationMeta(
    'paymentId',
  );
  @override
  late final GeneratedColumn<String> paymentId = GeneratedColumn<String>(
    'payment_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _paymentNoMeta = const VerificationMeta(
    'paymentNo',
  );
  @override
  late final GeneratedColumn<String> paymentNo = GeneratedColumn<String>(
    'payment_no',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _paymentDateMeta = const VerificationMeta(
    'paymentDate',
  );
  @override
  late final GeneratedColumn<DateTime> paymentDate = GeneratedColumn<DateTime>(
    'payment_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _supplierIdMeta = const VerificationMeta(
    'supplierId',
  );
  @override
  late final GeneratedColumn<String> supplierId = GeneratedColumn<String>(
    'supplier_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES suppliers (supplier_id)',
    ),
  );
  static const VerificationMeta _totalAmountMeta = const VerificationMeta(
    'totalAmount',
  );
  @override
  late final GeneratedColumn<double> totalAmount = GeneratedColumn<double>(
    'total_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _paymentMethodMeta = const VerificationMeta(
    'paymentMethod',
  );
  @override
  late final GeneratedColumn<String> paymentMethod = GeneratedColumn<String>(
    'payment_method',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('CASH'),
  );
  static const VerificationMeta _bankNameMeta = const VerificationMeta(
    'bankName',
  );
  @override
  late final GeneratedColumn<String> bankName = GeneratedColumn<String>(
    'bank_name',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _chequeNoMeta = const VerificationMeta(
    'chequeNo',
  );
  @override
  late final GeneratedColumn<String> chequeNo = GeneratedColumn<String>(
    'cheque_no',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _chequeDateMeta = const VerificationMeta(
    'chequeDate',
  );
  @override
  late final GeneratedColumn<DateTime> chequeDate = GeneratedColumn<DateTime>(
    'cheque_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _transferRefMeta = const VerificationMeta(
    'transferRef',
  );
  @override
  late final GeneratedColumn<String> transferRef = GeneratedColumn<String>(
    'transfer_ref',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (user_id)',
    ),
  );
  static const VerificationMeta _remarkMeta = const VerificationMeta('remark');
  @override
  late final GeneratedColumn<String> remark = GeneratedColumn<String>(
    'remark',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    paymentId,
    paymentNo,
    paymentDate,
    supplierId,
    totalAmount,
    paymentMethod,
    bankName,
    chequeNo,
    chequeDate,
    transferRef,
    userId,
    remark,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ap_payments';
  @override
  VerificationContext validateIntegrity(
    Insertable<ApPayment> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('payment_id')) {
      context.handle(
        _paymentIdMeta,
        paymentId.isAcceptableOrUnknown(data['payment_id']!, _paymentIdMeta),
      );
    } else if (isInserting) {
      context.missing(_paymentIdMeta);
    }
    if (data.containsKey('payment_no')) {
      context.handle(
        _paymentNoMeta,
        paymentNo.isAcceptableOrUnknown(data['payment_no']!, _paymentNoMeta),
      );
    } else if (isInserting) {
      context.missing(_paymentNoMeta);
    }
    if (data.containsKey('payment_date')) {
      context.handle(
        _paymentDateMeta,
        paymentDate.isAcceptableOrUnknown(
          data['payment_date']!,
          _paymentDateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_paymentDateMeta);
    }
    if (data.containsKey('supplier_id')) {
      context.handle(
        _supplierIdMeta,
        supplierId.isAcceptableOrUnknown(data['supplier_id']!, _supplierIdMeta),
      );
    } else if (isInserting) {
      context.missing(_supplierIdMeta);
    }
    if (data.containsKey('total_amount')) {
      context.handle(
        _totalAmountMeta,
        totalAmount.isAcceptableOrUnknown(
          data['total_amount']!,
          _totalAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalAmountMeta);
    }
    if (data.containsKey('payment_method')) {
      context.handle(
        _paymentMethodMeta,
        paymentMethod.isAcceptableOrUnknown(
          data['payment_method']!,
          _paymentMethodMeta,
        ),
      );
    }
    if (data.containsKey('bank_name')) {
      context.handle(
        _bankNameMeta,
        bankName.isAcceptableOrUnknown(data['bank_name']!, _bankNameMeta),
      );
    }
    if (data.containsKey('cheque_no')) {
      context.handle(
        _chequeNoMeta,
        chequeNo.isAcceptableOrUnknown(data['cheque_no']!, _chequeNoMeta),
      );
    }
    if (data.containsKey('cheque_date')) {
      context.handle(
        _chequeDateMeta,
        chequeDate.isAcceptableOrUnknown(data['cheque_date']!, _chequeDateMeta),
      );
    }
    if (data.containsKey('transfer_ref')) {
      context.handle(
        _transferRefMeta,
        transferRef.isAcceptableOrUnknown(
          data['transfer_ref']!,
          _transferRefMeta,
        ),
      );
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('remark')) {
      context.handle(
        _remarkMeta,
        remark.isAcceptableOrUnknown(data['remark']!, _remarkMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {paymentId};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {paymentNo},
  ];
  @override
  ApPayment map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ApPayment(
      paymentId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payment_id'],
      )!,
      paymentNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payment_no'],
      )!,
      paymentDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}payment_date'],
      )!,
      supplierId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}supplier_id'],
      )!,
      totalAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_amount'],
      )!,
      paymentMethod: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payment_method'],
      )!,
      bankName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bank_name'],
      ),
      chequeNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cheque_no'],
      ),
      chequeDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}cheque_date'],
      ),
      transferRef: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}transfer_ref'],
      ),
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      remark: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}remark'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ApPaymentsTable createAlias(String alias) {
    return $ApPaymentsTable(attachedDatabase, alias);
  }
}

class ApPayment extends DataClass implements Insertable<ApPayment> {
  final String paymentId;
  final String paymentNo;
  final DateTime paymentDate;
  final String supplierId;
  final double totalAmount;
  final String paymentMethod;
  final String? bankName;
  final String? chequeNo;
  final DateTime? chequeDate;
  final String? transferRef;
  final String userId;
  final String? remark;
  final DateTime createdAt;
  const ApPayment({
    required this.paymentId,
    required this.paymentNo,
    required this.paymentDate,
    required this.supplierId,
    required this.totalAmount,
    required this.paymentMethod,
    this.bankName,
    this.chequeNo,
    this.chequeDate,
    this.transferRef,
    required this.userId,
    this.remark,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['payment_id'] = Variable<String>(paymentId);
    map['payment_no'] = Variable<String>(paymentNo);
    map['payment_date'] = Variable<DateTime>(paymentDate);
    map['supplier_id'] = Variable<String>(supplierId);
    map['total_amount'] = Variable<double>(totalAmount);
    map['payment_method'] = Variable<String>(paymentMethod);
    if (!nullToAbsent || bankName != null) {
      map['bank_name'] = Variable<String>(bankName);
    }
    if (!nullToAbsent || chequeNo != null) {
      map['cheque_no'] = Variable<String>(chequeNo);
    }
    if (!nullToAbsent || chequeDate != null) {
      map['cheque_date'] = Variable<DateTime>(chequeDate);
    }
    if (!nullToAbsent || transferRef != null) {
      map['transfer_ref'] = Variable<String>(transferRef);
    }
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || remark != null) {
      map['remark'] = Variable<String>(remark);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ApPaymentsCompanion toCompanion(bool nullToAbsent) {
    return ApPaymentsCompanion(
      paymentId: Value(paymentId),
      paymentNo: Value(paymentNo),
      paymentDate: Value(paymentDate),
      supplierId: Value(supplierId),
      totalAmount: Value(totalAmount),
      paymentMethod: Value(paymentMethod),
      bankName: bankName == null && nullToAbsent
          ? const Value.absent()
          : Value(bankName),
      chequeNo: chequeNo == null && nullToAbsent
          ? const Value.absent()
          : Value(chequeNo),
      chequeDate: chequeDate == null && nullToAbsent
          ? const Value.absent()
          : Value(chequeDate),
      transferRef: transferRef == null && nullToAbsent
          ? const Value.absent()
          : Value(transferRef),
      userId: Value(userId),
      remark: remark == null && nullToAbsent
          ? const Value.absent()
          : Value(remark),
      createdAt: Value(createdAt),
    );
  }

  factory ApPayment.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ApPayment(
      paymentId: serializer.fromJson<String>(json['paymentId']),
      paymentNo: serializer.fromJson<String>(json['paymentNo']),
      paymentDate: serializer.fromJson<DateTime>(json['paymentDate']),
      supplierId: serializer.fromJson<String>(json['supplierId']),
      totalAmount: serializer.fromJson<double>(json['totalAmount']),
      paymentMethod: serializer.fromJson<String>(json['paymentMethod']),
      bankName: serializer.fromJson<String?>(json['bankName']),
      chequeNo: serializer.fromJson<String?>(json['chequeNo']),
      chequeDate: serializer.fromJson<DateTime?>(json['chequeDate']),
      transferRef: serializer.fromJson<String?>(json['transferRef']),
      userId: serializer.fromJson<String>(json['userId']),
      remark: serializer.fromJson<String?>(json['remark']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'paymentId': serializer.toJson<String>(paymentId),
      'paymentNo': serializer.toJson<String>(paymentNo),
      'paymentDate': serializer.toJson<DateTime>(paymentDate),
      'supplierId': serializer.toJson<String>(supplierId),
      'totalAmount': serializer.toJson<double>(totalAmount),
      'paymentMethod': serializer.toJson<String>(paymentMethod),
      'bankName': serializer.toJson<String?>(bankName),
      'chequeNo': serializer.toJson<String?>(chequeNo),
      'chequeDate': serializer.toJson<DateTime?>(chequeDate),
      'transferRef': serializer.toJson<String?>(transferRef),
      'userId': serializer.toJson<String>(userId),
      'remark': serializer.toJson<String?>(remark),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  ApPayment copyWith({
    String? paymentId,
    String? paymentNo,
    DateTime? paymentDate,
    String? supplierId,
    double? totalAmount,
    String? paymentMethod,
    Value<String?> bankName = const Value.absent(),
    Value<String?> chequeNo = const Value.absent(),
    Value<DateTime?> chequeDate = const Value.absent(),
    Value<String?> transferRef = const Value.absent(),
    String? userId,
    Value<String?> remark = const Value.absent(),
    DateTime? createdAt,
  }) => ApPayment(
    paymentId: paymentId ?? this.paymentId,
    paymentNo: paymentNo ?? this.paymentNo,
    paymentDate: paymentDate ?? this.paymentDate,
    supplierId: supplierId ?? this.supplierId,
    totalAmount: totalAmount ?? this.totalAmount,
    paymentMethod: paymentMethod ?? this.paymentMethod,
    bankName: bankName.present ? bankName.value : this.bankName,
    chequeNo: chequeNo.present ? chequeNo.value : this.chequeNo,
    chequeDate: chequeDate.present ? chequeDate.value : this.chequeDate,
    transferRef: transferRef.present ? transferRef.value : this.transferRef,
    userId: userId ?? this.userId,
    remark: remark.present ? remark.value : this.remark,
    createdAt: createdAt ?? this.createdAt,
  );
  ApPayment copyWithCompanion(ApPaymentsCompanion data) {
    return ApPayment(
      paymentId: data.paymentId.present ? data.paymentId.value : this.paymentId,
      paymentNo: data.paymentNo.present ? data.paymentNo.value : this.paymentNo,
      paymentDate: data.paymentDate.present
          ? data.paymentDate.value
          : this.paymentDate,
      supplierId: data.supplierId.present
          ? data.supplierId.value
          : this.supplierId,
      totalAmount: data.totalAmount.present
          ? data.totalAmount.value
          : this.totalAmount,
      paymentMethod: data.paymentMethod.present
          ? data.paymentMethod.value
          : this.paymentMethod,
      bankName: data.bankName.present ? data.bankName.value : this.bankName,
      chequeNo: data.chequeNo.present ? data.chequeNo.value : this.chequeNo,
      chequeDate: data.chequeDate.present
          ? data.chequeDate.value
          : this.chequeDate,
      transferRef: data.transferRef.present
          ? data.transferRef.value
          : this.transferRef,
      userId: data.userId.present ? data.userId.value : this.userId,
      remark: data.remark.present ? data.remark.value : this.remark,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ApPayment(')
          ..write('paymentId: $paymentId, ')
          ..write('paymentNo: $paymentNo, ')
          ..write('paymentDate: $paymentDate, ')
          ..write('supplierId: $supplierId, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('bankName: $bankName, ')
          ..write('chequeNo: $chequeNo, ')
          ..write('chequeDate: $chequeDate, ')
          ..write('transferRef: $transferRef, ')
          ..write('userId: $userId, ')
          ..write('remark: $remark, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    paymentId,
    paymentNo,
    paymentDate,
    supplierId,
    totalAmount,
    paymentMethod,
    bankName,
    chequeNo,
    chequeDate,
    transferRef,
    userId,
    remark,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ApPayment &&
          other.paymentId == this.paymentId &&
          other.paymentNo == this.paymentNo &&
          other.paymentDate == this.paymentDate &&
          other.supplierId == this.supplierId &&
          other.totalAmount == this.totalAmount &&
          other.paymentMethod == this.paymentMethod &&
          other.bankName == this.bankName &&
          other.chequeNo == this.chequeNo &&
          other.chequeDate == this.chequeDate &&
          other.transferRef == this.transferRef &&
          other.userId == this.userId &&
          other.remark == this.remark &&
          other.createdAt == this.createdAt);
}

class ApPaymentsCompanion extends UpdateCompanion<ApPayment> {
  final Value<String> paymentId;
  final Value<String> paymentNo;
  final Value<DateTime> paymentDate;
  final Value<String> supplierId;
  final Value<double> totalAmount;
  final Value<String> paymentMethod;
  final Value<String?> bankName;
  final Value<String?> chequeNo;
  final Value<DateTime?> chequeDate;
  final Value<String?> transferRef;
  final Value<String> userId;
  final Value<String?> remark;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ApPaymentsCompanion({
    this.paymentId = const Value.absent(),
    this.paymentNo = const Value.absent(),
    this.paymentDate = const Value.absent(),
    this.supplierId = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.paymentMethod = const Value.absent(),
    this.bankName = const Value.absent(),
    this.chequeNo = const Value.absent(),
    this.chequeDate = const Value.absent(),
    this.transferRef = const Value.absent(),
    this.userId = const Value.absent(),
    this.remark = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ApPaymentsCompanion.insert({
    required String paymentId,
    required String paymentNo,
    required DateTime paymentDate,
    required String supplierId,
    required double totalAmount,
    this.paymentMethod = const Value.absent(),
    this.bankName = const Value.absent(),
    this.chequeNo = const Value.absent(),
    this.chequeDate = const Value.absent(),
    this.transferRef = const Value.absent(),
    required String userId,
    this.remark = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : paymentId = Value(paymentId),
       paymentNo = Value(paymentNo),
       paymentDate = Value(paymentDate),
       supplierId = Value(supplierId),
       totalAmount = Value(totalAmount),
       userId = Value(userId);
  static Insertable<ApPayment> custom({
    Expression<String>? paymentId,
    Expression<String>? paymentNo,
    Expression<DateTime>? paymentDate,
    Expression<String>? supplierId,
    Expression<double>? totalAmount,
    Expression<String>? paymentMethod,
    Expression<String>? bankName,
    Expression<String>? chequeNo,
    Expression<DateTime>? chequeDate,
    Expression<String>? transferRef,
    Expression<String>? userId,
    Expression<String>? remark,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (paymentId != null) 'payment_id': paymentId,
      if (paymentNo != null) 'payment_no': paymentNo,
      if (paymentDate != null) 'payment_date': paymentDate,
      if (supplierId != null) 'supplier_id': supplierId,
      if (totalAmount != null) 'total_amount': totalAmount,
      if (paymentMethod != null) 'payment_method': paymentMethod,
      if (bankName != null) 'bank_name': bankName,
      if (chequeNo != null) 'cheque_no': chequeNo,
      if (chequeDate != null) 'cheque_date': chequeDate,
      if (transferRef != null) 'transfer_ref': transferRef,
      if (userId != null) 'user_id': userId,
      if (remark != null) 'remark': remark,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ApPaymentsCompanion copyWith({
    Value<String>? paymentId,
    Value<String>? paymentNo,
    Value<DateTime>? paymentDate,
    Value<String>? supplierId,
    Value<double>? totalAmount,
    Value<String>? paymentMethod,
    Value<String?>? bankName,
    Value<String?>? chequeNo,
    Value<DateTime?>? chequeDate,
    Value<String?>? transferRef,
    Value<String>? userId,
    Value<String?>? remark,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ApPaymentsCompanion(
      paymentId: paymentId ?? this.paymentId,
      paymentNo: paymentNo ?? this.paymentNo,
      paymentDate: paymentDate ?? this.paymentDate,
      supplierId: supplierId ?? this.supplierId,
      totalAmount: totalAmount ?? this.totalAmount,
      paymentMethod: paymentMethod ?? this.paymentMethod,
      bankName: bankName ?? this.bankName,
      chequeNo: chequeNo ?? this.chequeNo,
      chequeDate: chequeDate ?? this.chequeDate,
      transferRef: transferRef ?? this.transferRef,
      userId: userId ?? this.userId,
      remark: remark ?? this.remark,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (paymentId.present) {
      map['payment_id'] = Variable<String>(paymentId.value);
    }
    if (paymentNo.present) {
      map['payment_no'] = Variable<String>(paymentNo.value);
    }
    if (paymentDate.present) {
      map['payment_date'] = Variable<DateTime>(paymentDate.value);
    }
    if (supplierId.present) {
      map['supplier_id'] = Variable<String>(supplierId.value);
    }
    if (totalAmount.present) {
      map['total_amount'] = Variable<double>(totalAmount.value);
    }
    if (paymentMethod.present) {
      map['payment_method'] = Variable<String>(paymentMethod.value);
    }
    if (bankName.present) {
      map['bank_name'] = Variable<String>(bankName.value);
    }
    if (chequeNo.present) {
      map['cheque_no'] = Variable<String>(chequeNo.value);
    }
    if (chequeDate.present) {
      map['cheque_date'] = Variable<DateTime>(chequeDate.value);
    }
    if (transferRef.present) {
      map['transfer_ref'] = Variable<String>(transferRef.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (remark.present) {
      map['remark'] = Variable<String>(remark.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ApPaymentsCompanion(')
          ..write('paymentId: $paymentId, ')
          ..write('paymentNo: $paymentNo, ')
          ..write('paymentDate: $paymentDate, ')
          ..write('supplierId: $supplierId, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('bankName: $bankName, ')
          ..write('chequeNo: $chequeNo, ')
          ..write('chequeDate: $chequeDate, ')
          ..write('transferRef: $transferRef, ')
          ..write('userId: $userId, ')
          ..write('remark: $remark, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ApPaymentAllocationsTable extends ApPaymentAllocations
    with TableInfo<$ApPaymentAllocationsTable, ApPaymentAllocation> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ApPaymentAllocationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _allocationIdMeta = const VerificationMeta(
    'allocationId',
  );
  @override
  late final GeneratedColumn<String> allocationId = GeneratedColumn<String>(
    'allocation_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _paymentIdMeta = const VerificationMeta(
    'paymentId',
  );
  @override
  late final GeneratedColumn<String> paymentId = GeneratedColumn<String>(
    'payment_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES ap_payments (payment_id)',
    ),
  );
  static const VerificationMeta _invoiceIdMeta = const VerificationMeta(
    'invoiceId',
  );
  @override
  late final GeneratedColumn<String> invoiceId = GeneratedColumn<String>(
    'invoice_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES ap_invoices (invoice_id)',
    ),
  );
  static const VerificationMeta _allocatedAmountMeta = const VerificationMeta(
    'allocatedAmount',
  );
  @override
  late final GeneratedColumn<double> allocatedAmount = GeneratedColumn<double>(
    'allocated_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    allocationId,
    paymentId,
    invoiceId,
    allocatedAmount,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ap_payment_allocations';
  @override
  VerificationContext validateIntegrity(
    Insertable<ApPaymentAllocation> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('allocation_id')) {
      context.handle(
        _allocationIdMeta,
        allocationId.isAcceptableOrUnknown(
          data['allocation_id']!,
          _allocationIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_allocationIdMeta);
    }
    if (data.containsKey('payment_id')) {
      context.handle(
        _paymentIdMeta,
        paymentId.isAcceptableOrUnknown(data['payment_id']!, _paymentIdMeta),
      );
    } else if (isInserting) {
      context.missing(_paymentIdMeta);
    }
    if (data.containsKey('invoice_id')) {
      context.handle(
        _invoiceIdMeta,
        invoiceId.isAcceptableOrUnknown(data['invoice_id']!, _invoiceIdMeta),
      );
    } else if (isInserting) {
      context.missing(_invoiceIdMeta);
    }
    if (data.containsKey('allocated_amount')) {
      context.handle(
        _allocatedAmountMeta,
        allocatedAmount.isAcceptableOrUnknown(
          data['allocated_amount']!,
          _allocatedAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_allocatedAmountMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {allocationId};
  @override
  ApPaymentAllocation map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ApPaymentAllocation(
      allocationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}allocation_id'],
      )!,
      paymentId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payment_id'],
      )!,
      invoiceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}invoice_id'],
      )!,
      allocatedAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}allocated_amount'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ApPaymentAllocationsTable createAlias(String alias) {
    return $ApPaymentAllocationsTable(attachedDatabase, alias);
  }
}

class ApPaymentAllocation extends DataClass
    implements Insertable<ApPaymentAllocation> {
  final String allocationId;
  final String paymentId;
  final String invoiceId;
  final double allocatedAmount;
  final DateTime createdAt;
  const ApPaymentAllocation({
    required this.allocationId,
    required this.paymentId,
    required this.invoiceId,
    required this.allocatedAmount,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['allocation_id'] = Variable<String>(allocationId);
    map['payment_id'] = Variable<String>(paymentId);
    map['invoice_id'] = Variable<String>(invoiceId);
    map['allocated_amount'] = Variable<double>(allocatedAmount);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ApPaymentAllocationsCompanion toCompanion(bool nullToAbsent) {
    return ApPaymentAllocationsCompanion(
      allocationId: Value(allocationId),
      paymentId: Value(paymentId),
      invoiceId: Value(invoiceId),
      allocatedAmount: Value(allocatedAmount),
      createdAt: Value(createdAt),
    );
  }

  factory ApPaymentAllocation.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ApPaymentAllocation(
      allocationId: serializer.fromJson<String>(json['allocationId']),
      paymentId: serializer.fromJson<String>(json['paymentId']),
      invoiceId: serializer.fromJson<String>(json['invoiceId']),
      allocatedAmount: serializer.fromJson<double>(json['allocatedAmount']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'allocationId': serializer.toJson<String>(allocationId),
      'paymentId': serializer.toJson<String>(paymentId),
      'invoiceId': serializer.toJson<String>(invoiceId),
      'allocatedAmount': serializer.toJson<double>(allocatedAmount),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  ApPaymentAllocation copyWith({
    String? allocationId,
    String? paymentId,
    String? invoiceId,
    double? allocatedAmount,
    DateTime? createdAt,
  }) => ApPaymentAllocation(
    allocationId: allocationId ?? this.allocationId,
    paymentId: paymentId ?? this.paymentId,
    invoiceId: invoiceId ?? this.invoiceId,
    allocatedAmount: allocatedAmount ?? this.allocatedAmount,
    createdAt: createdAt ?? this.createdAt,
  );
  ApPaymentAllocation copyWithCompanion(ApPaymentAllocationsCompanion data) {
    return ApPaymentAllocation(
      allocationId: data.allocationId.present
          ? data.allocationId.value
          : this.allocationId,
      paymentId: data.paymentId.present ? data.paymentId.value : this.paymentId,
      invoiceId: data.invoiceId.present ? data.invoiceId.value : this.invoiceId,
      allocatedAmount: data.allocatedAmount.present
          ? data.allocatedAmount.value
          : this.allocatedAmount,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ApPaymentAllocation(')
          ..write('allocationId: $allocationId, ')
          ..write('paymentId: $paymentId, ')
          ..write('invoiceId: $invoiceId, ')
          ..write('allocatedAmount: $allocatedAmount, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    allocationId,
    paymentId,
    invoiceId,
    allocatedAmount,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ApPaymentAllocation &&
          other.allocationId == this.allocationId &&
          other.paymentId == this.paymentId &&
          other.invoiceId == this.invoiceId &&
          other.allocatedAmount == this.allocatedAmount &&
          other.createdAt == this.createdAt);
}

class ApPaymentAllocationsCompanion
    extends UpdateCompanion<ApPaymentAllocation> {
  final Value<String> allocationId;
  final Value<String> paymentId;
  final Value<String> invoiceId;
  final Value<double> allocatedAmount;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ApPaymentAllocationsCompanion({
    this.allocationId = const Value.absent(),
    this.paymentId = const Value.absent(),
    this.invoiceId = const Value.absent(),
    this.allocatedAmount = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ApPaymentAllocationsCompanion.insert({
    required String allocationId,
    required String paymentId,
    required String invoiceId,
    required double allocatedAmount,
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : allocationId = Value(allocationId),
       paymentId = Value(paymentId),
       invoiceId = Value(invoiceId),
       allocatedAmount = Value(allocatedAmount);
  static Insertable<ApPaymentAllocation> custom({
    Expression<String>? allocationId,
    Expression<String>? paymentId,
    Expression<String>? invoiceId,
    Expression<double>? allocatedAmount,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (allocationId != null) 'allocation_id': allocationId,
      if (paymentId != null) 'payment_id': paymentId,
      if (invoiceId != null) 'invoice_id': invoiceId,
      if (allocatedAmount != null) 'allocated_amount': allocatedAmount,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ApPaymentAllocationsCompanion copyWith({
    Value<String>? allocationId,
    Value<String>? paymentId,
    Value<String>? invoiceId,
    Value<double>? allocatedAmount,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ApPaymentAllocationsCompanion(
      allocationId: allocationId ?? this.allocationId,
      paymentId: paymentId ?? this.paymentId,
      invoiceId: invoiceId ?? this.invoiceId,
      allocatedAmount: allocatedAmount ?? this.allocatedAmount,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (allocationId.present) {
      map['allocation_id'] = Variable<String>(allocationId.value);
    }
    if (paymentId.present) {
      map['payment_id'] = Variable<String>(paymentId.value);
    }
    if (invoiceId.present) {
      map['invoice_id'] = Variable<String>(invoiceId.value);
    }
    if (allocatedAmount.present) {
      map['allocated_amount'] = Variable<double>(allocatedAmount.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ApPaymentAllocationsCompanion(')
          ..write('allocationId: $allocationId, ')
          ..write('paymentId: $paymentId, ')
          ..write('invoiceId: $invoiceId, ')
          ..write('allocatedAmount: $allocatedAmount, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DevicesTable extends Devices with TableInfo<$DevicesTable, Device> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DevicesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _deviceIdMeta = const VerificationMeta(
    'deviceId',
  );
  @override
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
    'device_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deviceNameMeta = const VerificationMeta(
    'deviceName',
  );
  @override
  late final GeneratedColumn<String> deviceName = GeneratedColumn<String>(
    'device_name',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deviceTypeMeta = const VerificationMeta(
    'deviceType',
  );
  @override
  late final GeneratedColumn<String> deviceType = GeneratedColumn<String>(
    'device_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _ipAddressMeta = const VerificationMeta(
    'ipAddress',
  );
  @override
  late final GeneratedColumn<String> ipAddress = GeneratedColumn<String>(
    'ip_address',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _macAddressMeta = const VerificationMeta(
    'macAddress',
  );
  @override
  late final GeneratedColumn<String> macAddress = GeneratedColumn<String>(
    'mac_address',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isOnlineMeta = const VerificationMeta(
    'isOnline',
  );
  @override
  late final GeneratedColumn<bool> isOnline = GeneratedColumn<bool>(
    'is_online',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_online" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _lastSeenMeta = const VerificationMeta(
    'lastSeen',
  );
  @override
  late final GeneratedColumn<DateTime> lastSeen = GeneratedColumn<DateTime>(
    'last_seen',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    deviceId,
    deviceName,
    deviceType,
    ipAddress,
    macAddress,
    isOnline,
    lastSeen,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'devices';
  @override
  VerificationContext validateIntegrity(
    Insertable<Device> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('device_id')) {
      context.handle(
        _deviceIdMeta,
        deviceId.isAcceptableOrUnknown(data['device_id']!, _deviceIdMeta),
      );
    } else if (isInserting) {
      context.missing(_deviceIdMeta);
    }
    if (data.containsKey('device_name')) {
      context.handle(
        _deviceNameMeta,
        deviceName.isAcceptableOrUnknown(data['device_name']!, _deviceNameMeta),
      );
    } else if (isInserting) {
      context.missing(_deviceNameMeta);
    }
    if (data.containsKey('device_type')) {
      context.handle(
        _deviceTypeMeta,
        deviceType.isAcceptableOrUnknown(data['device_type']!, _deviceTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_deviceTypeMeta);
    }
    if (data.containsKey('ip_address')) {
      context.handle(
        _ipAddressMeta,
        ipAddress.isAcceptableOrUnknown(data['ip_address']!, _ipAddressMeta),
      );
    }
    if (data.containsKey('mac_address')) {
      context.handle(
        _macAddressMeta,
        macAddress.isAcceptableOrUnknown(data['mac_address']!, _macAddressMeta),
      );
    }
    if (data.containsKey('is_online')) {
      context.handle(
        _isOnlineMeta,
        isOnline.isAcceptableOrUnknown(data['is_online']!, _isOnlineMeta),
      );
    }
    if (data.containsKey('last_seen')) {
      context.handle(
        _lastSeenMeta,
        lastSeen.isAcceptableOrUnknown(data['last_seen']!, _lastSeenMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {deviceId};
  @override
  Device map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Device(
      deviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}device_id'],
      )!,
      deviceName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}device_name'],
      )!,
      deviceType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}device_type'],
      )!,
      ipAddress: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ip_address'],
      ),
      macAddress: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}mac_address'],
      ),
      isOnline: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_online'],
      )!,
      lastSeen: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_seen'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $DevicesTable createAlias(String alias) {
    return $DevicesTable(attachedDatabase, alias);
  }
}

class Device extends DataClass implements Insertable<Device> {
  final String deviceId;
  final String deviceName;
  final String deviceType;
  final String? ipAddress;
  final String? macAddress;
  final bool isOnline;
  final DateTime? lastSeen;
  final DateTime createdAt;
  const Device({
    required this.deviceId,
    required this.deviceName,
    required this.deviceType,
    this.ipAddress,
    this.macAddress,
    required this.isOnline,
    this.lastSeen,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['device_id'] = Variable<String>(deviceId);
    map['device_name'] = Variable<String>(deviceName);
    map['device_type'] = Variable<String>(deviceType);
    if (!nullToAbsent || ipAddress != null) {
      map['ip_address'] = Variable<String>(ipAddress);
    }
    if (!nullToAbsent || macAddress != null) {
      map['mac_address'] = Variable<String>(macAddress);
    }
    map['is_online'] = Variable<bool>(isOnline);
    if (!nullToAbsent || lastSeen != null) {
      map['last_seen'] = Variable<DateTime>(lastSeen);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  DevicesCompanion toCompanion(bool nullToAbsent) {
    return DevicesCompanion(
      deviceId: Value(deviceId),
      deviceName: Value(deviceName),
      deviceType: Value(deviceType),
      ipAddress: ipAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(ipAddress),
      macAddress: macAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(macAddress),
      isOnline: Value(isOnline),
      lastSeen: lastSeen == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSeen),
      createdAt: Value(createdAt),
    );
  }

  factory Device.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Device(
      deviceId: serializer.fromJson<String>(json['deviceId']),
      deviceName: serializer.fromJson<String>(json['deviceName']),
      deviceType: serializer.fromJson<String>(json['deviceType']),
      ipAddress: serializer.fromJson<String?>(json['ipAddress']),
      macAddress: serializer.fromJson<String?>(json['macAddress']),
      isOnline: serializer.fromJson<bool>(json['isOnline']),
      lastSeen: serializer.fromJson<DateTime?>(json['lastSeen']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'deviceId': serializer.toJson<String>(deviceId),
      'deviceName': serializer.toJson<String>(deviceName),
      'deviceType': serializer.toJson<String>(deviceType),
      'ipAddress': serializer.toJson<String?>(ipAddress),
      'macAddress': serializer.toJson<String?>(macAddress),
      'isOnline': serializer.toJson<bool>(isOnline),
      'lastSeen': serializer.toJson<DateTime?>(lastSeen),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Device copyWith({
    String? deviceId,
    String? deviceName,
    String? deviceType,
    Value<String?> ipAddress = const Value.absent(),
    Value<String?> macAddress = const Value.absent(),
    bool? isOnline,
    Value<DateTime?> lastSeen = const Value.absent(),
    DateTime? createdAt,
  }) => Device(
    deviceId: deviceId ?? this.deviceId,
    deviceName: deviceName ?? this.deviceName,
    deviceType: deviceType ?? this.deviceType,
    ipAddress: ipAddress.present ? ipAddress.value : this.ipAddress,
    macAddress: macAddress.present ? macAddress.value : this.macAddress,
    isOnline: isOnline ?? this.isOnline,
    lastSeen: lastSeen.present ? lastSeen.value : this.lastSeen,
    createdAt: createdAt ?? this.createdAt,
  );
  Device copyWithCompanion(DevicesCompanion data) {
    return Device(
      deviceId: data.deviceId.present ? data.deviceId.value : this.deviceId,
      deviceName: data.deviceName.present
          ? data.deviceName.value
          : this.deviceName,
      deviceType: data.deviceType.present
          ? data.deviceType.value
          : this.deviceType,
      ipAddress: data.ipAddress.present ? data.ipAddress.value : this.ipAddress,
      macAddress: data.macAddress.present
          ? data.macAddress.value
          : this.macAddress,
      isOnline: data.isOnline.present ? data.isOnline.value : this.isOnline,
      lastSeen: data.lastSeen.present ? data.lastSeen.value : this.lastSeen,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Device(')
          ..write('deviceId: $deviceId, ')
          ..write('deviceName: $deviceName, ')
          ..write('deviceType: $deviceType, ')
          ..write('ipAddress: $ipAddress, ')
          ..write('macAddress: $macAddress, ')
          ..write('isOnline: $isOnline, ')
          ..write('lastSeen: $lastSeen, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    deviceId,
    deviceName,
    deviceType,
    ipAddress,
    macAddress,
    isOnline,
    lastSeen,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Device &&
          other.deviceId == this.deviceId &&
          other.deviceName == this.deviceName &&
          other.deviceType == this.deviceType &&
          other.ipAddress == this.ipAddress &&
          other.macAddress == this.macAddress &&
          other.isOnline == this.isOnline &&
          other.lastSeen == this.lastSeen &&
          other.createdAt == this.createdAt);
}

class DevicesCompanion extends UpdateCompanion<Device> {
  final Value<String> deviceId;
  final Value<String> deviceName;
  final Value<String> deviceType;
  final Value<String?> ipAddress;
  final Value<String?> macAddress;
  final Value<bool> isOnline;
  final Value<DateTime?> lastSeen;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const DevicesCompanion({
    this.deviceId = const Value.absent(),
    this.deviceName = const Value.absent(),
    this.deviceType = const Value.absent(),
    this.ipAddress = const Value.absent(),
    this.macAddress = const Value.absent(),
    this.isOnline = const Value.absent(),
    this.lastSeen = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DevicesCompanion.insert({
    required String deviceId,
    required String deviceName,
    required String deviceType,
    this.ipAddress = const Value.absent(),
    this.macAddress = const Value.absent(),
    this.isOnline = const Value.absent(),
    this.lastSeen = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : deviceId = Value(deviceId),
       deviceName = Value(deviceName),
       deviceType = Value(deviceType);
  static Insertable<Device> custom({
    Expression<String>? deviceId,
    Expression<String>? deviceName,
    Expression<String>? deviceType,
    Expression<String>? ipAddress,
    Expression<String>? macAddress,
    Expression<bool>? isOnline,
    Expression<DateTime>? lastSeen,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (deviceId != null) 'device_id': deviceId,
      if (deviceName != null) 'device_name': deviceName,
      if (deviceType != null) 'device_type': deviceType,
      if (ipAddress != null) 'ip_address': ipAddress,
      if (macAddress != null) 'mac_address': macAddress,
      if (isOnline != null) 'is_online': isOnline,
      if (lastSeen != null) 'last_seen': lastSeen,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DevicesCompanion copyWith({
    Value<String>? deviceId,
    Value<String>? deviceName,
    Value<String>? deviceType,
    Value<String?>? ipAddress,
    Value<String?>? macAddress,
    Value<bool>? isOnline,
    Value<DateTime?>? lastSeen,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return DevicesCompanion(
      deviceId: deviceId ?? this.deviceId,
      deviceName: deviceName ?? this.deviceName,
      deviceType: deviceType ?? this.deviceType,
      ipAddress: ipAddress ?? this.ipAddress,
      macAddress: macAddress ?? this.macAddress,
      isOnline: isOnline ?? this.isOnline,
      lastSeen: lastSeen ?? this.lastSeen,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (deviceName.present) {
      map['device_name'] = Variable<String>(deviceName.value);
    }
    if (deviceType.present) {
      map['device_type'] = Variable<String>(deviceType.value);
    }
    if (ipAddress.present) {
      map['ip_address'] = Variable<String>(ipAddress.value);
    }
    if (macAddress.present) {
      map['mac_address'] = Variable<String>(macAddress.value);
    }
    if (isOnline.present) {
      map['is_online'] = Variable<bool>(isOnline.value);
    }
    if (lastSeen.present) {
      map['last_seen'] = Variable<DateTime>(lastSeen.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DevicesCompanion(')
          ..write('deviceId: $deviceId, ')
          ..write('deviceName: $deviceName, ')
          ..write('deviceType: $deviceType, ')
          ..write('ipAddress: $ipAddress, ')
          ..write('macAddress: $macAddress, ')
          ..write('isOnline: $isOnline, ')
          ..write('lastSeen: $lastSeen, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActiveSessionsTable extends ActiveSessions
    with TableInfo<$ActiveSessionsTable, ActiveSession> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActiveSessionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _sessionIdMeta = const VerificationMeta(
    'sessionId',
  );
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
    'session_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deviceIdMeta = const VerificationMeta(
    'deviceId',
  );
  @override
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
    'device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES devices (device_id)',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (user_id)',
    ),
  );
  static const VerificationMeta _tokenMeta = const VerificationMeta('token');
  @override
  late final GeneratedColumn<String> token = GeneratedColumn<String>(
    'token',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _ipAddressMeta = const VerificationMeta(
    'ipAddress',
  );
  @override
  late final GeneratedColumn<String> ipAddress = GeneratedColumn<String>(
    'ip_address',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _startedAtMeta = const VerificationMeta(
    'startedAt',
  );
  @override
  late final GeneratedColumn<DateTime> startedAt = GeneratedColumn<DateTime>(
    'started_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _lastActivityMeta = const VerificationMeta(
    'lastActivity',
  );
  @override
  late final GeneratedColumn<DateTime> lastActivity = GeneratedColumn<DateTime>(
    'last_activity',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    sessionId,
    deviceId,
    userId,
    token,
    ipAddress,
    startedAt,
    lastActivity,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'active_sessions';
  @override
  VerificationContext validateIntegrity(
    Insertable<ActiveSession> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('session_id')) {
      context.handle(
        _sessionIdMeta,
        sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta),
      );
    } else if (isInserting) {
      context.missing(_sessionIdMeta);
    }
    if (data.containsKey('device_id')) {
      context.handle(
        _deviceIdMeta,
        deviceId.isAcceptableOrUnknown(data['device_id']!, _deviceIdMeta),
      );
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    }
    if (data.containsKey('token')) {
      context.handle(
        _tokenMeta,
        token.isAcceptableOrUnknown(data['token']!, _tokenMeta),
      );
    } else if (isInserting) {
      context.missing(_tokenMeta);
    }
    if (data.containsKey('ip_address')) {
      context.handle(
        _ipAddressMeta,
        ipAddress.isAcceptableOrUnknown(data['ip_address']!, _ipAddressMeta),
      );
    }
    if (data.containsKey('started_at')) {
      context.handle(
        _startedAtMeta,
        startedAt.isAcceptableOrUnknown(data['started_at']!, _startedAtMeta),
      );
    }
    if (data.containsKey('last_activity')) {
      context.handle(
        _lastActivityMeta,
        lastActivity.isAcceptableOrUnknown(
          data['last_activity']!,
          _lastActivityMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {sessionId};
  @override
  ActiveSession map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ActiveSession(
      sessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_id'],
      )!,
      deviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}device_id'],
      ),
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      ),
      token: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}token'],
      )!,
      ipAddress: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ip_address'],
      ),
      startedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}started_at'],
      )!,
      lastActivity: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_activity'],
      )!,
    );
  }

  @override
  $ActiveSessionsTable createAlias(String alias) {
    return $ActiveSessionsTable(attachedDatabase, alias);
  }
}

class ActiveSession extends DataClass implements Insertable<ActiveSession> {
  final String sessionId;
  final String? deviceId;
  final String? userId;
  final String token;
  final String? ipAddress;
  final DateTime startedAt;
  final DateTime lastActivity;
  const ActiveSession({
    required this.sessionId,
    this.deviceId,
    this.userId,
    required this.token,
    this.ipAddress,
    required this.startedAt,
    required this.lastActivity,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['session_id'] = Variable<String>(sessionId);
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<String>(userId);
    }
    map['token'] = Variable<String>(token);
    if (!nullToAbsent || ipAddress != null) {
      map['ip_address'] = Variable<String>(ipAddress);
    }
    map['started_at'] = Variable<DateTime>(startedAt);
    map['last_activity'] = Variable<DateTime>(lastActivity);
    return map;
  }

  ActiveSessionsCompanion toCompanion(bool nullToAbsent) {
    return ActiveSessionsCompanion(
      sessionId: Value(sessionId),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      userId: userId == null && nullToAbsent
          ? const Value.absent()
          : Value(userId),
      token: Value(token),
      ipAddress: ipAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(ipAddress),
      startedAt: Value(startedAt),
      lastActivity: Value(lastActivity),
    );
  }

  factory ActiveSession.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ActiveSession(
      sessionId: serializer.fromJson<String>(json['sessionId']),
      deviceId: serializer.fromJson<String?>(json['deviceId']),
      userId: serializer.fromJson<String?>(json['userId']),
      token: serializer.fromJson<String>(json['token']),
      ipAddress: serializer.fromJson<String?>(json['ipAddress']),
      startedAt: serializer.fromJson<DateTime>(json['startedAt']),
      lastActivity: serializer.fromJson<DateTime>(json['lastActivity']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'sessionId': serializer.toJson<String>(sessionId),
      'deviceId': serializer.toJson<String?>(deviceId),
      'userId': serializer.toJson<String?>(userId),
      'token': serializer.toJson<String>(token),
      'ipAddress': serializer.toJson<String?>(ipAddress),
      'startedAt': serializer.toJson<DateTime>(startedAt),
      'lastActivity': serializer.toJson<DateTime>(lastActivity),
    };
  }

  ActiveSession copyWith({
    String? sessionId,
    Value<String?> deviceId = const Value.absent(),
    Value<String?> userId = const Value.absent(),
    String? token,
    Value<String?> ipAddress = const Value.absent(),
    DateTime? startedAt,
    DateTime? lastActivity,
  }) => ActiveSession(
    sessionId: sessionId ?? this.sessionId,
    deviceId: deviceId.present ? deviceId.value : this.deviceId,
    userId: userId.present ? userId.value : this.userId,
    token: token ?? this.token,
    ipAddress: ipAddress.present ? ipAddress.value : this.ipAddress,
    startedAt: startedAt ?? this.startedAt,
    lastActivity: lastActivity ?? this.lastActivity,
  );
  ActiveSession copyWithCompanion(ActiveSessionsCompanion data) {
    return ActiveSession(
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      deviceId: data.deviceId.present ? data.deviceId.value : this.deviceId,
      userId: data.userId.present ? data.userId.value : this.userId,
      token: data.token.present ? data.token.value : this.token,
      ipAddress: data.ipAddress.present ? data.ipAddress.value : this.ipAddress,
      startedAt: data.startedAt.present ? data.startedAt.value : this.startedAt,
      lastActivity: data.lastActivity.present
          ? data.lastActivity.value
          : this.lastActivity,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ActiveSession(')
          ..write('sessionId: $sessionId, ')
          ..write('deviceId: $deviceId, ')
          ..write('userId: $userId, ')
          ..write('token: $token, ')
          ..write('ipAddress: $ipAddress, ')
          ..write('startedAt: $startedAt, ')
          ..write('lastActivity: $lastActivity')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    sessionId,
    deviceId,
    userId,
    token,
    ipAddress,
    startedAt,
    lastActivity,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ActiveSession &&
          other.sessionId == this.sessionId &&
          other.deviceId == this.deviceId &&
          other.userId == this.userId &&
          other.token == this.token &&
          other.ipAddress == this.ipAddress &&
          other.startedAt == this.startedAt &&
          other.lastActivity == this.lastActivity);
}

class ActiveSessionsCompanion extends UpdateCompanion<ActiveSession> {
  final Value<String> sessionId;
  final Value<String?> deviceId;
  final Value<String?> userId;
  final Value<String> token;
  final Value<String?> ipAddress;
  final Value<DateTime> startedAt;
  final Value<DateTime> lastActivity;
  final Value<int> rowid;
  const ActiveSessionsCompanion({
    this.sessionId = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.userId = const Value.absent(),
    this.token = const Value.absent(),
    this.ipAddress = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.lastActivity = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActiveSessionsCompanion.insert({
    required String sessionId,
    this.deviceId = const Value.absent(),
    this.userId = const Value.absent(),
    required String token,
    this.ipAddress = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.lastActivity = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : sessionId = Value(sessionId),
       token = Value(token);
  static Insertable<ActiveSession> custom({
    Expression<String>? sessionId,
    Expression<String>? deviceId,
    Expression<String>? userId,
    Expression<String>? token,
    Expression<String>? ipAddress,
    Expression<DateTime>? startedAt,
    Expression<DateTime>? lastActivity,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (sessionId != null) 'session_id': sessionId,
      if (deviceId != null) 'device_id': deviceId,
      if (userId != null) 'user_id': userId,
      if (token != null) 'token': token,
      if (ipAddress != null) 'ip_address': ipAddress,
      if (startedAt != null) 'started_at': startedAt,
      if (lastActivity != null) 'last_activity': lastActivity,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActiveSessionsCompanion copyWith({
    Value<String>? sessionId,
    Value<String?>? deviceId,
    Value<String?>? userId,
    Value<String>? token,
    Value<String?>? ipAddress,
    Value<DateTime>? startedAt,
    Value<DateTime>? lastActivity,
    Value<int>? rowid,
  }) {
    return ActiveSessionsCompanion(
      sessionId: sessionId ?? this.sessionId,
      deviceId: deviceId ?? this.deviceId,
      userId: userId ?? this.userId,
      token: token ?? this.token,
      ipAddress: ipAddress ?? this.ipAddress,
      startedAt: startedAt ?? this.startedAt,
      lastActivity: lastActivity ?? this.lastActivity,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (token.present) {
      map['token'] = Variable<String>(token.value);
    }
    if (ipAddress.present) {
      map['ip_address'] = Variable<String>(ipAddress.value);
    }
    if (startedAt.present) {
      map['started_at'] = Variable<DateTime>(startedAt.value);
    }
    if (lastActivity.present) {
      map['last_activity'] = Variable<DateTime>(lastActivity.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActiveSessionsCompanion(')
          ..write('sessionId: $sessionId, ')
          ..write('deviceId: $deviceId, ')
          ..write('userId: $userId, ')
          ..write('token: $token, ')
          ..write('ipAddress: $ipAddress, ')
          ..write('startedAt: $startedAt, ')
          ..write('lastActivity: $lastActivity, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SyncQueuesTable extends SyncQueues
    with TableInfo<$SyncQueuesTable, SyncQueue> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncQueuesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _queueIdMeta = const VerificationMeta(
    'queueId',
  );
  @override
  late final GeneratedColumn<String> queueId = GeneratedColumn<String>(
    'queue_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deviceIdMeta = const VerificationMeta(
    'deviceId',
  );
  @override
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
    'device_id',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tableNameValueMeta = const VerificationMeta(
    'tableNameValue',
  );
  @override
  late final GeneratedColumn<String> tableNameValue = GeneratedColumn<String>(
    'table_name_value',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _recordIdMeta = const VerificationMeta(
    'recordId',
  );
  @override
  late final GeneratedColumn<String> recordId = GeneratedColumn<String>(
    'record_id',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _operationMeta = const VerificationMeta(
    'operation',
  );
  @override
  late final GeneratedColumn<String> operation = GeneratedColumn<String>(
    'operation',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 10),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  data = GeneratedColumn<String>(
    'data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($SyncQueuesTable.$converterdatan);
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<String> syncStatus = GeneratedColumn<String>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('PENDING'),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _syncedAtMeta = const VerificationMeta(
    'syncedAt',
  );
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
    'synced_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    queueId,
    deviceId,
    tableNameValue,
    recordId,
    operation,
    data,
    syncStatus,
    createdAt,
    syncedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_queues';
  @override
  VerificationContext validateIntegrity(
    Insertable<SyncQueue> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('queue_id')) {
      context.handle(
        _queueIdMeta,
        queueId.isAcceptableOrUnknown(data['queue_id']!, _queueIdMeta),
      );
    } else if (isInserting) {
      context.missing(_queueIdMeta);
    }
    if (data.containsKey('device_id')) {
      context.handle(
        _deviceIdMeta,
        deviceId.isAcceptableOrUnknown(data['device_id']!, _deviceIdMeta),
      );
    } else if (isInserting) {
      context.missing(_deviceIdMeta);
    }
    if (data.containsKey('table_name_value')) {
      context.handle(
        _tableNameValueMeta,
        tableNameValue.isAcceptableOrUnknown(
          data['table_name_value']!,
          _tableNameValueMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_tableNameValueMeta);
    }
    if (data.containsKey('record_id')) {
      context.handle(
        _recordIdMeta,
        recordId.isAcceptableOrUnknown(data['record_id']!, _recordIdMeta),
      );
    } else if (isInserting) {
      context.missing(_recordIdMeta);
    }
    if (data.containsKey('operation')) {
      context.handle(
        _operationMeta,
        operation.isAcceptableOrUnknown(data['operation']!, _operationMeta),
      );
    } else if (isInserting) {
      context.missing(_operationMeta);
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('synced_at')) {
      context.handle(
        _syncedAtMeta,
        syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {queueId};
  @override
  SyncQueue map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncQueue(
      queueId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}queue_id'],
      )!,
      deviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}device_id'],
      )!,
      tableNameValue: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}table_name_value'],
      )!,
      recordId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}record_id'],
      )!,
      operation: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation'],
      )!,
      data: $SyncQueuesTable.$converterdatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}data'],
        ),
      ),
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_status'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      syncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}synced_at'],
      ),
    );
  }

  @override
  $SyncQueuesTable createAlias(String alias) {
    return $SyncQueuesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $converterdata =
      const JsonConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $converterdatan =
      NullAwareTypeConverter.wrap($converterdata);
}

class SyncQueue extends DataClass implements Insertable<SyncQueue> {
  final String queueId;
  final String deviceId;
  final String tableNameValue;
  final String recordId;
  final String operation;
  final Map<String, dynamic>? data;
  final String syncStatus;
  final DateTime createdAt;
  final DateTime? syncedAt;
  const SyncQueue({
    required this.queueId,
    required this.deviceId,
    required this.tableNameValue,
    required this.recordId,
    required this.operation,
    this.data,
    required this.syncStatus,
    required this.createdAt,
    this.syncedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['queue_id'] = Variable<String>(queueId);
    map['device_id'] = Variable<String>(deviceId);
    map['table_name_value'] = Variable<String>(tableNameValue);
    map['record_id'] = Variable<String>(recordId);
    map['operation'] = Variable<String>(operation);
    if (!nullToAbsent || data != null) {
      map['data'] = Variable<String>(
        $SyncQueuesTable.$converterdatan.toSql(data),
      );
    }
    map['sync_status'] = Variable<String>(syncStatus);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    return map;
  }

  SyncQueuesCompanion toCompanion(bool nullToAbsent) {
    return SyncQueuesCompanion(
      queueId: Value(queueId),
      deviceId: Value(deviceId),
      tableNameValue: Value(tableNameValue),
      recordId: Value(recordId),
      operation: Value(operation),
      data: data == null && nullToAbsent ? const Value.absent() : Value(data),
      syncStatus: Value(syncStatus),
      createdAt: Value(createdAt),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
    );
  }

  factory SyncQueue.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncQueue(
      queueId: serializer.fromJson<String>(json['queueId']),
      deviceId: serializer.fromJson<String>(json['deviceId']),
      tableNameValue: serializer.fromJson<String>(json['tableNameValue']),
      recordId: serializer.fromJson<String>(json['recordId']),
      operation: serializer.fromJson<String>(json['operation']),
      data: serializer.fromJson<Map<String, dynamic>?>(json['data']),
      syncStatus: serializer.fromJson<String>(json['syncStatus']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'queueId': serializer.toJson<String>(queueId),
      'deviceId': serializer.toJson<String>(deviceId),
      'tableNameValue': serializer.toJson<String>(tableNameValue),
      'recordId': serializer.toJson<String>(recordId),
      'operation': serializer.toJson<String>(operation),
      'data': serializer.toJson<Map<String, dynamic>?>(data),
      'syncStatus': serializer.toJson<String>(syncStatus),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
    };
  }

  SyncQueue copyWith({
    String? queueId,
    String? deviceId,
    String? tableNameValue,
    String? recordId,
    String? operation,
    Value<Map<String, dynamic>?> data = const Value.absent(),
    String? syncStatus,
    DateTime? createdAt,
    Value<DateTime?> syncedAt = const Value.absent(),
  }) => SyncQueue(
    queueId: queueId ?? this.queueId,
    deviceId: deviceId ?? this.deviceId,
    tableNameValue: tableNameValue ?? this.tableNameValue,
    recordId: recordId ?? this.recordId,
    operation: operation ?? this.operation,
    data: data.present ? data.value : this.data,
    syncStatus: syncStatus ?? this.syncStatus,
    createdAt: createdAt ?? this.createdAt,
    syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
  );
  SyncQueue copyWithCompanion(SyncQueuesCompanion data) {
    return SyncQueue(
      queueId: data.queueId.present ? data.queueId.value : this.queueId,
      deviceId: data.deviceId.present ? data.deviceId.value : this.deviceId,
      tableNameValue: data.tableNameValue.present
          ? data.tableNameValue.value
          : this.tableNameValue,
      recordId: data.recordId.present ? data.recordId.value : this.recordId,
      operation: data.operation.present ? data.operation.value : this.operation,
      data: data.data.present ? data.data.value : this.data,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueue(')
          ..write('queueId: $queueId, ')
          ..write('deviceId: $deviceId, ')
          ..write('tableNameValue: $tableNameValue, ')
          ..write('recordId: $recordId, ')
          ..write('operation: $operation, ')
          ..write('data: $data, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('createdAt: $createdAt, ')
          ..write('syncedAt: $syncedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    queueId,
    deviceId,
    tableNameValue,
    recordId,
    operation,
    data,
    syncStatus,
    createdAt,
    syncedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncQueue &&
          other.queueId == this.queueId &&
          other.deviceId == this.deviceId &&
          other.tableNameValue == this.tableNameValue &&
          other.recordId == this.recordId &&
          other.operation == this.operation &&
          other.data == this.data &&
          other.syncStatus == this.syncStatus &&
          other.createdAt == this.createdAt &&
          other.syncedAt == this.syncedAt);
}

class SyncQueuesCompanion extends UpdateCompanion<SyncQueue> {
  final Value<String> queueId;
  final Value<String> deviceId;
  final Value<String> tableNameValue;
  final Value<String> recordId;
  final Value<String> operation;
  final Value<Map<String, dynamic>?> data;
  final Value<String> syncStatus;
  final Value<DateTime> createdAt;
  final Value<DateTime?> syncedAt;
  final Value<int> rowid;
  const SyncQueuesCompanion({
    this.queueId = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.tableNameValue = const Value.absent(),
    this.recordId = const Value.absent(),
    this.operation = const Value.absent(),
    this.data = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SyncQueuesCompanion.insert({
    required String queueId,
    required String deviceId,
    required String tableNameValue,
    required String recordId,
    required String operation,
    this.data = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : queueId = Value(queueId),
       deviceId = Value(deviceId),
       tableNameValue = Value(tableNameValue),
       recordId = Value(recordId),
       operation = Value(operation);
  static Insertable<SyncQueue> custom({
    Expression<String>? queueId,
    Expression<String>? deviceId,
    Expression<String>? tableNameValue,
    Expression<String>? recordId,
    Expression<String>? operation,
    Expression<String>? data,
    Expression<String>? syncStatus,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? syncedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (queueId != null) 'queue_id': queueId,
      if (deviceId != null) 'device_id': deviceId,
      if (tableNameValue != null) 'table_name_value': tableNameValue,
      if (recordId != null) 'record_id': recordId,
      if (operation != null) 'operation': operation,
      if (data != null) 'data': data,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (createdAt != null) 'created_at': createdAt,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SyncQueuesCompanion copyWith({
    Value<String>? queueId,
    Value<String>? deviceId,
    Value<String>? tableNameValue,
    Value<String>? recordId,
    Value<String>? operation,
    Value<Map<String, dynamic>?>? data,
    Value<String>? syncStatus,
    Value<DateTime>? createdAt,
    Value<DateTime?>? syncedAt,
    Value<int>? rowid,
  }) {
    return SyncQueuesCompanion(
      queueId: queueId ?? this.queueId,
      deviceId: deviceId ?? this.deviceId,
      tableNameValue: tableNameValue ?? this.tableNameValue,
      recordId: recordId ?? this.recordId,
      operation: operation ?? this.operation,
      data: data ?? this.data,
      syncStatus: syncStatus ?? this.syncStatus,
      createdAt: createdAt ?? this.createdAt,
      syncedAt: syncedAt ?? this.syncedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (queueId.present) {
      map['queue_id'] = Variable<String>(queueId.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (tableNameValue.present) {
      map['table_name_value'] = Variable<String>(tableNameValue.value);
    }
    if (recordId.present) {
      map['record_id'] = Variable<String>(recordId.value);
    }
    if (operation.present) {
      map['operation'] = Variable<String>(operation.value);
    }
    if (data.present) {
      map['data'] = Variable<String>(
        $SyncQueuesTable.$converterdatan.toSql(data.value),
      );
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<String>(syncStatus.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueuesCompanion(')
          ..write('queueId: $queueId, ')
          ..write('deviceId: $deviceId, ')
          ..write('tableNameValue: $tableNameValue, ')
          ..write('recordId: $recordId, ')
          ..write('operation: $operation, ')
          ..write('data: $data, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('createdAt: $createdAt, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AuditLogsTable extends AuditLogs
    with TableInfo<$AuditLogsTable, AuditLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AuditLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _logIdMeta = const VerificationMeta('logId');
  @override
  late final GeneratedColumn<String> logId = GeneratedColumn<String>(
    'log_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tableNameValueMeta = const VerificationMeta(
    'tableNameValue',
  );
  @override
  late final GeneratedColumn<String> tableNameValue = GeneratedColumn<String>(
    'table_name_value',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _recordIdMeta = const VerificationMeta(
    'recordId',
  );
  @override
  late final GeneratedColumn<String> recordId = GeneratedColumn<String>(
    'record_id',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
    'action',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  oldValue = GeneratedColumn<String>(
    'old_value',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($AuditLogsTable.$converteroldValuen);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  newValue = GeneratedColumn<String>(
    'new_value',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($AuditLogsTable.$converternewValuen);
  static const VerificationMeta _ipAddressMeta = const VerificationMeta(
    'ipAddress',
  );
  @override
  late final GeneratedColumn<String> ipAddress = GeneratedColumn<String>(
    'ip_address',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    logId,
    tableNameValue,
    recordId,
    action,
    userId,
    oldValue,
    newValue,
    ipAddress,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'audit_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<AuditLog> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('log_id')) {
      context.handle(
        _logIdMeta,
        logId.isAcceptableOrUnknown(data['log_id']!, _logIdMeta),
      );
    } else if (isInserting) {
      context.missing(_logIdMeta);
    }
    if (data.containsKey('table_name_value')) {
      context.handle(
        _tableNameValueMeta,
        tableNameValue.isAcceptableOrUnknown(
          data['table_name_value']!,
          _tableNameValueMeta,
        ),
      );
    }
    if (data.containsKey('record_id')) {
      context.handle(
        _recordIdMeta,
        recordId.isAcceptableOrUnknown(data['record_id']!, _recordIdMeta),
      );
    }
    if (data.containsKey('action')) {
      context.handle(
        _actionMeta,
        action.isAcceptableOrUnknown(data['action']!, _actionMeta),
      );
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    }
    if (data.containsKey('ip_address')) {
      context.handle(
        _ipAddressMeta,
        ipAddress.isAcceptableOrUnknown(data['ip_address']!, _ipAddressMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {logId};
  @override
  AuditLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AuditLog(
      logId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}log_id'],
      )!,
      tableNameValue: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}table_name_value'],
      ),
      recordId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}record_id'],
      ),
      action: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action'],
      ),
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      ),
      oldValue: $AuditLogsTable.$converteroldValuen.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}old_value'],
        ),
      ),
      newValue: $AuditLogsTable.$converternewValuen.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}new_value'],
        ),
      ),
      ipAddress: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ip_address'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $AuditLogsTable createAlias(String alias) {
    return $AuditLogsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $converteroldValue =
      const JsonConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $converteroldValuen =
      NullAwareTypeConverter.wrap($converteroldValue);
  static TypeConverter<Map<String, dynamic>, String> $converternewValue =
      const JsonConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $converternewValuen =
      NullAwareTypeConverter.wrap($converternewValue);
}

class AuditLog extends DataClass implements Insertable<AuditLog> {
  final String logId;
  final String? tableNameValue;
  final String? recordId;
  final String? action;
  final String? userId;
  final Map<String, dynamic>? oldValue;
  final Map<String, dynamic>? newValue;
  final String? ipAddress;
  final DateTime createdAt;
  const AuditLog({
    required this.logId,
    this.tableNameValue,
    this.recordId,
    this.action,
    this.userId,
    this.oldValue,
    this.newValue,
    this.ipAddress,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['log_id'] = Variable<String>(logId);
    if (!nullToAbsent || tableNameValue != null) {
      map['table_name_value'] = Variable<String>(tableNameValue);
    }
    if (!nullToAbsent || recordId != null) {
      map['record_id'] = Variable<String>(recordId);
    }
    if (!nullToAbsent || action != null) {
      map['action'] = Variable<String>(action);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<String>(userId);
    }
    if (!nullToAbsent || oldValue != null) {
      map['old_value'] = Variable<String>(
        $AuditLogsTable.$converteroldValuen.toSql(oldValue),
      );
    }
    if (!nullToAbsent || newValue != null) {
      map['new_value'] = Variable<String>(
        $AuditLogsTable.$converternewValuen.toSql(newValue),
      );
    }
    if (!nullToAbsent || ipAddress != null) {
      map['ip_address'] = Variable<String>(ipAddress);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  AuditLogsCompanion toCompanion(bool nullToAbsent) {
    return AuditLogsCompanion(
      logId: Value(logId),
      tableNameValue: tableNameValue == null && nullToAbsent
          ? const Value.absent()
          : Value(tableNameValue),
      recordId: recordId == null && nullToAbsent
          ? const Value.absent()
          : Value(recordId),
      action: action == null && nullToAbsent
          ? const Value.absent()
          : Value(action),
      userId: userId == null && nullToAbsent
          ? const Value.absent()
          : Value(userId),
      oldValue: oldValue == null && nullToAbsent
          ? const Value.absent()
          : Value(oldValue),
      newValue: newValue == null && nullToAbsent
          ? const Value.absent()
          : Value(newValue),
      ipAddress: ipAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(ipAddress),
      createdAt: Value(createdAt),
    );
  }

  factory AuditLog.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AuditLog(
      logId: serializer.fromJson<String>(json['logId']),
      tableNameValue: serializer.fromJson<String?>(json['tableNameValue']),
      recordId: serializer.fromJson<String?>(json['recordId']),
      action: serializer.fromJson<String?>(json['action']),
      userId: serializer.fromJson<String?>(json['userId']),
      oldValue: serializer.fromJson<Map<String, dynamic>?>(json['oldValue']),
      newValue: serializer.fromJson<Map<String, dynamic>?>(json['newValue']),
      ipAddress: serializer.fromJson<String?>(json['ipAddress']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'logId': serializer.toJson<String>(logId),
      'tableNameValue': serializer.toJson<String?>(tableNameValue),
      'recordId': serializer.toJson<String?>(recordId),
      'action': serializer.toJson<String?>(action),
      'userId': serializer.toJson<String?>(userId),
      'oldValue': serializer.toJson<Map<String, dynamic>?>(oldValue),
      'newValue': serializer.toJson<Map<String, dynamic>?>(newValue),
      'ipAddress': serializer.toJson<String?>(ipAddress),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  AuditLog copyWith({
    String? logId,
    Value<String?> tableNameValue = const Value.absent(),
    Value<String?> recordId = const Value.absent(),
    Value<String?> action = const Value.absent(),
    Value<String?> userId = const Value.absent(),
    Value<Map<String, dynamic>?> oldValue = const Value.absent(),
    Value<Map<String, dynamic>?> newValue = const Value.absent(),
    Value<String?> ipAddress = const Value.absent(),
    DateTime? createdAt,
  }) => AuditLog(
    logId: logId ?? this.logId,
    tableNameValue: tableNameValue.present
        ? tableNameValue.value
        : this.tableNameValue,
    recordId: recordId.present ? recordId.value : this.recordId,
    action: action.present ? action.value : this.action,
    userId: userId.present ? userId.value : this.userId,
    oldValue: oldValue.present ? oldValue.value : this.oldValue,
    newValue: newValue.present ? newValue.value : this.newValue,
    ipAddress: ipAddress.present ? ipAddress.value : this.ipAddress,
    createdAt: createdAt ?? this.createdAt,
  );
  AuditLog copyWithCompanion(AuditLogsCompanion data) {
    return AuditLog(
      logId: data.logId.present ? data.logId.value : this.logId,
      tableNameValue: data.tableNameValue.present
          ? data.tableNameValue.value
          : this.tableNameValue,
      recordId: data.recordId.present ? data.recordId.value : this.recordId,
      action: data.action.present ? data.action.value : this.action,
      userId: data.userId.present ? data.userId.value : this.userId,
      oldValue: data.oldValue.present ? data.oldValue.value : this.oldValue,
      newValue: data.newValue.present ? data.newValue.value : this.newValue,
      ipAddress: data.ipAddress.present ? data.ipAddress.value : this.ipAddress,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AuditLog(')
          ..write('logId: $logId, ')
          ..write('tableNameValue: $tableNameValue, ')
          ..write('recordId: $recordId, ')
          ..write('action: $action, ')
          ..write('userId: $userId, ')
          ..write('oldValue: $oldValue, ')
          ..write('newValue: $newValue, ')
          ..write('ipAddress: $ipAddress, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    logId,
    tableNameValue,
    recordId,
    action,
    userId,
    oldValue,
    newValue,
    ipAddress,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AuditLog &&
          other.logId == this.logId &&
          other.tableNameValue == this.tableNameValue &&
          other.recordId == this.recordId &&
          other.action == this.action &&
          other.userId == this.userId &&
          other.oldValue == this.oldValue &&
          other.newValue == this.newValue &&
          other.ipAddress == this.ipAddress &&
          other.createdAt == this.createdAt);
}

class AuditLogsCompanion extends UpdateCompanion<AuditLog> {
  final Value<String> logId;
  final Value<String?> tableNameValue;
  final Value<String?> recordId;
  final Value<String?> action;
  final Value<String?> userId;
  final Value<Map<String, dynamic>?> oldValue;
  final Value<Map<String, dynamic>?> newValue;
  final Value<String?> ipAddress;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const AuditLogsCompanion({
    this.logId = const Value.absent(),
    this.tableNameValue = const Value.absent(),
    this.recordId = const Value.absent(),
    this.action = const Value.absent(),
    this.userId = const Value.absent(),
    this.oldValue = const Value.absent(),
    this.newValue = const Value.absent(),
    this.ipAddress = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AuditLogsCompanion.insert({
    required String logId,
    this.tableNameValue = const Value.absent(),
    this.recordId = const Value.absent(),
    this.action = const Value.absent(),
    this.userId = const Value.absent(),
    this.oldValue = const Value.absent(),
    this.newValue = const Value.absent(),
    this.ipAddress = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : logId = Value(logId);
  static Insertable<AuditLog> custom({
    Expression<String>? logId,
    Expression<String>? tableNameValue,
    Expression<String>? recordId,
    Expression<String>? action,
    Expression<String>? userId,
    Expression<String>? oldValue,
    Expression<String>? newValue,
    Expression<String>? ipAddress,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (logId != null) 'log_id': logId,
      if (tableNameValue != null) 'table_name_value': tableNameValue,
      if (recordId != null) 'record_id': recordId,
      if (action != null) 'action': action,
      if (userId != null) 'user_id': userId,
      if (oldValue != null) 'old_value': oldValue,
      if (newValue != null) 'new_value': newValue,
      if (ipAddress != null) 'ip_address': ipAddress,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AuditLogsCompanion copyWith({
    Value<String>? logId,
    Value<String?>? tableNameValue,
    Value<String?>? recordId,
    Value<String?>? action,
    Value<String?>? userId,
    Value<Map<String, dynamic>?>? oldValue,
    Value<Map<String, dynamic>?>? newValue,
    Value<String?>? ipAddress,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return AuditLogsCompanion(
      logId: logId ?? this.logId,
      tableNameValue: tableNameValue ?? this.tableNameValue,
      recordId: recordId ?? this.recordId,
      action: action ?? this.action,
      userId: userId ?? this.userId,
      oldValue: oldValue ?? this.oldValue,
      newValue: newValue ?? this.newValue,
      ipAddress: ipAddress ?? this.ipAddress,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (logId.present) {
      map['log_id'] = Variable<String>(logId.value);
    }
    if (tableNameValue.present) {
      map['table_name_value'] = Variable<String>(tableNameValue.value);
    }
    if (recordId.present) {
      map['record_id'] = Variable<String>(recordId.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (oldValue.present) {
      map['old_value'] = Variable<String>(
        $AuditLogsTable.$converteroldValuen.toSql(oldValue.value),
      );
    }
    if (newValue.present) {
      map['new_value'] = Variable<String>(
        $AuditLogsTable.$converternewValuen.toSql(newValue.value),
      );
    }
    if (ipAddress.present) {
      map['ip_address'] = Variable<String>(ipAddress.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AuditLogsCompanion(')
          ..write('logId: $logId, ')
          ..write('tableNameValue: $tableNameValue, ')
          ..write('recordId: $recordId, ')
          ..write('action: $action, ')
          ..write('userId: $userId, ')
          ..write('oldValue: $oldValue, ')
          ..write('newValue: $newValue, ')
          ..write('ipAddress: $ipAddress, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $CompaniesTable companies = $CompaniesTable(this);
  late final $BranchesTable branches = $BranchesTable(this);
  late final $RolesTable roles = $RolesTable(this);
  late final $UsersTable users = $UsersTable(this);
  late final $ProductGroupsTable productGroups = $ProductGroupsTable(this);
  late final $ProductsTable products = $ProductsTable(this);
  late final $WarehousesTable warehouses = $WarehousesTable(this);
  late final $StockBalancesTable stockBalances = $StockBalancesTable(this);
  late final $SerialNumbersTable serialNumbers = $SerialNumbersTable(this);
  late final $ModifierGroupsTable modifierGroups = $ModifierGroupsTable(this);
  late final $ModifiersTable modifiers = $ModifiersTable(this);
  late final $ProductModifiersTable productModifiers = $ProductModifiersTable(
    this,
  );
  late final $ZonesTable zones = $ZonesTable(this);
  late final $DiningTablesTable diningTables = $DiningTablesTable(this);
  late final $CustomerGroupsTable customerGroups = $CustomerGroupsTable(this);
  late final $CustomersTable customers = $CustomersTable(this);
  late final $SuppliersTable suppliers = $SuppliersTable(this);
  late final $SalesOrdersTable salesOrders = $SalesOrdersTable(this);
  late final $SalesOrderItemsTable salesOrderItems = $SalesOrderItemsTable(
    this,
  );
  late final $OrderItemModifiersTable orderItemModifiers =
      $OrderItemModifiersTable(this);
  late final $PurchaseOrdersTable purchaseOrders = $PurchaseOrdersTable(this);
  late final $PurchaseOrderItemsTable purchaseOrderItems =
      $PurchaseOrderItemsTable(this);
  late final $StockMovementsTable stockMovements = $StockMovementsTable(this);
  late final $PromotionsTable promotions = $PromotionsTable(this);
  late final $PromotionUsagesTable promotionUsages = $PromotionUsagesTable(
    this,
  );
  late final $CouponsTable coupons = $CouponsTable(this);
  late final $ArInvoicesTable arInvoices = $ArInvoicesTable(this);
  late final $ArReceiptsTable arReceipts = $ArReceiptsTable(this);
  late final $ArReceiptAllocationsTable arReceiptAllocations =
      $ArReceiptAllocationsTable(this);
  late final $ApInvoicesTable apInvoices = $ApInvoicesTable(this);
  late final $ApPaymentsTable apPayments = $ApPaymentsTable(this);
  late final $ApPaymentAllocationsTable apPaymentAllocations =
      $ApPaymentAllocationsTable(this);
  late final $DevicesTable devices = $DevicesTable(this);
  late final $ActiveSessionsTable activeSessions = $ActiveSessionsTable(this);
  late final $SyncQueuesTable syncQueues = $SyncQueuesTable(this);
  late final $AuditLogsTable auditLogs = $AuditLogsTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    companies,
    branches,
    roles,
    users,
    productGroups,
    products,
    warehouses,
    stockBalances,
    serialNumbers,
    modifierGroups,
    modifiers,
    productModifiers,
    zones,
    diningTables,
    customerGroups,
    customers,
    suppliers,
    salesOrders,
    salesOrderItems,
    orderItemModifiers,
    purchaseOrders,
    purchaseOrderItems,
    stockMovements,
    promotions,
    promotionUsages,
    coupons,
    arInvoices,
    arReceipts,
    arReceiptAllocations,
    apInvoices,
    apPayments,
    apPaymentAllocations,
    devices,
    activeSessions,
    syncQueues,
    auditLogs,
  ];
  @override
  StreamQueryUpdateRules get streamUpdateRules => const StreamQueryUpdateRules([
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'sales_orders',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('sales_order_items', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'sales_order_items',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('order_item_modifiers', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'purchase_orders',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('purchase_order_items', kind: UpdateKind.delete)],
    ),
  ]);
}

typedef $$CompaniesTableCreateCompanionBuilder =
    CompaniesCompanion Function({
      required String companyId,
      required String companyName,
      Value<String?> taxId,
      Value<String?> address,
      Value<String?> phone,
      Value<String?> logoUrl,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$CompaniesTableUpdateCompanionBuilder =
    CompaniesCompanion Function({
      Value<String> companyId,
      Value<String> companyName,
      Value<String?> taxId,
      Value<String?> address,
      Value<String?> phone,
      Value<String?> logoUrl,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$CompaniesTableReferences
    extends BaseReferences<_$AppDatabase, $CompaniesTable, Company> {
  $$CompaniesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$BranchesTable, List<Branch>> _branchesRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.branches,
    aliasName: $_aliasNameGenerator(
      db.companies.companyId,
      db.branches.companyId,
    ),
  );

  $$BranchesTableProcessedTableManager get branchesRefs {
    final manager = $$BranchesTableTableManager($_db, $_db.branches).filter(
      (f) =>
          f.companyId.companyId.sqlEquals($_itemColumn<String>('company_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_branchesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CompaniesTableFilterComposer
    extends Composer<_$AppDatabase, $CompaniesTable> {
  $$CompaniesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get companyId => $composableBuilder(
    column: $table.companyId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get companyName => $composableBuilder(
    column: $table.companyName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get taxId => $composableBuilder(
    column: $table.taxId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get logoUrl => $composableBuilder(
    column: $table.logoUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> branchesRefs(
    Expression<bool> Function($$BranchesTableFilterComposer f) f,
  ) {
    final $$BranchesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.companyId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.companyId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableFilterComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CompaniesTableOrderingComposer
    extends Composer<_$AppDatabase, $CompaniesTable> {
  $$CompaniesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get companyId => $composableBuilder(
    column: $table.companyId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get companyName => $composableBuilder(
    column: $table.companyName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get taxId => $composableBuilder(
    column: $table.taxId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get logoUrl => $composableBuilder(
    column: $table.logoUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CompaniesTableAnnotationComposer
    extends Composer<_$AppDatabase, $CompaniesTable> {
  $$CompaniesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get companyId =>
      $composableBuilder(column: $table.companyId, builder: (column) => column);

  GeneratedColumn<String> get companyName => $composableBuilder(
    column: $table.companyName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get taxId =>
      $composableBuilder(column: $table.taxId, builder: (column) => column);

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get logoUrl =>
      $composableBuilder(column: $table.logoUrl, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> branchesRefs<T extends Object>(
    Expression<T> Function($$BranchesTableAnnotationComposer a) f,
  ) {
    final $$BranchesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.companyId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.companyId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableAnnotationComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CompaniesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CompaniesTable,
          Company,
          $$CompaniesTableFilterComposer,
          $$CompaniesTableOrderingComposer,
          $$CompaniesTableAnnotationComposer,
          $$CompaniesTableCreateCompanionBuilder,
          $$CompaniesTableUpdateCompanionBuilder,
          (Company, $$CompaniesTableReferences),
          Company,
          PrefetchHooks Function({bool branchesRefs})
        > {
  $$CompaniesTableTableManager(_$AppDatabase db, $CompaniesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CompaniesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CompaniesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CompaniesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> companyId = const Value.absent(),
                Value<String> companyName = const Value.absent(),
                Value<String?> taxId = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> logoUrl = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CompaniesCompanion(
                companyId: companyId,
                companyName: companyName,
                taxId: taxId,
                address: address,
                phone: phone,
                logoUrl: logoUrl,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String companyId,
                required String companyName,
                Value<String?> taxId = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> logoUrl = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CompaniesCompanion.insert(
                companyId: companyId,
                companyName: companyName,
                taxId: taxId,
                address: address,
                phone: phone,
                logoUrl: logoUrl,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CompaniesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({branchesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (branchesRefs) db.branches],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (branchesRefs)
                    await $_getPrefetchedData<Company, $CompaniesTable, Branch>(
                      currentTable: table,
                      referencedTable: $$CompaniesTableReferences
                          ._branchesRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$CompaniesTableReferences(
                            db,
                            table,
                            p0,
                          ).branchesRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.companyId == item.companyId,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$CompaniesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CompaniesTable,
      Company,
      $$CompaniesTableFilterComposer,
      $$CompaniesTableOrderingComposer,
      $$CompaniesTableAnnotationComposer,
      $$CompaniesTableCreateCompanionBuilder,
      $$CompaniesTableUpdateCompanionBuilder,
      (Company, $$CompaniesTableReferences),
      Company,
      PrefetchHooks Function({bool branchesRefs})
    >;
typedef $$BranchesTableCreateCompanionBuilder =
    BranchesCompanion Function({
      required String branchId,
      required String companyId,
      required String branchCode,
      required String branchName,
      Value<String?> address,
      Value<String?> phone,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$BranchesTableUpdateCompanionBuilder =
    BranchesCompanion Function({
      Value<String> branchId,
      Value<String> companyId,
      Value<String> branchCode,
      Value<String> branchName,
      Value<String?> address,
      Value<String?> phone,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$BranchesTableReferences
    extends BaseReferences<_$AppDatabase, $BranchesTable, Branch> {
  $$BranchesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $CompaniesTable _companyIdTable(_$AppDatabase db) =>
      db.companies.createAlias(
        $_aliasNameGenerator(db.branches.companyId, db.companies.companyId),
      );

  $$CompaniesTableProcessedTableManager get companyId {
    final $_column = $_itemColumn<String>('company_id')!;

    final manager = $$CompaniesTableTableManager(
      $_db,
      $_db.companies,
    ).filter((f) => f.companyId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_companyIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$UsersTable, List<User>> _usersRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.users,
    aliasName: $_aliasNameGenerator(db.branches.branchId, db.users.branchId),
  );

  $$UsersTableProcessedTableManager get usersRefs {
    final manager = $$UsersTableTableManager($_db, $_db.users).filter(
      (f) => f.branchId.branchId.sqlEquals($_itemColumn<String>('branch_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_usersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$WarehousesTable, List<Warehouse>>
  _warehousesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.warehouses,
    aliasName: $_aliasNameGenerator(
      db.branches.branchId,
      db.warehouses.branchId,
    ),
  );

  $$WarehousesTableProcessedTableManager get warehousesRefs {
    final manager = $$WarehousesTableTableManager($_db, $_db.warehouses).filter(
      (f) => f.branchId.branchId.sqlEquals($_itemColumn<String>('branch_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_warehousesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ZonesTable, List<Zone>> _zonesRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.zones,
    aliasName: $_aliasNameGenerator(db.branches.branchId, db.zones.branchId),
  );

  $$ZonesTableProcessedTableManager get zonesRefs {
    final manager = $$ZonesTableTableManager($_db, $_db.zones).filter(
      (f) => f.branchId.branchId.sqlEquals($_itemColumn<String>('branch_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_zonesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SalesOrdersTable, List<SalesOrder>>
  _salesOrdersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.salesOrders,
    aliasName: $_aliasNameGenerator(
      db.branches.branchId,
      db.salesOrders.branchId,
    ),
  );

  $$SalesOrdersTableProcessedTableManager get salesOrdersRefs {
    final manager = $$SalesOrdersTableTableManager($_db, $_db.salesOrders)
        .filter(
          (f) =>
              f.branchId.branchId.sqlEquals($_itemColumn<String>('branch_id')!),
        );

    final cache = $_typedResult.readTableOrNull(_salesOrdersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PurchaseOrdersTable, List<PurchaseOrder>>
  _purchaseOrdersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.purchaseOrders,
    aliasName: $_aliasNameGenerator(
      db.branches.branchId,
      db.purchaseOrders.branchId,
    ),
  );

  $$PurchaseOrdersTableProcessedTableManager get purchaseOrdersRefs {
    final manager = $$PurchaseOrdersTableTableManager($_db, $_db.purchaseOrders)
        .filter(
          (f) =>
              f.branchId.branchId.sqlEquals($_itemColumn<String>('branch_id')!),
        );

    final cache = $_typedResult.readTableOrNull(_purchaseOrdersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$BranchesTableFilterComposer
    extends Composer<_$AppDatabase, $BranchesTable> {
  $$BranchesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get branchCode => $composableBuilder(
    column: $table.branchCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get branchName => $composableBuilder(
    column: $table.branchName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CompaniesTableFilterComposer get companyId {
    final $$CompaniesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.companyId,
      referencedTable: $db.companies,
      getReferencedColumn: (t) => t.companyId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CompaniesTableFilterComposer(
            $db: $db,
            $table: $db.companies,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> usersRefs(
    Expression<bool> Function($$UsersTableFilterComposer f) f,
  ) {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> warehousesRefs(
    Expression<bool> Function($$WarehousesTableFilterComposer f) f,
  ) {
    final $$WarehousesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableFilterComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> zonesRefs(
    Expression<bool> Function($$ZonesTableFilterComposer f) f,
  ) {
    final $$ZonesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.zones,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ZonesTableFilterComposer(
            $db: $db,
            $table: $db.zones,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> salesOrdersRefs(
    Expression<bool> Function($$SalesOrdersTableFilterComposer f) f,
  ) {
    final $$SalesOrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableFilterComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> purchaseOrdersRefs(
    Expression<bool> Function($$PurchaseOrdersTableFilterComposer f) f,
  ) {
    final $$PurchaseOrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.purchaseOrders,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrdersTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BranchesTableOrderingComposer
    extends Composer<_$AppDatabase, $BranchesTable> {
  $$BranchesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get branchCode => $composableBuilder(
    column: $table.branchCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get branchName => $composableBuilder(
    column: $table.branchName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CompaniesTableOrderingComposer get companyId {
    final $$CompaniesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.companyId,
      referencedTable: $db.companies,
      getReferencedColumn: (t) => t.companyId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CompaniesTableOrderingComposer(
            $db: $db,
            $table: $db.companies,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BranchesTableAnnotationComposer
    extends Composer<_$AppDatabase, $BranchesTable> {
  $$BranchesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get branchId =>
      $composableBuilder(column: $table.branchId, builder: (column) => column);

  GeneratedColumn<String> get branchCode => $composableBuilder(
    column: $table.branchCode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get branchName => $composableBuilder(
    column: $table.branchName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$CompaniesTableAnnotationComposer get companyId {
    final $$CompaniesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.companyId,
      referencedTable: $db.companies,
      getReferencedColumn: (t) => t.companyId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CompaniesTableAnnotationComposer(
            $db: $db,
            $table: $db.companies,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> usersRefs<T extends Object>(
    Expression<T> Function($$UsersTableAnnotationComposer a) f,
  ) {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> warehousesRefs<T extends Object>(
    Expression<T> Function($$WarehousesTableAnnotationComposer a) f,
  ) {
    final $$WarehousesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableAnnotationComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> zonesRefs<T extends Object>(
    Expression<T> Function($$ZonesTableAnnotationComposer a) f,
  ) {
    final $$ZonesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.zones,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ZonesTableAnnotationComposer(
            $db: $db,
            $table: $db.zones,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> salesOrdersRefs<T extends Object>(
    Expression<T> Function($$SalesOrdersTableAnnotationComposer a) f,
  ) {
    final $$SalesOrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> purchaseOrdersRefs<T extends Object>(
    Expression<T> Function($$PurchaseOrdersTableAnnotationComposer a) f,
  ) {
    final $$PurchaseOrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.purchaseOrders,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.purchaseOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BranchesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BranchesTable,
          Branch,
          $$BranchesTableFilterComposer,
          $$BranchesTableOrderingComposer,
          $$BranchesTableAnnotationComposer,
          $$BranchesTableCreateCompanionBuilder,
          $$BranchesTableUpdateCompanionBuilder,
          (Branch, $$BranchesTableReferences),
          Branch,
          PrefetchHooks Function({
            bool companyId,
            bool usersRefs,
            bool warehousesRefs,
            bool zonesRefs,
            bool salesOrdersRefs,
            bool purchaseOrdersRefs,
          })
        > {
  $$BranchesTableTableManager(_$AppDatabase db, $BranchesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BranchesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BranchesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BranchesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> branchId = const Value.absent(),
                Value<String> companyId = const Value.absent(),
                Value<String> branchCode = const Value.absent(),
                Value<String> branchName = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BranchesCompanion(
                branchId: branchId,
                companyId: companyId,
                branchCode: branchCode,
                branchName: branchName,
                address: address,
                phone: phone,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String branchId,
                required String companyId,
                required String branchCode,
                required String branchName,
                Value<String?> address = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BranchesCompanion.insert(
                branchId: branchId,
                companyId: companyId,
                branchCode: branchCode,
                branchName: branchName,
                address: address,
                phone: phone,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$BranchesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                companyId = false,
                usersRefs = false,
                warehousesRefs = false,
                zonesRefs = false,
                salesOrdersRefs = false,
                purchaseOrdersRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (usersRefs) db.users,
                    if (warehousesRefs) db.warehouses,
                    if (zonesRefs) db.zones,
                    if (salesOrdersRefs) db.salesOrders,
                    if (purchaseOrdersRefs) db.purchaseOrders,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (companyId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.companyId,
                                    referencedTable: $$BranchesTableReferences
                                        ._companyIdTable(db),
                                    referencedColumn: $$BranchesTableReferences
                                        ._companyIdTable(db)
                                        .companyId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (usersRefs)
                        await $_getPrefetchedData<Branch, $BranchesTable, User>(
                          currentTable: table,
                          referencedTable: $$BranchesTableReferences
                              ._usersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BranchesTableReferences(
                                db,
                                table,
                                p0,
                              ).usersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.branchId == item.branchId,
                              ),
                          typedResults: items,
                        ),
                      if (warehousesRefs)
                        await $_getPrefetchedData<
                          Branch,
                          $BranchesTable,
                          Warehouse
                        >(
                          currentTable: table,
                          referencedTable: $$BranchesTableReferences
                              ._warehousesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BranchesTableReferences(
                                db,
                                table,
                                p0,
                              ).warehousesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.branchId == item.branchId,
                              ),
                          typedResults: items,
                        ),
                      if (zonesRefs)
                        await $_getPrefetchedData<Branch, $BranchesTable, Zone>(
                          currentTable: table,
                          referencedTable: $$BranchesTableReferences
                              ._zonesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BranchesTableReferences(
                                db,
                                table,
                                p0,
                              ).zonesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.branchId == item.branchId,
                              ),
                          typedResults: items,
                        ),
                      if (salesOrdersRefs)
                        await $_getPrefetchedData<
                          Branch,
                          $BranchesTable,
                          SalesOrder
                        >(
                          currentTable: table,
                          referencedTable: $$BranchesTableReferences
                              ._salesOrdersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BranchesTableReferences(
                                db,
                                table,
                                p0,
                              ).salesOrdersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.branchId == item.branchId,
                              ),
                          typedResults: items,
                        ),
                      if (purchaseOrdersRefs)
                        await $_getPrefetchedData<
                          Branch,
                          $BranchesTable,
                          PurchaseOrder
                        >(
                          currentTable: table,
                          referencedTable: $$BranchesTableReferences
                              ._purchaseOrdersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BranchesTableReferences(
                                db,
                                table,
                                p0,
                              ).purchaseOrdersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.branchId == item.branchId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$BranchesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BranchesTable,
      Branch,
      $$BranchesTableFilterComposer,
      $$BranchesTableOrderingComposer,
      $$BranchesTableAnnotationComposer,
      $$BranchesTableCreateCompanionBuilder,
      $$BranchesTableUpdateCompanionBuilder,
      (Branch, $$BranchesTableReferences),
      Branch,
      PrefetchHooks Function({
        bool companyId,
        bool usersRefs,
        bool warehousesRefs,
        bool zonesRefs,
        bool salesOrdersRefs,
        bool purchaseOrdersRefs,
      })
    >;
typedef $$RolesTableCreateCompanionBuilder =
    RolesCompanion Function({
      required String roleId,
      required String roleName,
      required Map<String, dynamic> permissions,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$RolesTableUpdateCompanionBuilder =
    RolesCompanion Function({
      Value<String> roleId,
      Value<String> roleName,
      Value<Map<String, dynamic>> permissions,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$RolesTableReferences
    extends BaseReferences<_$AppDatabase, $RolesTable, Role> {
  $$RolesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$UsersTable, List<User>> _usersRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.users,
    aliasName: $_aliasNameGenerator(db.roles.roleId, db.users.roleId),
  );

  $$UsersTableProcessedTableManager get usersRefs {
    final manager = $$UsersTableTableManager($_db, $_db.users).filter(
      (f) => f.roleId.roleId.sqlEquals($_itemColumn<String>('role_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_usersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$RolesTableFilterComposer extends Composer<_$AppDatabase, $RolesTable> {
  $$RolesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get roleId => $composableBuilder(
    column: $table.roleId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get roleName => $composableBuilder(
    column: $table.roleName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>,
    Map<String, dynamic>,
    String
  >
  get permissions => $composableBuilder(
    column: $table.permissions,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> usersRefs(
    Expression<bool> Function($$UsersTableFilterComposer f) f,
  ) {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.roleId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.roleId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$RolesTableOrderingComposer
    extends Composer<_$AppDatabase, $RolesTable> {
  $$RolesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get roleId => $composableBuilder(
    column: $table.roleId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get roleName => $composableBuilder(
    column: $table.roleName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get permissions => $composableBuilder(
    column: $table.permissions,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$RolesTableAnnotationComposer
    extends Composer<_$AppDatabase, $RolesTable> {
  $$RolesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get roleId =>
      $composableBuilder(column: $table.roleId, builder: (column) => column);

  GeneratedColumn<String> get roleName =>
      $composableBuilder(column: $table.roleName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>, String>
  get permissions => $composableBuilder(
    column: $table.permissions,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  Expression<T> usersRefs<T extends Object>(
    Expression<T> Function($$UsersTableAnnotationComposer a) f,
  ) {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.roleId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.roleId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$RolesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RolesTable,
          Role,
          $$RolesTableFilterComposer,
          $$RolesTableOrderingComposer,
          $$RolesTableAnnotationComposer,
          $$RolesTableCreateCompanionBuilder,
          $$RolesTableUpdateCompanionBuilder,
          (Role, $$RolesTableReferences),
          Role,
          PrefetchHooks Function({bool usersRefs})
        > {
  $$RolesTableTableManager(_$AppDatabase db, $RolesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RolesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RolesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RolesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> roleId = const Value.absent(),
                Value<String> roleName = const Value.absent(),
                Value<Map<String, dynamic>> permissions = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RolesCompanion(
                roleId: roleId,
                roleName: roleName,
                permissions: permissions,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String roleId,
                required String roleName,
                required Map<String, dynamic> permissions,
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RolesCompanion.insert(
                roleId: roleId,
                roleName: roleName,
                permissions: permissions,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$RolesTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({usersRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (usersRefs) db.users],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (usersRefs)
                    await $_getPrefetchedData<Role, $RolesTable, User>(
                      currentTable: table,
                      referencedTable: $$RolesTableReferences._usersRefsTable(
                        db,
                      ),
                      managerFromTypedResult: (p0) =>
                          $$RolesTableReferences(db, table, p0).usersRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.roleId == item.roleId),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$RolesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RolesTable,
      Role,
      $$RolesTableFilterComposer,
      $$RolesTableOrderingComposer,
      $$RolesTableAnnotationComposer,
      $$RolesTableCreateCompanionBuilder,
      $$RolesTableUpdateCompanionBuilder,
      (Role, $$RolesTableReferences),
      Role,
      PrefetchHooks Function({bool usersRefs})
    >;
typedef $$UsersTableCreateCompanionBuilder =
    UsersCompanion Function({
      required String userId,
      required String username,
      required String passwordHash,
      required String fullName,
      Value<String?> email,
      Value<String?> phone,
      Value<String?> roleId,
      Value<String?> branchId,
      Value<bool> isActive,
      Value<DateTime?> lastLogin,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$UsersTableUpdateCompanionBuilder =
    UsersCompanion Function({
      Value<String> userId,
      Value<String> username,
      Value<String> passwordHash,
      Value<String> fullName,
      Value<String?> email,
      Value<String?> phone,
      Value<String?> roleId,
      Value<String?> branchId,
      Value<bool> isActive,
      Value<DateTime?> lastLogin,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$UsersTableReferences
    extends BaseReferences<_$AppDatabase, $UsersTable, User> {
  $$UsersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $RolesTable _roleIdTable(_$AppDatabase db) => db.roles.createAlias(
    $_aliasNameGenerator(db.users.roleId, db.roles.roleId),
  );

  $$RolesTableProcessedTableManager? get roleId {
    final $_column = $_itemColumn<String>('role_id');
    if ($_column == null) return null;
    final manager = $$RolesTableTableManager(
      $_db,
      $_db.roles,
    ).filter((f) => f.roleId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_roleIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $BranchesTable _branchIdTable(_$AppDatabase db) =>
      db.branches.createAlias(
        $_aliasNameGenerator(db.users.branchId, db.branches.branchId),
      );

  $$BranchesTableProcessedTableManager? get branchId {
    final $_column = $_itemColumn<String>('branch_id');
    if ($_column == null) return null;
    final manager = $$BranchesTableTableManager(
      $_db,
      $_db.branches,
    ).filter((f) => f.branchId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_branchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$SalesOrdersTable, List<SalesOrder>>
  _salesOrdersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.salesOrders,
    aliasName: $_aliasNameGenerator(db.users.userId, db.salesOrders.userId),
  );

  $$SalesOrdersTableProcessedTableManager get salesOrdersRefs {
    final manager = $$SalesOrdersTableTableManager($_db, $_db.salesOrders)
        .filter(
          (f) => f.userId.userId.sqlEquals($_itemColumn<String>('user_id')!),
        );

    final cache = $_typedResult.readTableOrNull(_salesOrdersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PurchaseOrdersTable, List<PurchaseOrder>>
  _purchaseOrdersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.purchaseOrders,
    aliasName: $_aliasNameGenerator(db.users.userId, db.purchaseOrders.userId),
  );

  $$PurchaseOrdersTableProcessedTableManager get purchaseOrdersRefs {
    final manager = $$PurchaseOrdersTableTableManager($_db, $_db.purchaseOrders)
        .filter(
          (f) => f.userId.userId.sqlEquals($_itemColumn<String>('user_id')!),
        );

    final cache = $_typedResult.readTableOrNull(_purchaseOrdersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$StockMovementsTable, List<StockMovement>>
  _stockMovementsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.stockMovements,
    aliasName: $_aliasNameGenerator(db.users.userId, db.stockMovements.userId),
  );

  $$StockMovementsTableProcessedTableManager get stockMovementsRefs {
    final manager = $$StockMovementsTableTableManager($_db, $_db.stockMovements)
        .filter(
          (f) => f.userId.userId.sqlEquals($_itemColumn<String>('user_id')!),
        );

    final cache = $_typedResult.readTableOrNull(_stockMovementsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PromotionsTable, List<Promotion>>
  _promotionsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.promotions,
    aliasName: $_aliasNameGenerator(db.users.userId, db.promotions.createdBy),
  );

  $$PromotionsTableProcessedTableManager get promotionsRefs {
    final manager = $$PromotionsTableTableManager($_db, $_db.promotions).filter(
      (f) => f.createdBy.userId.sqlEquals($_itemColumn<String>('user_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_promotionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ArReceiptsTable, List<ArReceipt>>
  _arReceiptsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.arReceipts,
    aliasName: $_aliasNameGenerator(db.users.userId, db.arReceipts.userId),
  );

  $$ArReceiptsTableProcessedTableManager get arReceiptsRefs {
    final manager = $$ArReceiptsTableTableManager($_db, $_db.arReceipts).filter(
      (f) => f.userId.userId.sqlEquals($_itemColumn<String>('user_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_arReceiptsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ApPaymentsTable, List<ApPayment>>
  _apPaymentsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.apPayments,
    aliasName: $_aliasNameGenerator(db.users.userId, db.apPayments.userId),
  );

  $$ApPaymentsTableProcessedTableManager get apPaymentsRefs {
    final manager = $$ApPaymentsTableTableManager($_db, $_db.apPayments).filter(
      (f) => f.userId.userId.sqlEquals($_itemColumn<String>('user_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_apPaymentsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ActiveSessionsTable, List<ActiveSession>>
  _activeSessionsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.activeSessions,
    aliasName: $_aliasNameGenerator(db.users.userId, db.activeSessions.userId),
  );

  $$ActiveSessionsTableProcessedTableManager get activeSessionsRefs {
    final manager = $$ActiveSessionsTableTableManager($_db, $_db.activeSessions)
        .filter(
          (f) => f.userId.userId.sqlEquals($_itemColumn<String>('user_id')!),
        );

    final cache = $_typedResult.readTableOrNull(_activeSessionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$UsersTableFilterComposer extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get username => $composableBuilder(
    column: $table.username,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get passwordHash => $composableBuilder(
    column: $table.passwordHash,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fullName => $composableBuilder(
    column: $table.fullName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastLogin => $composableBuilder(
    column: $table.lastLogin,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$RolesTableFilterComposer get roleId {
    final $$RolesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.roleId,
      referencedTable: $db.roles,
      getReferencedColumn: (t) => t.roleId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RolesTableFilterComposer(
            $db: $db,
            $table: $db.roles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableFilterComposer get branchId {
    final $$BranchesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableFilterComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> salesOrdersRefs(
    Expression<bool> Function($$SalesOrdersTableFilterComposer f) f,
  ) {
    final $$SalesOrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableFilterComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> purchaseOrdersRefs(
    Expression<bool> Function($$PurchaseOrdersTableFilterComposer f) f,
  ) {
    final $$PurchaseOrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.purchaseOrders,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrdersTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> stockMovementsRefs(
    Expression<bool> Function($$StockMovementsTableFilterComposer f) f,
  ) {
    final $$StockMovementsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.stockMovements,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockMovementsTableFilterComposer(
            $db: $db,
            $table: $db.stockMovements,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> promotionsRefs(
    Expression<bool> Function($$PromotionsTableFilterComposer f) f,
  ) {
    final $$PromotionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.promotions,
      getReferencedColumn: (t) => t.createdBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionsTableFilterComposer(
            $db: $db,
            $table: $db.promotions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> arReceiptsRefs(
    Expression<bool> Function($$ArReceiptsTableFilterComposer f) f,
  ) {
    final $$ArReceiptsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.arReceipts,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArReceiptsTableFilterComposer(
            $db: $db,
            $table: $db.arReceipts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> apPaymentsRefs(
    Expression<bool> Function($$ApPaymentsTableFilterComposer f) f,
  ) {
    final $$ApPaymentsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.apPayments,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApPaymentsTableFilterComposer(
            $db: $db,
            $table: $db.apPayments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> activeSessionsRefs(
    Expression<bool> Function($$ActiveSessionsTableFilterComposer f) f,
  ) {
    final $$ActiveSessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.activeSessions,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActiveSessionsTableFilterComposer(
            $db: $db,
            $table: $db.activeSessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UsersTableOrderingComposer
    extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get username => $composableBuilder(
    column: $table.username,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get passwordHash => $composableBuilder(
    column: $table.passwordHash,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fullName => $composableBuilder(
    column: $table.fullName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastLogin => $composableBuilder(
    column: $table.lastLogin,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$RolesTableOrderingComposer get roleId {
    final $$RolesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.roleId,
      referencedTable: $db.roles,
      getReferencedColumn: (t) => t.roleId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RolesTableOrderingComposer(
            $db: $db,
            $table: $db.roles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableOrderingComposer get branchId {
    final $$BranchesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableOrderingComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UsersTableAnnotationComposer
    extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get username =>
      $composableBuilder(column: $table.username, builder: (column) => column);

  GeneratedColumn<String> get passwordHash => $composableBuilder(
    column: $table.passwordHash,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fullName =>
      $composableBuilder(column: $table.fullName, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get lastLogin =>
      $composableBuilder(column: $table.lastLogin, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$RolesTableAnnotationComposer get roleId {
    final $$RolesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.roleId,
      referencedTable: $db.roles,
      getReferencedColumn: (t) => t.roleId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RolesTableAnnotationComposer(
            $db: $db,
            $table: $db.roles,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableAnnotationComposer get branchId {
    final $$BranchesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableAnnotationComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> salesOrdersRefs<T extends Object>(
    Expression<T> Function($$SalesOrdersTableAnnotationComposer a) f,
  ) {
    final $$SalesOrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> purchaseOrdersRefs<T extends Object>(
    Expression<T> Function($$PurchaseOrdersTableAnnotationComposer a) f,
  ) {
    final $$PurchaseOrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.purchaseOrders,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.purchaseOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> stockMovementsRefs<T extends Object>(
    Expression<T> Function($$StockMovementsTableAnnotationComposer a) f,
  ) {
    final $$StockMovementsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.stockMovements,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockMovementsTableAnnotationComposer(
            $db: $db,
            $table: $db.stockMovements,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> promotionsRefs<T extends Object>(
    Expression<T> Function($$PromotionsTableAnnotationComposer a) f,
  ) {
    final $$PromotionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.promotions,
      getReferencedColumn: (t) => t.createdBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionsTableAnnotationComposer(
            $db: $db,
            $table: $db.promotions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> arReceiptsRefs<T extends Object>(
    Expression<T> Function($$ArReceiptsTableAnnotationComposer a) f,
  ) {
    final $$ArReceiptsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.arReceipts,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArReceiptsTableAnnotationComposer(
            $db: $db,
            $table: $db.arReceipts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> apPaymentsRefs<T extends Object>(
    Expression<T> Function($$ApPaymentsTableAnnotationComposer a) f,
  ) {
    final $$ApPaymentsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.apPayments,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApPaymentsTableAnnotationComposer(
            $db: $db,
            $table: $db.apPayments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> activeSessionsRefs<T extends Object>(
    Expression<T> Function($$ActiveSessionsTableAnnotationComposer a) f,
  ) {
    final $$ActiveSessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.activeSessions,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActiveSessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.activeSessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UsersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UsersTable,
          User,
          $$UsersTableFilterComposer,
          $$UsersTableOrderingComposer,
          $$UsersTableAnnotationComposer,
          $$UsersTableCreateCompanionBuilder,
          $$UsersTableUpdateCompanionBuilder,
          (User, $$UsersTableReferences),
          User,
          PrefetchHooks Function({
            bool roleId,
            bool branchId,
            bool salesOrdersRefs,
            bool purchaseOrdersRefs,
            bool stockMovementsRefs,
            bool promotionsRefs,
            bool arReceiptsRefs,
            bool apPaymentsRefs,
            bool activeSessionsRefs,
          })
        > {
  $$UsersTableTableManager(_$AppDatabase db, $UsersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UsersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UsersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UsersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> userId = const Value.absent(),
                Value<String> username = const Value.absent(),
                Value<String> passwordHash = const Value.absent(),
                Value<String> fullName = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> roleId = const Value.absent(),
                Value<String?> branchId = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime?> lastLogin = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UsersCompanion(
                userId: userId,
                username: username,
                passwordHash: passwordHash,
                fullName: fullName,
                email: email,
                phone: phone,
                roleId: roleId,
                branchId: branchId,
                isActive: isActive,
                lastLogin: lastLogin,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String userId,
                required String username,
                required String passwordHash,
                required String fullName,
                Value<String?> email = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> roleId = const Value.absent(),
                Value<String?> branchId = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime?> lastLogin = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UsersCompanion.insert(
                userId: userId,
                username: username,
                passwordHash: passwordHash,
                fullName: fullName,
                email: email,
                phone: phone,
                roleId: roleId,
                branchId: branchId,
                isActive: isActive,
                lastLogin: lastLogin,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$UsersTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                roleId = false,
                branchId = false,
                salesOrdersRefs = false,
                purchaseOrdersRefs = false,
                stockMovementsRefs = false,
                promotionsRefs = false,
                arReceiptsRefs = false,
                apPaymentsRefs = false,
                activeSessionsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (salesOrdersRefs) db.salesOrders,
                    if (purchaseOrdersRefs) db.purchaseOrders,
                    if (stockMovementsRefs) db.stockMovements,
                    if (promotionsRefs) db.promotions,
                    if (arReceiptsRefs) db.arReceipts,
                    if (apPaymentsRefs) db.apPayments,
                    if (activeSessionsRefs) db.activeSessions,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (roleId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.roleId,
                                    referencedTable: $$UsersTableReferences
                                        ._roleIdTable(db),
                                    referencedColumn: $$UsersTableReferences
                                        ._roleIdTable(db)
                                        .roleId,
                                  )
                                  as T;
                        }
                        if (branchId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.branchId,
                                    referencedTable: $$UsersTableReferences
                                        ._branchIdTable(db),
                                    referencedColumn: $$UsersTableReferences
                                        ._branchIdTable(db)
                                        .branchId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (salesOrdersRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          SalesOrder
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._salesOrdersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).salesOrdersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.userId,
                              ),
                          typedResults: items,
                        ),
                      if (purchaseOrdersRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          PurchaseOrder
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._purchaseOrdersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).purchaseOrdersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.userId,
                              ),
                          typedResults: items,
                        ),
                      if (stockMovementsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          StockMovement
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._stockMovementsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).stockMovementsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.userId,
                              ),
                          typedResults: items,
                        ),
                      if (promotionsRefs)
                        await $_getPrefetchedData<User, $UsersTable, Promotion>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._promotionsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).promotionsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.createdBy == item.userId,
                              ),
                          typedResults: items,
                        ),
                      if (arReceiptsRefs)
                        await $_getPrefetchedData<User, $UsersTable, ArReceipt>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._arReceiptsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).arReceiptsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.userId,
                              ),
                          typedResults: items,
                        ),
                      if (apPaymentsRefs)
                        await $_getPrefetchedData<User, $UsersTable, ApPayment>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._apPaymentsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).apPaymentsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.userId,
                              ),
                          typedResults: items,
                        ),
                      if (activeSessionsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          ActiveSession
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._activeSessionsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).activeSessionsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.userId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$UsersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UsersTable,
      User,
      $$UsersTableFilterComposer,
      $$UsersTableOrderingComposer,
      $$UsersTableAnnotationComposer,
      $$UsersTableCreateCompanionBuilder,
      $$UsersTableUpdateCompanionBuilder,
      (User, $$UsersTableReferences),
      User,
      PrefetchHooks Function({
        bool roleId,
        bool branchId,
        bool salesOrdersRefs,
        bool purchaseOrdersRefs,
        bool stockMovementsRefs,
        bool promotionsRefs,
        bool arReceiptsRefs,
        bool apPaymentsRefs,
        bool activeSessionsRefs,
      })
    >;
typedef $$ProductGroupsTableCreateCompanionBuilder =
    ProductGroupsCompanion Function({
      required String groupId,
      required String groupCode,
      required String groupName,
      Value<String?> parentGroupId,
      Value<String> groupType,
      Value<String?> imageUrl,
      Value<int> displayOrder,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$ProductGroupsTableUpdateCompanionBuilder =
    ProductGroupsCompanion Function({
      Value<String> groupId,
      Value<String> groupCode,
      Value<String> groupName,
      Value<String?> parentGroupId,
      Value<String> groupType,
      Value<String?> imageUrl,
      Value<int> displayOrder,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ProductGroupsTableReferences
    extends BaseReferences<_$AppDatabase, $ProductGroupsTable, ProductGroup> {
  $$ProductGroupsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$ProductsTable, List<Product>> _productsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.products,
    aliasName: $_aliasNameGenerator(
      db.productGroups.groupId,
      db.products.groupId,
    ),
  );

  $$ProductsTableProcessedTableManager get productsRefs {
    final manager = $$ProductsTableTableManager($_db, $_db.products).filter(
      (f) => f.groupId.groupId.sqlEquals($_itemColumn<String>('group_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_productsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ProductGroupsTableFilterComposer
    extends Composer<_$AppDatabase, $ProductGroupsTable> {
  $$ProductGroupsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get groupId => $composableBuilder(
    column: $table.groupId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get groupCode => $composableBuilder(
    column: $table.groupCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get groupName => $composableBuilder(
    column: $table.groupName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentGroupId => $composableBuilder(
    column: $table.parentGroupId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get groupType => $composableBuilder(
    column: $table.groupType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> productsRefs(
    Expression<bool> Function($$ProductsTableFilterComposer f) f,
  ) {
    final $$ProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.groupId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.groupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableFilterComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductGroupsTableOrderingComposer
    extends Composer<_$AppDatabase, $ProductGroupsTable> {
  $$ProductGroupsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get groupId => $composableBuilder(
    column: $table.groupId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get groupCode => $composableBuilder(
    column: $table.groupCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get groupName => $composableBuilder(
    column: $table.groupName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentGroupId => $composableBuilder(
    column: $table.parentGroupId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get groupType => $composableBuilder(
    column: $table.groupType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ProductGroupsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProductGroupsTable> {
  $$ProductGroupsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get groupId =>
      $composableBuilder(column: $table.groupId, builder: (column) => column);

  GeneratedColumn<String> get groupCode =>
      $composableBuilder(column: $table.groupCode, builder: (column) => column);

  GeneratedColumn<String> get groupName =>
      $composableBuilder(column: $table.groupName, builder: (column) => column);

  GeneratedColumn<String> get parentGroupId => $composableBuilder(
    column: $table.parentGroupId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get groupType =>
      $composableBuilder(column: $table.groupType, builder: (column) => column);

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  Expression<T> productsRefs<T extends Object>(
    Expression<T> Function($$ProductsTableAnnotationComposer a) f,
  ) {
    final $$ProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.groupId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.groupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductGroupsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ProductGroupsTable,
          ProductGroup,
          $$ProductGroupsTableFilterComposer,
          $$ProductGroupsTableOrderingComposer,
          $$ProductGroupsTableAnnotationComposer,
          $$ProductGroupsTableCreateCompanionBuilder,
          $$ProductGroupsTableUpdateCompanionBuilder,
          (ProductGroup, $$ProductGroupsTableReferences),
          ProductGroup,
          PrefetchHooks Function({bool productsRefs})
        > {
  $$ProductGroupsTableTableManager(_$AppDatabase db, $ProductGroupsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProductGroupsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProductGroupsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProductGroupsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> groupId = const Value.absent(),
                Value<String> groupCode = const Value.absent(),
                Value<String> groupName = const Value.absent(),
                Value<String?> parentGroupId = const Value.absent(),
                Value<String> groupType = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<int> displayOrder = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProductGroupsCompanion(
                groupId: groupId,
                groupCode: groupCode,
                groupName: groupName,
                parentGroupId: parentGroupId,
                groupType: groupType,
                imageUrl: imageUrl,
                displayOrder: displayOrder,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String groupId,
                required String groupCode,
                required String groupName,
                Value<String?> parentGroupId = const Value.absent(),
                Value<String> groupType = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<int> displayOrder = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProductGroupsCompanion.insert(
                groupId: groupId,
                groupCode: groupCode,
                groupName: groupName,
                parentGroupId: parentGroupId,
                groupType: groupType,
                imageUrl: imageUrl,
                displayOrder: displayOrder,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ProductGroupsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({productsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (productsRefs) db.products],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (productsRefs)
                    await $_getPrefetchedData<
                      ProductGroup,
                      $ProductGroupsTable,
                      Product
                    >(
                      currentTable: table,
                      referencedTable: $$ProductGroupsTableReferences
                          ._productsRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$ProductGroupsTableReferences(
                            db,
                            table,
                            p0,
                          ).productsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.groupId == item.groupId,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$ProductGroupsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ProductGroupsTable,
      ProductGroup,
      $$ProductGroupsTableFilterComposer,
      $$ProductGroupsTableOrderingComposer,
      $$ProductGroupsTableAnnotationComposer,
      $$ProductGroupsTableCreateCompanionBuilder,
      $$ProductGroupsTableUpdateCompanionBuilder,
      (ProductGroup, $$ProductGroupsTableReferences),
      ProductGroup,
      PrefetchHooks Function({bool productsRefs})
    >;
typedef $$ProductsTableCreateCompanionBuilder =
    ProductsCompanion Function({
      required String productId,
      required String productCode,
      Value<String?> barcode,
      required String productName,
      Value<String?> productNameEn,
      Value<String?> groupId,
      Value<String?> brand,
      Value<String?> model,
      Value<String?> color,
      required String baseUnit,
      Value<Map<String, dynamic>?> unitConversion,
      Value<double> priceLevel1,
      Value<double> priceLevel2,
      Value<double> priceLevel3,
      Value<double> priceLevel4,
      Value<double> priceLevel5,
      Value<String> costMethod,
      Value<double> standardCost,
      Value<bool> isStockControl,
      Value<bool> isSerialControl,
      Value<bool> allowNegativeStock,
      Value<double> reorderPoint,
      Value<String> vatType,
      Value<double> vatRate,
      Value<Map<String, dynamic>?> imageUrls,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$ProductsTableUpdateCompanionBuilder =
    ProductsCompanion Function({
      Value<String> productId,
      Value<String> productCode,
      Value<String?> barcode,
      Value<String> productName,
      Value<String?> productNameEn,
      Value<String?> groupId,
      Value<String?> brand,
      Value<String?> model,
      Value<String?> color,
      Value<String> baseUnit,
      Value<Map<String, dynamic>?> unitConversion,
      Value<double> priceLevel1,
      Value<double> priceLevel2,
      Value<double> priceLevel3,
      Value<double> priceLevel4,
      Value<double> priceLevel5,
      Value<String> costMethod,
      Value<double> standardCost,
      Value<bool> isStockControl,
      Value<bool> isSerialControl,
      Value<bool> allowNegativeStock,
      Value<double> reorderPoint,
      Value<String> vatType,
      Value<double> vatRate,
      Value<Map<String, dynamic>?> imageUrls,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$ProductsTableReferences
    extends BaseReferences<_$AppDatabase, $ProductsTable, Product> {
  $$ProductsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ProductGroupsTable _groupIdTable(_$AppDatabase db) =>
      db.productGroups.createAlias(
        $_aliasNameGenerator(db.products.groupId, db.productGroups.groupId),
      );

  $$ProductGroupsTableProcessedTableManager? get groupId {
    final $_column = $_itemColumn<String>('group_id');
    if ($_column == null) return null;
    final manager = $$ProductGroupsTableTableManager(
      $_db,
      $_db.productGroups,
    ).filter((f) => f.groupId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_groupIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$StockBalancesTable, List<StockBalance>>
  _stockBalancesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.stockBalances,
    aliasName: $_aliasNameGenerator(
      db.products.productId,
      db.stockBalances.productId,
    ),
  );

  $$StockBalancesTableProcessedTableManager get stockBalancesRefs {
    final manager = $$StockBalancesTableTableManager($_db, $_db.stockBalances)
        .filter(
          (f) => f.productId.productId.sqlEquals(
            $_itemColumn<String>('product_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(_stockBalancesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SerialNumbersTable, List<SerialNumber>>
  _serialNumbersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.serialNumbers,
    aliasName: $_aliasNameGenerator(
      db.products.productId,
      db.serialNumbers.productId,
    ),
  );

  $$SerialNumbersTableProcessedTableManager get serialNumbersRefs {
    final manager = $$SerialNumbersTableTableManager($_db, $_db.serialNumbers)
        .filter(
          (f) => f.productId.productId.sqlEquals(
            $_itemColumn<String>('product_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(_serialNumbersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ProductModifiersTable, List<ProductModifier>>
  _productModifiersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.productModifiers,
    aliasName: $_aliasNameGenerator(
      db.products.productId,
      db.productModifiers.productId,
    ),
  );

  $$ProductModifiersTableProcessedTableManager get productModifiersRefs {
    final manager =
        $$ProductModifiersTableTableManager($_db, $_db.productModifiers).filter(
          (f) => f.productId.productId.sqlEquals(
            $_itemColumn<String>('product_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _productModifiersRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SalesOrderItemsTable, List<SalesOrderItem>>
  _salesOrderItemsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.salesOrderItems,
    aliasName: $_aliasNameGenerator(
      db.products.productId,
      db.salesOrderItems.productId,
    ),
  );

  $$SalesOrderItemsTableProcessedTableManager get salesOrderItemsRefs {
    final manager =
        $$SalesOrderItemsTableTableManager($_db, $_db.salesOrderItems).filter(
          (f) => f.productId.productId.sqlEquals(
            $_itemColumn<String>('product_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _salesOrderItemsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PurchaseOrderItemsTable, List<PurchaseOrderItem>>
  _purchaseOrderItemsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.purchaseOrderItems,
        aliasName: $_aliasNameGenerator(
          db.products.productId,
          db.purchaseOrderItems.productId,
        ),
      );

  $$PurchaseOrderItemsTableProcessedTableManager get purchaseOrderItemsRefs {
    final manager =
        $$PurchaseOrderItemsTableTableManager(
          $_db,
          $_db.purchaseOrderItems,
        ).filter(
          (f) => f.productId.productId.sqlEquals(
            $_itemColumn<String>('product_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _purchaseOrderItemsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$StockMovementsTable, List<StockMovement>>
  _stockMovementsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.stockMovements,
    aliasName: $_aliasNameGenerator(
      db.products.productId,
      db.stockMovements.productId,
    ),
  );

  $$StockMovementsTableProcessedTableManager get stockMovementsRefs {
    final manager = $$StockMovementsTableTableManager($_db, $_db.stockMovements)
        .filter(
          (f) => f.productId.productId.sqlEquals(
            $_itemColumn<String>('product_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(_stockMovementsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ProductsTableFilterComposer
    extends Composer<_$AppDatabase, $ProductsTable> {
  $$ProductsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get productId => $composableBuilder(
    column: $table.productId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get productCode => $composableBuilder(
    column: $table.productCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get barcode => $composableBuilder(
    column: $table.barcode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get productNameEn => $composableBuilder(
    column: $table.productNameEn,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get model => $composableBuilder(
    column: $table.model,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get baseUnit => $composableBuilder(
    column: $table.baseUnit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get unitConversion => $composableBuilder(
    column: $table.unitConversion,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<double> get priceLevel1 => $composableBuilder(
    column: $table.priceLevel1,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get priceLevel2 => $composableBuilder(
    column: $table.priceLevel2,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get priceLevel3 => $composableBuilder(
    column: $table.priceLevel3,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get priceLevel4 => $composableBuilder(
    column: $table.priceLevel4,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get priceLevel5 => $composableBuilder(
    column: $table.priceLevel5,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get costMethod => $composableBuilder(
    column: $table.costMethod,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get standardCost => $composableBuilder(
    column: $table.standardCost,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isStockControl => $composableBuilder(
    column: $table.isStockControl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isSerialControl => $composableBuilder(
    column: $table.isSerialControl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get allowNegativeStock => $composableBuilder(
    column: $table.allowNegativeStock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get reorderPoint => $composableBuilder(
    column: $table.reorderPoint,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get vatType => $composableBuilder(
    column: $table.vatType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get vatRate => $composableBuilder(
    column: $table.vatRate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get imageUrls => $composableBuilder(
    column: $table.imageUrls,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ProductGroupsTableFilterComposer get groupId {
    final $$ProductGroupsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.groupId,
      referencedTable: $db.productGroups,
      getReferencedColumn: (t) => t.groupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductGroupsTableFilterComposer(
            $db: $db,
            $table: $db.productGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> stockBalancesRefs(
    Expression<bool> Function($$StockBalancesTableFilterComposer f) f,
  ) {
    final $$StockBalancesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.stockBalances,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockBalancesTableFilterComposer(
            $db: $db,
            $table: $db.stockBalances,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> serialNumbersRefs(
    Expression<bool> Function($$SerialNumbersTableFilterComposer f) f,
  ) {
    final $$SerialNumbersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.serialNumbers,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SerialNumbersTableFilterComposer(
            $db: $db,
            $table: $db.serialNumbers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> productModifiersRefs(
    Expression<bool> Function($$ProductModifiersTableFilterComposer f) f,
  ) {
    final $$ProductModifiersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.productModifiers,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductModifiersTableFilterComposer(
            $db: $db,
            $table: $db.productModifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> salesOrderItemsRefs(
    Expression<bool> Function($$SalesOrderItemsTableFilterComposer f) f,
  ) {
    final $$SalesOrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.salesOrderItems,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.salesOrderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> purchaseOrderItemsRefs(
    Expression<bool> Function($$PurchaseOrderItemsTableFilterComposer f) f,
  ) {
    final $$PurchaseOrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.purchaseOrderItems,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> stockMovementsRefs(
    Expression<bool> Function($$StockMovementsTableFilterComposer f) f,
  ) {
    final $$StockMovementsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.stockMovements,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockMovementsTableFilterComposer(
            $db: $db,
            $table: $db.stockMovements,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductsTableOrderingComposer
    extends Composer<_$AppDatabase, $ProductsTable> {
  $$ProductsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get productId => $composableBuilder(
    column: $table.productId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get productCode => $composableBuilder(
    column: $table.productCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get barcode => $composableBuilder(
    column: $table.barcode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get productNameEn => $composableBuilder(
    column: $table.productNameEn,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get brand => $composableBuilder(
    column: $table.brand,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get model => $composableBuilder(
    column: $table.model,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get baseUnit => $composableBuilder(
    column: $table.baseUnit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get unitConversion => $composableBuilder(
    column: $table.unitConversion,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get priceLevel1 => $composableBuilder(
    column: $table.priceLevel1,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get priceLevel2 => $composableBuilder(
    column: $table.priceLevel2,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get priceLevel3 => $composableBuilder(
    column: $table.priceLevel3,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get priceLevel4 => $composableBuilder(
    column: $table.priceLevel4,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get priceLevel5 => $composableBuilder(
    column: $table.priceLevel5,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get costMethod => $composableBuilder(
    column: $table.costMethod,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get standardCost => $composableBuilder(
    column: $table.standardCost,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isStockControl => $composableBuilder(
    column: $table.isStockControl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isSerialControl => $composableBuilder(
    column: $table.isSerialControl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get allowNegativeStock => $composableBuilder(
    column: $table.allowNegativeStock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get reorderPoint => $composableBuilder(
    column: $table.reorderPoint,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get vatType => $composableBuilder(
    column: $table.vatType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get vatRate => $composableBuilder(
    column: $table.vatRate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageUrls => $composableBuilder(
    column: $table.imageUrls,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ProductGroupsTableOrderingComposer get groupId {
    final $$ProductGroupsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.groupId,
      referencedTable: $db.productGroups,
      getReferencedColumn: (t) => t.groupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductGroupsTableOrderingComposer(
            $db: $db,
            $table: $db.productGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ProductsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProductsTable> {
  $$ProductsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get productId =>
      $composableBuilder(column: $table.productId, builder: (column) => column);

  GeneratedColumn<String> get productCode => $composableBuilder(
    column: $table.productCode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get barcode =>
      $composableBuilder(column: $table.barcode, builder: (column) => column);

  GeneratedColumn<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get productNameEn => $composableBuilder(
    column: $table.productNameEn,
    builder: (column) => column,
  );

  GeneratedColumn<String> get brand =>
      $composableBuilder(column: $table.brand, builder: (column) => column);

  GeneratedColumn<String> get model =>
      $composableBuilder(column: $table.model, builder: (column) => column);

  GeneratedColumn<String> get color =>
      $composableBuilder(column: $table.color, builder: (column) => column);

  GeneratedColumn<String> get baseUnit =>
      $composableBuilder(column: $table.baseUnit, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get unitConversion => $composableBuilder(
    column: $table.unitConversion,
    builder: (column) => column,
  );

  GeneratedColumn<double> get priceLevel1 => $composableBuilder(
    column: $table.priceLevel1,
    builder: (column) => column,
  );

  GeneratedColumn<double> get priceLevel2 => $composableBuilder(
    column: $table.priceLevel2,
    builder: (column) => column,
  );

  GeneratedColumn<double> get priceLevel3 => $composableBuilder(
    column: $table.priceLevel3,
    builder: (column) => column,
  );

  GeneratedColumn<double> get priceLevel4 => $composableBuilder(
    column: $table.priceLevel4,
    builder: (column) => column,
  );

  GeneratedColumn<double> get priceLevel5 => $composableBuilder(
    column: $table.priceLevel5,
    builder: (column) => column,
  );

  GeneratedColumn<String> get costMethod => $composableBuilder(
    column: $table.costMethod,
    builder: (column) => column,
  );

  GeneratedColumn<double> get standardCost => $composableBuilder(
    column: $table.standardCost,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isStockControl => $composableBuilder(
    column: $table.isStockControl,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isSerialControl => $composableBuilder(
    column: $table.isSerialControl,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get allowNegativeStock => $composableBuilder(
    column: $table.allowNegativeStock,
    builder: (column) => column,
  );

  GeneratedColumn<double> get reorderPoint => $composableBuilder(
    column: $table.reorderPoint,
    builder: (column) => column,
  );

  GeneratedColumn<String> get vatType =>
      $composableBuilder(column: $table.vatType, builder: (column) => column);

  GeneratedColumn<double> get vatRate =>
      $composableBuilder(column: $table.vatRate, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get imageUrls =>
      $composableBuilder(column: $table.imageUrls, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$ProductGroupsTableAnnotationComposer get groupId {
    final $$ProductGroupsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.groupId,
      referencedTable: $db.productGroups,
      getReferencedColumn: (t) => t.groupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductGroupsTableAnnotationComposer(
            $db: $db,
            $table: $db.productGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> stockBalancesRefs<T extends Object>(
    Expression<T> Function($$StockBalancesTableAnnotationComposer a) f,
  ) {
    final $$StockBalancesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.stockBalances,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockBalancesTableAnnotationComposer(
            $db: $db,
            $table: $db.stockBalances,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> serialNumbersRefs<T extends Object>(
    Expression<T> Function($$SerialNumbersTableAnnotationComposer a) f,
  ) {
    final $$SerialNumbersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.serialNumbers,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SerialNumbersTableAnnotationComposer(
            $db: $db,
            $table: $db.serialNumbers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> productModifiersRefs<T extends Object>(
    Expression<T> Function($$ProductModifiersTableAnnotationComposer a) f,
  ) {
    final $$ProductModifiersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.productModifiers,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductModifiersTableAnnotationComposer(
            $db: $db,
            $table: $db.productModifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> salesOrderItemsRefs<T extends Object>(
    Expression<T> Function($$SalesOrderItemsTableAnnotationComposer a) f,
  ) {
    final $$SalesOrderItemsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.salesOrderItems,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrderItemsTableAnnotationComposer(
            $db: $db,
            $table: $db.salesOrderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> purchaseOrderItemsRefs<T extends Object>(
    Expression<T> Function($$PurchaseOrderItemsTableAnnotationComposer a) f,
  ) {
    final $$PurchaseOrderItemsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.productId,
          referencedTable: $db.purchaseOrderItems,
          getReferencedColumn: (t) => t.productId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$PurchaseOrderItemsTableAnnotationComposer(
                $db: $db,
                $table: $db.purchaseOrderItems,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> stockMovementsRefs<T extends Object>(
    Expression<T> Function($$StockMovementsTableAnnotationComposer a) f,
  ) {
    final $$StockMovementsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.stockMovements,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockMovementsTableAnnotationComposer(
            $db: $db,
            $table: $db.stockMovements,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ProductsTable,
          Product,
          $$ProductsTableFilterComposer,
          $$ProductsTableOrderingComposer,
          $$ProductsTableAnnotationComposer,
          $$ProductsTableCreateCompanionBuilder,
          $$ProductsTableUpdateCompanionBuilder,
          (Product, $$ProductsTableReferences),
          Product,
          PrefetchHooks Function({
            bool groupId,
            bool stockBalancesRefs,
            bool serialNumbersRefs,
            bool productModifiersRefs,
            bool salesOrderItemsRefs,
            bool purchaseOrderItemsRefs,
            bool stockMovementsRefs,
          })
        > {
  $$ProductsTableTableManager(_$AppDatabase db, $ProductsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProductsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProductsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProductsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> productId = const Value.absent(),
                Value<String> productCode = const Value.absent(),
                Value<String?> barcode = const Value.absent(),
                Value<String> productName = const Value.absent(),
                Value<String?> productNameEn = const Value.absent(),
                Value<String?> groupId = const Value.absent(),
                Value<String?> brand = const Value.absent(),
                Value<String?> model = const Value.absent(),
                Value<String?> color = const Value.absent(),
                Value<String> baseUnit = const Value.absent(),
                Value<Map<String, dynamic>?> unitConversion =
                    const Value.absent(),
                Value<double> priceLevel1 = const Value.absent(),
                Value<double> priceLevel2 = const Value.absent(),
                Value<double> priceLevel3 = const Value.absent(),
                Value<double> priceLevel4 = const Value.absent(),
                Value<double> priceLevel5 = const Value.absent(),
                Value<String> costMethod = const Value.absent(),
                Value<double> standardCost = const Value.absent(),
                Value<bool> isStockControl = const Value.absent(),
                Value<bool> isSerialControl = const Value.absent(),
                Value<bool> allowNegativeStock = const Value.absent(),
                Value<double> reorderPoint = const Value.absent(),
                Value<String> vatType = const Value.absent(),
                Value<double> vatRate = const Value.absent(),
                Value<Map<String, dynamic>?> imageUrls = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProductsCompanion(
                productId: productId,
                productCode: productCode,
                barcode: barcode,
                productName: productName,
                productNameEn: productNameEn,
                groupId: groupId,
                brand: brand,
                model: model,
                color: color,
                baseUnit: baseUnit,
                unitConversion: unitConversion,
                priceLevel1: priceLevel1,
                priceLevel2: priceLevel2,
                priceLevel3: priceLevel3,
                priceLevel4: priceLevel4,
                priceLevel5: priceLevel5,
                costMethod: costMethod,
                standardCost: standardCost,
                isStockControl: isStockControl,
                isSerialControl: isSerialControl,
                allowNegativeStock: allowNegativeStock,
                reorderPoint: reorderPoint,
                vatType: vatType,
                vatRate: vatRate,
                imageUrls: imageUrls,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String productId,
                required String productCode,
                Value<String?> barcode = const Value.absent(),
                required String productName,
                Value<String?> productNameEn = const Value.absent(),
                Value<String?> groupId = const Value.absent(),
                Value<String?> brand = const Value.absent(),
                Value<String?> model = const Value.absent(),
                Value<String?> color = const Value.absent(),
                required String baseUnit,
                Value<Map<String, dynamic>?> unitConversion =
                    const Value.absent(),
                Value<double> priceLevel1 = const Value.absent(),
                Value<double> priceLevel2 = const Value.absent(),
                Value<double> priceLevel3 = const Value.absent(),
                Value<double> priceLevel4 = const Value.absent(),
                Value<double> priceLevel5 = const Value.absent(),
                Value<String> costMethod = const Value.absent(),
                Value<double> standardCost = const Value.absent(),
                Value<bool> isStockControl = const Value.absent(),
                Value<bool> isSerialControl = const Value.absent(),
                Value<bool> allowNegativeStock = const Value.absent(),
                Value<double> reorderPoint = const Value.absent(),
                Value<String> vatType = const Value.absent(),
                Value<double> vatRate = const Value.absent(),
                Value<Map<String, dynamic>?> imageUrls = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProductsCompanion.insert(
                productId: productId,
                productCode: productCode,
                barcode: barcode,
                productName: productName,
                productNameEn: productNameEn,
                groupId: groupId,
                brand: brand,
                model: model,
                color: color,
                baseUnit: baseUnit,
                unitConversion: unitConversion,
                priceLevel1: priceLevel1,
                priceLevel2: priceLevel2,
                priceLevel3: priceLevel3,
                priceLevel4: priceLevel4,
                priceLevel5: priceLevel5,
                costMethod: costMethod,
                standardCost: standardCost,
                isStockControl: isStockControl,
                isSerialControl: isSerialControl,
                allowNegativeStock: allowNegativeStock,
                reorderPoint: reorderPoint,
                vatType: vatType,
                vatRate: vatRate,
                imageUrls: imageUrls,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ProductsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                groupId = false,
                stockBalancesRefs = false,
                serialNumbersRefs = false,
                productModifiersRefs = false,
                salesOrderItemsRefs = false,
                purchaseOrderItemsRefs = false,
                stockMovementsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (stockBalancesRefs) db.stockBalances,
                    if (serialNumbersRefs) db.serialNumbers,
                    if (productModifiersRefs) db.productModifiers,
                    if (salesOrderItemsRefs) db.salesOrderItems,
                    if (purchaseOrderItemsRefs) db.purchaseOrderItems,
                    if (stockMovementsRefs) db.stockMovements,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (groupId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.groupId,
                                    referencedTable: $$ProductsTableReferences
                                        ._groupIdTable(db),
                                    referencedColumn: $$ProductsTableReferences
                                        ._groupIdTable(db)
                                        .groupId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (stockBalancesRefs)
                        await $_getPrefetchedData<
                          Product,
                          $ProductsTable,
                          StockBalance
                        >(
                          currentTable: table,
                          referencedTable: $$ProductsTableReferences
                              ._stockBalancesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductsTableReferences(
                                db,
                                table,
                                p0,
                              ).stockBalancesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.productId,
                              ),
                          typedResults: items,
                        ),
                      if (serialNumbersRefs)
                        await $_getPrefetchedData<
                          Product,
                          $ProductsTable,
                          SerialNumber
                        >(
                          currentTable: table,
                          referencedTable: $$ProductsTableReferences
                              ._serialNumbersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductsTableReferences(
                                db,
                                table,
                                p0,
                              ).serialNumbersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.productId,
                              ),
                          typedResults: items,
                        ),
                      if (productModifiersRefs)
                        await $_getPrefetchedData<
                          Product,
                          $ProductsTable,
                          ProductModifier
                        >(
                          currentTable: table,
                          referencedTable: $$ProductsTableReferences
                              ._productModifiersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductsTableReferences(
                                db,
                                table,
                                p0,
                              ).productModifiersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.productId,
                              ),
                          typedResults: items,
                        ),
                      if (salesOrderItemsRefs)
                        await $_getPrefetchedData<
                          Product,
                          $ProductsTable,
                          SalesOrderItem
                        >(
                          currentTable: table,
                          referencedTable: $$ProductsTableReferences
                              ._salesOrderItemsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductsTableReferences(
                                db,
                                table,
                                p0,
                              ).salesOrderItemsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.productId,
                              ),
                          typedResults: items,
                        ),
                      if (purchaseOrderItemsRefs)
                        await $_getPrefetchedData<
                          Product,
                          $ProductsTable,
                          PurchaseOrderItem
                        >(
                          currentTable: table,
                          referencedTable: $$ProductsTableReferences
                              ._purchaseOrderItemsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductsTableReferences(
                                db,
                                table,
                                p0,
                              ).purchaseOrderItemsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.productId,
                              ),
                          typedResults: items,
                        ),
                      if (stockMovementsRefs)
                        await $_getPrefetchedData<
                          Product,
                          $ProductsTable,
                          StockMovement
                        >(
                          currentTable: table,
                          referencedTable: $$ProductsTableReferences
                              ._stockMovementsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductsTableReferences(
                                db,
                                table,
                                p0,
                              ).stockMovementsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.productId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ProductsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ProductsTable,
      Product,
      $$ProductsTableFilterComposer,
      $$ProductsTableOrderingComposer,
      $$ProductsTableAnnotationComposer,
      $$ProductsTableCreateCompanionBuilder,
      $$ProductsTableUpdateCompanionBuilder,
      (Product, $$ProductsTableReferences),
      Product,
      PrefetchHooks Function({
        bool groupId,
        bool stockBalancesRefs,
        bool serialNumbersRefs,
        bool productModifiersRefs,
        bool salesOrderItemsRefs,
        bool purchaseOrderItemsRefs,
        bool stockMovementsRefs,
      })
    >;
typedef $$WarehousesTableCreateCompanionBuilder =
    WarehousesCompanion Function({
      required String warehouseId,
      required String warehouseCode,
      required String warehouseName,
      required String branchId,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$WarehousesTableUpdateCompanionBuilder =
    WarehousesCompanion Function({
      Value<String> warehouseId,
      Value<String> warehouseCode,
      Value<String> warehouseName,
      Value<String> branchId,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$WarehousesTableReferences
    extends BaseReferences<_$AppDatabase, $WarehousesTable, Warehouse> {
  $$WarehousesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BranchesTable _branchIdTable(_$AppDatabase db) =>
      db.branches.createAlias(
        $_aliasNameGenerator(db.warehouses.branchId, db.branches.branchId),
      );

  $$BranchesTableProcessedTableManager get branchId {
    final $_column = $_itemColumn<String>('branch_id')!;

    final manager = $$BranchesTableTableManager(
      $_db,
      $_db.branches,
    ).filter((f) => f.branchId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_branchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$StockBalancesTable, List<StockBalance>>
  _stockBalancesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.stockBalances,
    aliasName: $_aliasNameGenerator(
      db.warehouses.warehouseId,
      db.stockBalances.warehouseId,
    ),
  );

  $$StockBalancesTableProcessedTableManager get stockBalancesRefs {
    final manager = $$StockBalancesTableTableManager($_db, $_db.stockBalances)
        .filter(
          (f) => f.warehouseId.warehouseId.sqlEquals(
            $_itemColumn<String>('warehouse_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(_stockBalancesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SerialNumbersTable, List<SerialNumber>>
  _serialNumbersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.serialNumbers,
    aliasName: $_aliasNameGenerator(
      db.warehouses.warehouseId,
      db.serialNumbers.warehouseId,
    ),
  );

  $$SerialNumbersTableProcessedTableManager get serialNumbersRefs {
    final manager = $$SerialNumbersTableTableManager($_db, $_db.serialNumbers)
        .filter(
          (f) => f.warehouseId.warehouseId.sqlEquals(
            $_itemColumn<String>('warehouse_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(_serialNumbersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SalesOrdersTable, List<SalesOrder>>
  _salesOrdersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.salesOrders,
    aliasName: $_aliasNameGenerator(
      db.warehouses.warehouseId,
      db.salesOrders.warehouseId,
    ),
  );

  $$SalesOrdersTableProcessedTableManager get salesOrdersRefs {
    final manager = $$SalesOrdersTableTableManager($_db, $_db.salesOrders)
        .filter(
          (f) => f.warehouseId.warehouseId.sqlEquals(
            $_itemColumn<String>('warehouse_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(_salesOrdersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SalesOrderItemsTable, List<SalesOrderItem>>
  _salesOrderItemsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.salesOrderItems,
    aliasName: $_aliasNameGenerator(
      db.warehouses.warehouseId,
      db.salesOrderItems.warehouseId,
    ),
  );

  $$SalesOrderItemsTableProcessedTableManager get salesOrderItemsRefs {
    final manager =
        $$SalesOrderItemsTableTableManager($_db, $_db.salesOrderItems).filter(
          (f) => f.warehouseId.warehouseId.sqlEquals(
            $_itemColumn<String>('warehouse_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _salesOrderItemsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PurchaseOrdersTable, List<PurchaseOrder>>
  _purchaseOrdersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.purchaseOrders,
    aliasName: $_aliasNameGenerator(
      db.warehouses.warehouseId,
      db.purchaseOrders.warehouseId,
    ),
  );

  $$PurchaseOrdersTableProcessedTableManager get purchaseOrdersRefs {
    final manager = $$PurchaseOrdersTableTableManager($_db, $_db.purchaseOrders)
        .filter(
          (f) => f.warehouseId.warehouseId.sqlEquals(
            $_itemColumn<String>('warehouse_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(_purchaseOrdersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$StockMovementsTable, List<StockMovement>>
  _stockMovementsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.stockMovements,
    aliasName: $_aliasNameGenerator(
      db.warehouses.warehouseId,
      db.stockMovements.warehouseId,
    ),
  );

  $$StockMovementsTableProcessedTableManager get stockMovementsRefs {
    final manager = $$StockMovementsTableTableManager($_db, $_db.stockMovements)
        .filter(
          (f) => f.warehouseId.warehouseId.sqlEquals(
            $_itemColumn<String>('warehouse_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(_stockMovementsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$WarehousesTableFilterComposer
    extends Composer<_$AppDatabase, $WarehousesTable> {
  $$WarehousesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get warehouseId => $composableBuilder(
    column: $table.warehouseId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get warehouseCode => $composableBuilder(
    column: $table.warehouseCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get warehouseName => $composableBuilder(
    column: $table.warehouseName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BranchesTableFilterComposer get branchId {
    final $$BranchesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableFilterComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> stockBalancesRefs(
    Expression<bool> Function($$StockBalancesTableFilterComposer f) f,
  ) {
    final $$StockBalancesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.stockBalances,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockBalancesTableFilterComposer(
            $db: $db,
            $table: $db.stockBalances,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> serialNumbersRefs(
    Expression<bool> Function($$SerialNumbersTableFilterComposer f) f,
  ) {
    final $$SerialNumbersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.serialNumbers,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SerialNumbersTableFilterComposer(
            $db: $db,
            $table: $db.serialNumbers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> salesOrdersRefs(
    Expression<bool> Function($$SalesOrdersTableFilterComposer f) f,
  ) {
    final $$SalesOrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableFilterComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> salesOrderItemsRefs(
    Expression<bool> Function($$SalesOrderItemsTableFilterComposer f) f,
  ) {
    final $$SalesOrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.salesOrderItems,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.salesOrderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> purchaseOrdersRefs(
    Expression<bool> Function($$PurchaseOrdersTableFilterComposer f) f,
  ) {
    final $$PurchaseOrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.purchaseOrders,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrdersTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> stockMovementsRefs(
    Expression<bool> Function($$StockMovementsTableFilterComposer f) f,
  ) {
    final $$StockMovementsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.stockMovements,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockMovementsTableFilterComposer(
            $db: $db,
            $table: $db.stockMovements,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$WarehousesTableOrderingComposer
    extends Composer<_$AppDatabase, $WarehousesTable> {
  $$WarehousesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get warehouseId => $composableBuilder(
    column: $table.warehouseId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get warehouseCode => $composableBuilder(
    column: $table.warehouseCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get warehouseName => $composableBuilder(
    column: $table.warehouseName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BranchesTableOrderingComposer get branchId {
    final $$BranchesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableOrderingComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$WarehousesTableAnnotationComposer
    extends Composer<_$AppDatabase, $WarehousesTable> {
  $$WarehousesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get warehouseId => $composableBuilder(
    column: $table.warehouseId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get warehouseCode => $composableBuilder(
    column: $table.warehouseCode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get warehouseName => $composableBuilder(
    column: $table.warehouseName,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$BranchesTableAnnotationComposer get branchId {
    final $$BranchesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableAnnotationComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> stockBalancesRefs<T extends Object>(
    Expression<T> Function($$StockBalancesTableAnnotationComposer a) f,
  ) {
    final $$StockBalancesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.stockBalances,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockBalancesTableAnnotationComposer(
            $db: $db,
            $table: $db.stockBalances,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> serialNumbersRefs<T extends Object>(
    Expression<T> Function($$SerialNumbersTableAnnotationComposer a) f,
  ) {
    final $$SerialNumbersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.serialNumbers,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SerialNumbersTableAnnotationComposer(
            $db: $db,
            $table: $db.serialNumbers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> salesOrdersRefs<T extends Object>(
    Expression<T> Function($$SalesOrdersTableAnnotationComposer a) f,
  ) {
    final $$SalesOrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> salesOrderItemsRefs<T extends Object>(
    Expression<T> Function($$SalesOrderItemsTableAnnotationComposer a) f,
  ) {
    final $$SalesOrderItemsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.salesOrderItems,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrderItemsTableAnnotationComposer(
            $db: $db,
            $table: $db.salesOrderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> purchaseOrdersRefs<T extends Object>(
    Expression<T> Function($$PurchaseOrdersTableAnnotationComposer a) f,
  ) {
    final $$PurchaseOrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.purchaseOrders,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.purchaseOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> stockMovementsRefs<T extends Object>(
    Expression<T> Function($$StockMovementsTableAnnotationComposer a) f,
  ) {
    final $$StockMovementsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.stockMovements,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$StockMovementsTableAnnotationComposer(
            $db: $db,
            $table: $db.stockMovements,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$WarehousesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $WarehousesTable,
          Warehouse,
          $$WarehousesTableFilterComposer,
          $$WarehousesTableOrderingComposer,
          $$WarehousesTableAnnotationComposer,
          $$WarehousesTableCreateCompanionBuilder,
          $$WarehousesTableUpdateCompanionBuilder,
          (Warehouse, $$WarehousesTableReferences),
          Warehouse,
          PrefetchHooks Function({
            bool branchId,
            bool stockBalancesRefs,
            bool serialNumbersRefs,
            bool salesOrdersRefs,
            bool salesOrderItemsRefs,
            bool purchaseOrdersRefs,
            bool stockMovementsRefs,
          })
        > {
  $$WarehousesTableTableManager(_$AppDatabase db, $WarehousesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WarehousesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WarehousesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$WarehousesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> warehouseId = const Value.absent(),
                Value<String> warehouseCode = const Value.absent(),
                Value<String> warehouseName = const Value.absent(),
                Value<String> branchId = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => WarehousesCompanion(
                warehouseId: warehouseId,
                warehouseCode: warehouseCode,
                warehouseName: warehouseName,
                branchId: branchId,
                isActive: isActive,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String warehouseId,
                required String warehouseCode,
                required String warehouseName,
                required String branchId,
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => WarehousesCompanion.insert(
                warehouseId: warehouseId,
                warehouseCode: warehouseCode,
                warehouseName: warehouseName,
                branchId: branchId,
                isActive: isActive,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$WarehousesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                branchId = false,
                stockBalancesRefs = false,
                serialNumbersRefs = false,
                salesOrdersRefs = false,
                salesOrderItemsRefs = false,
                purchaseOrdersRefs = false,
                stockMovementsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (stockBalancesRefs) db.stockBalances,
                    if (serialNumbersRefs) db.serialNumbers,
                    if (salesOrdersRefs) db.salesOrders,
                    if (salesOrderItemsRefs) db.salesOrderItems,
                    if (purchaseOrdersRefs) db.purchaseOrders,
                    if (stockMovementsRefs) db.stockMovements,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (branchId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.branchId,
                                    referencedTable: $$WarehousesTableReferences
                                        ._branchIdTable(db),
                                    referencedColumn:
                                        $$WarehousesTableReferences
                                            ._branchIdTable(db)
                                            .branchId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (stockBalancesRefs)
                        await $_getPrefetchedData<
                          Warehouse,
                          $WarehousesTable,
                          StockBalance
                        >(
                          currentTable: table,
                          referencedTable: $$WarehousesTableReferences
                              ._stockBalancesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$WarehousesTableReferences(
                                db,
                                table,
                                p0,
                              ).stockBalancesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.warehouseId == item.warehouseId,
                              ),
                          typedResults: items,
                        ),
                      if (serialNumbersRefs)
                        await $_getPrefetchedData<
                          Warehouse,
                          $WarehousesTable,
                          SerialNumber
                        >(
                          currentTable: table,
                          referencedTable: $$WarehousesTableReferences
                              ._serialNumbersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$WarehousesTableReferences(
                                db,
                                table,
                                p0,
                              ).serialNumbersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.warehouseId == item.warehouseId,
                              ),
                          typedResults: items,
                        ),
                      if (salesOrdersRefs)
                        await $_getPrefetchedData<
                          Warehouse,
                          $WarehousesTable,
                          SalesOrder
                        >(
                          currentTable: table,
                          referencedTable: $$WarehousesTableReferences
                              ._salesOrdersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$WarehousesTableReferences(
                                db,
                                table,
                                p0,
                              ).salesOrdersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.warehouseId == item.warehouseId,
                              ),
                          typedResults: items,
                        ),
                      if (salesOrderItemsRefs)
                        await $_getPrefetchedData<
                          Warehouse,
                          $WarehousesTable,
                          SalesOrderItem
                        >(
                          currentTable: table,
                          referencedTable: $$WarehousesTableReferences
                              ._salesOrderItemsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$WarehousesTableReferences(
                                db,
                                table,
                                p0,
                              ).salesOrderItemsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.warehouseId == item.warehouseId,
                              ),
                          typedResults: items,
                        ),
                      if (purchaseOrdersRefs)
                        await $_getPrefetchedData<
                          Warehouse,
                          $WarehousesTable,
                          PurchaseOrder
                        >(
                          currentTable: table,
                          referencedTable: $$WarehousesTableReferences
                              ._purchaseOrdersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$WarehousesTableReferences(
                                db,
                                table,
                                p0,
                              ).purchaseOrdersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.warehouseId == item.warehouseId,
                              ),
                          typedResults: items,
                        ),
                      if (stockMovementsRefs)
                        await $_getPrefetchedData<
                          Warehouse,
                          $WarehousesTable,
                          StockMovement
                        >(
                          currentTable: table,
                          referencedTable: $$WarehousesTableReferences
                              ._stockMovementsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$WarehousesTableReferences(
                                db,
                                table,
                                p0,
                              ).stockMovementsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.warehouseId == item.warehouseId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$WarehousesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $WarehousesTable,
      Warehouse,
      $$WarehousesTableFilterComposer,
      $$WarehousesTableOrderingComposer,
      $$WarehousesTableAnnotationComposer,
      $$WarehousesTableCreateCompanionBuilder,
      $$WarehousesTableUpdateCompanionBuilder,
      (Warehouse, $$WarehousesTableReferences),
      Warehouse,
      PrefetchHooks Function({
        bool branchId,
        bool stockBalancesRefs,
        bool serialNumbersRefs,
        bool salesOrdersRefs,
        bool salesOrderItemsRefs,
        bool purchaseOrdersRefs,
        bool stockMovementsRefs,
      })
    >;
typedef $$StockBalancesTableCreateCompanionBuilder =
    StockBalancesCompanion Function({
      required String stockId,
      required String productId,
      required String warehouseId,
      Value<double> quantity,
      Value<double> reservedQty,
      Value<double> avgCost,
      Value<double> lastCost,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$StockBalancesTableUpdateCompanionBuilder =
    StockBalancesCompanion Function({
      Value<String> stockId,
      Value<String> productId,
      Value<String> warehouseId,
      Value<double> quantity,
      Value<double> reservedQty,
      Value<double> avgCost,
      Value<double> lastCost,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$StockBalancesTableReferences
    extends BaseReferences<_$AppDatabase, $StockBalancesTable, StockBalance> {
  $$StockBalancesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ProductsTable _productIdTable(_$AppDatabase db) =>
      db.products.createAlias(
        $_aliasNameGenerator(db.stockBalances.productId, db.products.productId),
      );

  $$ProductsTableProcessedTableManager get productId {
    final $_column = $_itemColumn<String>('product_id')!;

    final manager = $$ProductsTableTableManager(
      $_db,
      $_db.products,
    ).filter((f) => f.productId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $WarehousesTable _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias(
        $_aliasNameGenerator(
          db.stockBalances.warehouseId,
          db.warehouses.warehouseId,
        ),
      );

  $$WarehousesTableProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<String>('warehouse_id')!;

    final manager = $$WarehousesTableTableManager(
      $_db,
      $_db.warehouses,
    ).filter((f) => f.warehouseId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$StockBalancesTableFilterComposer
    extends Composer<_$AppDatabase, $StockBalancesTable> {
  $$StockBalancesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get stockId => $composableBuilder(
    column: $table.stockId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get reservedQty => $composableBuilder(
    column: $table.reservedQty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get avgCost => $composableBuilder(
    column: $table.avgCost,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get lastCost => $composableBuilder(
    column: $table.lastCost,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ProductsTableFilterComposer get productId {
    final $$ProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableFilterComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableFilterComposer get warehouseId {
    final $$WarehousesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableFilterComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StockBalancesTableOrderingComposer
    extends Composer<_$AppDatabase, $StockBalancesTable> {
  $$StockBalancesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get stockId => $composableBuilder(
    column: $table.stockId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get reservedQty => $composableBuilder(
    column: $table.reservedQty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get avgCost => $composableBuilder(
    column: $table.avgCost,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get lastCost => $composableBuilder(
    column: $table.lastCost,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ProductsTableOrderingComposer get productId {
    final $$ProductsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableOrderingComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableOrderingComposer get warehouseId {
    final $$WarehousesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableOrderingComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StockBalancesTableAnnotationComposer
    extends Composer<_$AppDatabase, $StockBalancesTable> {
  $$StockBalancesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get stockId =>
      $composableBuilder(column: $table.stockId, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get reservedQty => $composableBuilder(
    column: $table.reservedQty,
    builder: (column) => column,
  );

  GeneratedColumn<double> get avgCost =>
      $composableBuilder(column: $table.avgCost, builder: (column) => column);

  GeneratedColumn<double> get lastCost =>
      $composableBuilder(column: $table.lastCost, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$ProductsTableAnnotationComposer get productId {
    final $$ProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableAnnotationComposer get warehouseId {
    final $$WarehousesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableAnnotationComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StockBalancesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $StockBalancesTable,
          StockBalance,
          $$StockBalancesTableFilterComposer,
          $$StockBalancesTableOrderingComposer,
          $$StockBalancesTableAnnotationComposer,
          $$StockBalancesTableCreateCompanionBuilder,
          $$StockBalancesTableUpdateCompanionBuilder,
          (StockBalance, $$StockBalancesTableReferences),
          StockBalance,
          PrefetchHooks Function({bool productId, bool warehouseId})
        > {
  $$StockBalancesTableTableManager(_$AppDatabase db, $StockBalancesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StockBalancesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StockBalancesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StockBalancesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> stockId = const Value.absent(),
                Value<String> productId = const Value.absent(),
                Value<String> warehouseId = const Value.absent(),
                Value<double> quantity = const Value.absent(),
                Value<double> reservedQty = const Value.absent(),
                Value<double> avgCost = const Value.absent(),
                Value<double> lastCost = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => StockBalancesCompanion(
                stockId: stockId,
                productId: productId,
                warehouseId: warehouseId,
                quantity: quantity,
                reservedQty: reservedQty,
                avgCost: avgCost,
                lastCost: lastCost,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String stockId,
                required String productId,
                required String warehouseId,
                Value<double> quantity = const Value.absent(),
                Value<double> reservedQty = const Value.absent(),
                Value<double> avgCost = const Value.absent(),
                Value<double> lastCost = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => StockBalancesCompanion.insert(
                stockId: stockId,
                productId: productId,
                warehouseId: warehouseId,
                quantity: quantity,
                reservedQty: reservedQty,
                avgCost: avgCost,
                lastCost: lastCost,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$StockBalancesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({productId = false, warehouseId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (productId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.productId,
                                referencedTable: $$StockBalancesTableReferences
                                    ._productIdTable(db),
                                referencedColumn: $$StockBalancesTableReferences
                                    ._productIdTable(db)
                                    .productId,
                              )
                              as T;
                    }
                    if (warehouseId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.warehouseId,
                                referencedTable: $$StockBalancesTableReferences
                                    ._warehouseIdTable(db),
                                referencedColumn: $$StockBalancesTableReferences
                                    ._warehouseIdTable(db)
                                    .warehouseId,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$StockBalancesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $StockBalancesTable,
      StockBalance,
      $$StockBalancesTableFilterComposer,
      $$StockBalancesTableOrderingComposer,
      $$StockBalancesTableAnnotationComposer,
      $$StockBalancesTableCreateCompanionBuilder,
      $$StockBalancesTableUpdateCompanionBuilder,
      (StockBalance, $$StockBalancesTableReferences),
      StockBalance,
      PrefetchHooks Function({bool productId, bool warehouseId})
    >;
typedef $$SerialNumbersTableCreateCompanionBuilder =
    SerialNumbersCompanion Function({
      required String serialId,
      required String productId,
      required String serialNo,
      required String warehouseId,
      Value<String> status,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$SerialNumbersTableUpdateCompanionBuilder =
    SerialNumbersCompanion Function({
      Value<String> serialId,
      Value<String> productId,
      Value<String> serialNo,
      Value<String> warehouseId,
      Value<String> status,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$SerialNumbersTableReferences
    extends BaseReferences<_$AppDatabase, $SerialNumbersTable, SerialNumber> {
  $$SerialNumbersTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ProductsTable _productIdTable(_$AppDatabase db) =>
      db.products.createAlias(
        $_aliasNameGenerator(db.serialNumbers.productId, db.products.productId),
      );

  $$ProductsTableProcessedTableManager get productId {
    final $_column = $_itemColumn<String>('product_id')!;

    final manager = $$ProductsTableTableManager(
      $_db,
      $_db.products,
    ).filter((f) => f.productId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $WarehousesTable _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias(
        $_aliasNameGenerator(
          db.serialNumbers.warehouseId,
          db.warehouses.warehouseId,
        ),
      );

  $$WarehousesTableProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<String>('warehouse_id')!;

    final manager = $$WarehousesTableTableManager(
      $_db,
      $_db.warehouses,
    ).filter((f) => f.warehouseId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$SerialNumbersTableFilterComposer
    extends Composer<_$AppDatabase, $SerialNumbersTable> {
  $$SerialNumbersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get serialId => $composableBuilder(
    column: $table.serialId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get serialNo => $composableBuilder(
    column: $table.serialNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ProductsTableFilterComposer get productId {
    final $$ProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableFilterComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableFilterComposer get warehouseId {
    final $$WarehousesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableFilterComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SerialNumbersTableOrderingComposer
    extends Composer<_$AppDatabase, $SerialNumbersTable> {
  $$SerialNumbersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get serialId => $composableBuilder(
    column: $table.serialId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get serialNo => $composableBuilder(
    column: $table.serialNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ProductsTableOrderingComposer get productId {
    final $$ProductsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableOrderingComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableOrderingComposer get warehouseId {
    final $$WarehousesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableOrderingComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SerialNumbersTableAnnotationComposer
    extends Composer<_$AppDatabase, $SerialNumbersTable> {
  $$SerialNumbersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get serialId =>
      $composableBuilder(column: $table.serialId, builder: (column) => column);

  GeneratedColumn<String> get serialNo =>
      $composableBuilder(column: $table.serialNo, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$ProductsTableAnnotationComposer get productId {
    final $$ProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableAnnotationComposer get warehouseId {
    final $$WarehousesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableAnnotationComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SerialNumbersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SerialNumbersTable,
          SerialNumber,
          $$SerialNumbersTableFilterComposer,
          $$SerialNumbersTableOrderingComposer,
          $$SerialNumbersTableAnnotationComposer,
          $$SerialNumbersTableCreateCompanionBuilder,
          $$SerialNumbersTableUpdateCompanionBuilder,
          (SerialNumber, $$SerialNumbersTableReferences),
          SerialNumber,
          PrefetchHooks Function({bool productId, bool warehouseId})
        > {
  $$SerialNumbersTableTableManager(_$AppDatabase db, $SerialNumbersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SerialNumbersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SerialNumbersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SerialNumbersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> serialId = const Value.absent(),
                Value<String> productId = const Value.absent(),
                Value<String> serialNo = const Value.absent(),
                Value<String> warehouseId = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SerialNumbersCompanion(
                serialId: serialId,
                productId: productId,
                serialNo: serialNo,
                warehouseId: warehouseId,
                status: status,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String serialId,
                required String productId,
                required String serialNo,
                required String warehouseId,
                Value<String> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SerialNumbersCompanion.insert(
                serialId: serialId,
                productId: productId,
                serialNo: serialNo,
                warehouseId: warehouseId,
                status: status,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SerialNumbersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({productId = false, warehouseId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (productId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.productId,
                                referencedTable: $$SerialNumbersTableReferences
                                    ._productIdTable(db),
                                referencedColumn: $$SerialNumbersTableReferences
                                    ._productIdTable(db)
                                    .productId,
                              )
                              as T;
                    }
                    if (warehouseId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.warehouseId,
                                referencedTable: $$SerialNumbersTableReferences
                                    ._warehouseIdTable(db),
                                referencedColumn: $$SerialNumbersTableReferences
                                    ._warehouseIdTable(db)
                                    .warehouseId,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$SerialNumbersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SerialNumbersTable,
      SerialNumber,
      $$SerialNumbersTableFilterComposer,
      $$SerialNumbersTableOrderingComposer,
      $$SerialNumbersTableAnnotationComposer,
      $$SerialNumbersTableCreateCompanionBuilder,
      $$SerialNumbersTableUpdateCompanionBuilder,
      (SerialNumber, $$SerialNumbersTableReferences),
      SerialNumber,
      PrefetchHooks Function({bool productId, bool warehouseId})
    >;
typedef $$ModifierGroupsTableCreateCompanionBuilder =
    ModifierGroupsCompanion Function({
      required String modifierGroupId,
      required String groupName,
      Value<String> selectionType,
      Value<int> minSelection,
      Value<int> maxSelection,
      Value<bool> isRequired,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$ModifierGroupsTableUpdateCompanionBuilder =
    ModifierGroupsCompanion Function({
      Value<String> modifierGroupId,
      Value<String> groupName,
      Value<String> selectionType,
      Value<int> minSelection,
      Value<int> maxSelection,
      Value<bool> isRequired,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ModifierGroupsTableReferences
    extends BaseReferences<_$AppDatabase, $ModifierGroupsTable, ModifierGroup> {
  $$ModifierGroupsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$ModifiersTable, List<Modifier>>
  _modifiersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.modifiers,
    aliasName: $_aliasNameGenerator(
      db.modifierGroups.modifierGroupId,
      db.modifiers.modifierGroupId,
    ),
  );

  $$ModifiersTableProcessedTableManager get modifiersRefs {
    final manager = $$ModifiersTableTableManager($_db, $_db.modifiers).filter(
      (f) => f.modifierGroupId.modifierGroupId.sqlEquals(
        $_itemColumn<String>('modifier_group_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_modifiersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ProductModifiersTable, List<ProductModifier>>
  _productModifiersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.productModifiers,
    aliasName: $_aliasNameGenerator(
      db.modifierGroups.modifierGroupId,
      db.productModifiers.modifierGroupId,
    ),
  );

  $$ProductModifiersTableProcessedTableManager get productModifiersRefs {
    final manager =
        $$ProductModifiersTableTableManager($_db, $_db.productModifiers).filter(
          (f) => f.modifierGroupId.modifierGroupId.sqlEquals(
            $_itemColumn<String>('modifier_group_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _productModifiersRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ModifierGroupsTableFilterComposer
    extends Composer<_$AppDatabase, $ModifierGroupsTable> {
  $$ModifierGroupsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get modifierGroupId => $composableBuilder(
    column: $table.modifierGroupId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get groupName => $composableBuilder(
    column: $table.groupName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get selectionType => $composableBuilder(
    column: $table.selectionType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get minSelection => $composableBuilder(
    column: $table.minSelection,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get maxSelection => $composableBuilder(
    column: $table.maxSelection,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isRequired => $composableBuilder(
    column: $table.isRequired,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> modifiersRefs(
    Expression<bool> Function($$ModifiersTableFilterComposer f) f,
  ) {
    final $$ModifiersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierGroupId,
      referencedTable: $db.modifiers,
      getReferencedColumn: (t) => t.modifierGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ModifiersTableFilterComposer(
            $db: $db,
            $table: $db.modifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> productModifiersRefs(
    Expression<bool> Function($$ProductModifiersTableFilterComposer f) f,
  ) {
    final $$ProductModifiersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierGroupId,
      referencedTable: $db.productModifiers,
      getReferencedColumn: (t) => t.modifierGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductModifiersTableFilterComposer(
            $db: $db,
            $table: $db.productModifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ModifierGroupsTableOrderingComposer
    extends Composer<_$AppDatabase, $ModifierGroupsTable> {
  $$ModifierGroupsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get modifierGroupId => $composableBuilder(
    column: $table.modifierGroupId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get groupName => $composableBuilder(
    column: $table.groupName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get selectionType => $composableBuilder(
    column: $table.selectionType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get minSelection => $composableBuilder(
    column: $table.minSelection,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get maxSelection => $composableBuilder(
    column: $table.maxSelection,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isRequired => $composableBuilder(
    column: $table.isRequired,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ModifierGroupsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ModifierGroupsTable> {
  $$ModifierGroupsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get modifierGroupId => $composableBuilder(
    column: $table.modifierGroupId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get groupName =>
      $composableBuilder(column: $table.groupName, builder: (column) => column);

  GeneratedColumn<String> get selectionType => $composableBuilder(
    column: $table.selectionType,
    builder: (column) => column,
  );

  GeneratedColumn<int> get minSelection => $composableBuilder(
    column: $table.minSelection,
    builder: (column) => column,
  );

  GeneratedColumn<int> get maxSelection => $composableBuilder(
    column: $table.maxSelection,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isRequired => $composableBuilder(
    column: $table.isRequired,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  Expression<T> modifiersRefs<T extends Object>(
    Expression<T> Function($$ModifiersTableAnnotationComposer a) f,
  ) {
    final $$ModifiersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierGroupId,
      referencedTable: $db.modifiers,
      getReferencedColumn: (t) => t.modifierGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ModifiersTableAnnotationComposer(
            $db: $db,
            $table: $db.modifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> productModifiersRefs<T extends Object>(
    Expression<T> Function($$ProductModifiersTableAnnotationComposer a) f,
  ) {
    final $$ProductModifiersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierGroupId,
      referencedTable: $db.productModifiers,
      getReferencedColumn: (t) => t.modifierGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductModifiersTableAnnotationComposer(
            $db: $db,
            $table: $db.productModifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ModifierGroupsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ModifierGroupsTable,
          ModifierGroup,
          $$ModifierGroupsTableFilterComposer,
          $$ModifierGroupsTableOrderingComposer,
          $$ModifierGroupsTableAnnotationComposer,
          $$ModifierGroupsTableCreateCompanionBuilder,
          $$ModifierGroupsTableUpdateCompanionBuilder,
          (ModifierGroup, $$ModifierGroupsTableReferences),
          ModifierGroup,
          PrefetchHooks Function({
            bool modifiersRefs,
            bool productModifiersRefs,
          })
        > {
  $$ModifierGroupsTableTableManager(
    _$AppDatabase db,
    $ModifierGroupsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ModifierGroupsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ModifierGroupsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ModifierGroupsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> modifierGroupId = const Value.absent(),
                Value<String> groupName = const Value.absent(),
                Value<String> selectionType = const Value.absent(),
                Value<int> minSelection = const Value.absent(),
                Value<int> maxSelection = const Value.absent(),
                Value<bool> isRequired = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ModifierGroupsCompanion(
                modifierGroupId: modifierGroupId,
                groupName: groupName,
                selectionType: selectionType,
                minSelection: minSelection,
                maxSelection: maxSelection,
                isRequired: isRequired,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String modifierGroupId,
                required String groupName,
                Value<String> selectionType = const Value.absent(),
                Value<int> minSelection = const Value.absent(),
                Value<int> maxSelection = const Value.absent(),
                Value<bool> isRequired = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ModifierGroupsCompanion.insert(
                modifierGroupId: modifierGroupId,
                groupName: groupName,
                selectionType: selectionType,
                minSelection: minSelection,
                maxSelection: maxSelection,
                isRequired: isRequired,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ModifierGroupsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({modifiersRefs = false, productModifiersRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (modifiersRefs) db.modifiers,
                    if (productModifiersRefs) db.productModifiers,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (modifiersRefs)
                        await $_getPrefetchedData<
                          ModifierGroup,
                          $ModifierGroupsTable,
                          Modifier
                        >(
                          currentTable: table,
                          referencedTable: $$ModifierGroupsTableReferences
                              ._modifiersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ModifierGroupsTableReferences(
                                db,
                                table,
                                p0,
                              ).modifiersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) =>
                                    e.modifierGroupId == item.modifierGroupId,
                              ),
                          typedResults: items,
                        ),
                      if (productModifiersRefs)
                        await $_getPrefetchedData<
                          ModifierGroup,
                          $ModifierGroupsTable,
                          ProductModifier
                        >(
                          currentTable: table,
                          referencedTable: $$ModifierGroupsTableReferences
                              ._productModifiersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ModifierGroupsTableReferences(
                                db,
                                table,
                                p0,
                              ).productModifiersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) =>
                                    e.modifierGroupId == item.modifierGroupId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ModifierGroupsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ModifierGroupsTable,
      ModifierGroup,
      $$ModifierGroupsTableFilterComposer,
      $$ModifierGroupsTableOrderingComposer,
      $$ModifierGroupsTableAnnotationComposer,
      $$ModifierGroupsTableCreateCompanionBuilder,
      $$ModifierGroupsTableUpdateCompanionBuilder,
      (ModifierGroup, $$ModifierGroupsTableReferences),
      ModifierGroup,
      PrefetchHooks Function({bool modifiersRefs, bool productModifiersRefs})
    >;
typedef $$ModifiersTableCreateCompanionBuilder =
    ModifiersCompanion Function({
      required String modifierId,
      required String modifierGroupId,
      required String modifierName,
      Value<double> priceAdjustment,
      Value<bool> isDefault,
      Value<int> displayOrder,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$ModifiersTableUpdateCompanionBuilder =
    ModifiersCompanion Function({
      Value<String> modifierId,
      Value<String> modifierGroupId,
      Value<String> modifierName,
      Value<double> priceAdjustment,
      Value<bool> isDefault,
      Value<int> displayOrder,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ModifiersTableReferences
    extends BaseReferences<_$AppDatabase, $ModifiersTable, Modifier> {
  $$ModifiersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ModifierGroupsTable _modifierGroupIdTable(_$AppDatabase db) =>
      db.modifierGroups.createAlias(
        $_aliasNameGenerator(
          db.modifiers.modifierGroupId,
          db.modifierGroups.modifierGroupId,
        ),
      );

  $$ModifierGroupsTableProcessedTableManager get modifierGroupId {
    final $_column = $_itemColumn<String>('modifier_group_id')!;

    final manager = $$ModifierGroupsTableTableManager(
      $_db,
      $_db.modifierGroups,
    ).filter((f) => f.modifierGroupId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_modifierGroupIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$OrderItemModifiersTable, List<OrderItemModifier>>
  _orderItemModifiersRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.orderItemModifiers,
        aliasName: $_aliasNameGenerator(
          db.modifiers.modifierId,
          db.orderItemModifiers.modifierId,
        ),
      );

  $$OrderItemModifiersTableProcessedTableManager get orderItemModifiersRefs {
    final manager =
        $$OrderItemModifiersTableTableManager(
          $_db,
          $_db.orderItemModifiers,
        ).filter(
          (f) => f.modifierId.modifierId.sqlEquals(
            $_itemColumn<String>('modifier_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _orderItemModifiersRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ModifiersTableFilterComposer
    extends Composer<_$AppDatabase, $ModifiersTable> {
  $$ModifiersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get modifierId => $composableBuilder(
    column: $table.modifierId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get modifierName => $composableBuilder(
    column: $table.modifierName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get priceAdjustment => $composableBuilder(
    column: $table.priceAdjustment,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ModifierGroupsTableFilterComposer get modifierGroupId {
    final $$ModifierGroupsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierGroupId,
      referencedTable: $db.modifierGroups,
      getReferencedColumn: (t) => t.modifierGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ModifierGroupsTableFilterComposer(
            $db: $db,
            $table: $db.modifierGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> orderItemModifiersRefs(
    Expression<bool> Function($$OrderItemModifiersTableFilterComposer f) f,
  ) {
    final $$OrderItemModifiersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierId,
      referencedTable: $db.orderItemModifiers,
      getReferencedColumn: (t) => t.modifierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemModifiersTableFilterComposer(
            $db: $db,
            $table: $db.orderItemModifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ModifiersTableOrderingComposer
    extends Composer<_$AppDatabase, $ModifiersTable> {
  $$ModifiersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get modifierId => $composableBuilder(
    column: $table.modifierId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get modifierName => $composableBuilder(
    column: $table.modifierName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get priceAdjustment => $composableBuilder(
    column: $table.priceAdjustment,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ModifierGroupsTableOrderingComposer get modifierGroupId {
    final $$ModifierGroupsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierGroupId,
      referencedTable: $db.modifierGroups,
      getReferencedColumn: (t) => t.modifierGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ModifierGroupsTableOrderingComposer(
            $db: $db,
            $table: $db.modifierGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ModifiersTableAnnotationComposer
    extends Composer<_$AppDatabase, $ModifiersTable> {
  $$ModifiersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get modifierId => $composableBuilder(
    column: $table.modifierId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get modifierName => $composableBuilder(
    column: $table.modifierName,
    builder: (column) => column,
  );

  GeneratedColumn<double> get priceAdjustment => $composableBuilder(
    column: $table.priceAdjustment,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isDefault =>
      $composableBuilder(column: $table.isDefault, builder: (column) => column);

  GeneratedColumn<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$ModifierGroupsTableAnnotationComposer get modifierGroupId {
    final $$ModifierGroupsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierGroupId,
      referencedTable: $db.modifierGroups,
      getReferencedColumn: (t) => t.modifierGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ModifierGroupsTableAnnotationComposer(
            $db: $db,
            $table: $db.modifierGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> orderItemModifiersRefs<T extends Object>(
    Expression<T> Function($$OrderItemModifiersTableAnnotationComposer a) f,
  ) {
    final $$OrderItemModifiersTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.modifierId,
          referencedTable: $db.orderItemModifiers,
          getReferencedColumn: (t) => t.modifierId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$OrderItemModifiersTableAnnotationComposer(
                $db: $db,
                $table: $db.orderItemModifiers,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$ModifiersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ModifiersTable,
          Modifier,
          $$ModifiersTableFilterComposer,
          $$ModifiersTableOrderingComposer,
          $$ModifiersTableAnnotationComposer,
          $$ModifiersTableCreateCompanionBuilder,
          $$ModifiersTableUpdateCompanionBuilder,
          (Modifier, $$ModifiersTableReferences),
          Modifier,
          PrefetchHooks Function({
            bool modifierGroupId,
            bool orderItemModifiersRefs,
          })
        > {
  $$ModifiersTableTableManager(_$AppDatabase db, $ModifiersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ModifiersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ModifiersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ModifiersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> modifierId = const Value.absent(),
                Value<String> modifierGroupId = const Value.absent(),
                Value<String> modifierName = const Value.absent(),
                Value<double> priceAdjustment = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<int> displayOrder = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ModifiersCompanion(
                modifierId: modifierId,
                modifierGroupId: modifierGroupId,
                modifierName: modifierName,
                priceAdjustment: priceAdjustment,
                isDefault: isDefault,
                displayOrder: displayOrder,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String modifierId,
                required String modifierGroupId,
                required String modifierName,
                Value<double> priceAdjustment = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<int> displayOrder = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ModifiersCompanion.insert(
                modifierId: modifierId,
                modifierGroupId: modifierGroupId,
                modifierName: modifierName,
                priceAdjustment: priceAdjustment,
                isDefault: isDefault,
                displayOrder: displayOrder,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ModifiersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({modifierGroupId = false, orderItemModifiersRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (orderItemModifiersRefs) db.orderItemModifiers,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (modifierGroupId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.modifierGroupId,
                                    referencedTable: $$ModifiersTableReferences
                                        ._modifierGroupIdTable(db),
                                    referencedColumn: $$ModifiersTableReferences
                                        ._modifierGroupIdTable(db)
                                        .modifierGroupId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (orderItemModifiersRefs)
                        await $_getPrefetchedData<
                          Modifier,
                          $ModifiersTable,
                          OrderItemModifier
                        >(
                          currentTable: table,
                          referencedTable: $$ModifiersTableReferences
                              ._orderItemModifiersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ModifiersTableReferences(
                                db,
                                table,
                                p0,
                              ).orderItemModifiersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.modifierId == item.modifierId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ModifiersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ModifiersTable,
      Modifier,
      $$ModifiersTableFilterComposer,
      $$ModifiersTableOrderingComposer,
      $$ModifiersTableAnnotationComposer,
      $$ModifiersTableCreateCompanionBuilder,
      $$ModifiersTableUpdateCompanionBuilder,
      (Modifier, $$ModifiersTableReferences),
      Modifier,
      PrefetchHooks Function({
        bool modifierGroupId,
        bool orderItemModifiersRefs,
      })
    >;
typedef $$ProductModifiersTableCreateCompanionBuilder =
    ProductModifiersCompanion Function({
      required String productId,
      required String modifierGroupId,
      Value<bool> isRequired,
      Value<int> rowid,
    });
typedef $$ProductModifiersTableUpdateCompanionBuilder =
    ProductModifiersCompanion Function({
      Value<String> productId,
      Value<String> modifierGroupId,
      Value<bool> isRequired,
      Value<int> rowid,
    });

final class $$ProductModifiersTableReferences
    extends
        BaseReferences<_$AppDatabase, $ProductModifiersTable, ProductModifier> {
  $$ProductModifiersTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ProductsTable _productIdTable(_$AppDatabase db) =>
      db.products.createAlias(
        $_aliasNameGenerator(
          db.productModifiers.productId,
          db.products.productId,
        ),
      );

  $$ProductsTableProcessedTableManager get productId {
    final $_column = $_itemColumn<String>('product_id')!;

    final manager = $$ProductsTableTableManager(
      $_db,
      $_db.products,
    ).filter((f) => f.productId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ModifierGroupsTable _modifierGroupIdTable(_$AppDatabase db) =>
      db.modifierGroups.createAlias(
        $_aliasNameGenerator(
          db.productModifiers.modifierGroupId,
          db.modifierGroups.modifierGroupId,
        ),
      );

  $$ModifierGroupsTableProcessedTableManager get modifierGroupId {
    final $_column = $_itemColumn<String>('modifier_group_id')!;

    final manager = $$ModifierGroupsTableTableManager(
      $_db,
      $_db.modifierGroups,
    ).filter((f) => f.modifierGroupId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_modifierGroupIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ProductModifiersTableFilterComposer
    extends Composer<_$AppDatabase, $ProductModifiersTable> {
  $$ProductModifiersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isRequired => $composableBuilder(
    column: $table.isRequired,
    builder: (column) => ColumnFilters(column),
  );

  $$ProductsTableFilterComposer get productId {
    final $$ProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableFilterComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ModifierGroupsTableFilterComposer get modifierGroupId {
    final $$ModifierGroupsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierGroupId,
      referencedTable: $db.modifierGroups,
      getReferencedColumn: (t) => t.modifierGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ModifierGroupsTableFilterComposer(
            $db: $db,
            $table: $db.modifierGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ProductModifiersTableOrderingComposer
    extends Composer<_$AppDatabase, $ProductModifiersTable> {
  $$ProductModifiersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isRequired => $composableBuilder(
    column: $table.isRequired,
    builder: (column) => ColumnOrderings(column),
  );

  $$ProductsTableOrderingComposer get productId {
    final $$ProductsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableOrderingComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ModifierGroupsTableOrderingComposer get modifierGroupId {
    final $$ModifierGroupsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierGroupId,
      referencedTable: $db.modifierGroups,
      getReferencedColumn: (t) => t.modifierGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ModifierGroupsTableOrderingComposer(
            $db: $db,
            $table: $db.modifierGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ProductModifiersTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProductModifiersTable> {
  $$ProductModifiersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isRequired => $composableBuilder(
    column: $table.isRequired,
    builder: (column) => column,
  );

  $$ProductsTableAnnotationComposer get productId {
    final $$ProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ModifierGroupsTableAnnotationComposer get modifierGroupId {
    final $$ModifierGroupsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierGroupId,
      referencedTable: $db.modifierGroups,
      getReferencedColumn: (t) => t.modifierGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ModifierGroupsTableAnnotationComposer(
            $db: $db,
            $table: $db.modifierGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ProductModifiersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ProductModifiersTable,
          ProductModifier,
          $$ProductModifiersTableFilterComposer,
          $$ProductModifiersTableOrderingComposer,
          $$ProductModifiersTableAnnotationComposer,
          $$ProductModifiersTableCreateCompanionBuilder,
          $$ProductModifiersTableUpdateCompanionBuilder,
          (ProductModifier, $$ProductModifiersTableReferences),
          ProductModifier,
          PrefetchHooks Function({bool productId, bool modifierGroupId})
        > {
  $$ProductModifiersTableTableManager(
    _$AppDatabase db,
    $ProductModifiersTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProductModifiersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProductModifiersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProductModifiersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> productId = const Value.absent(),
                Value<String> modifierGroupId = const Value.absent(),
                Value<bool> isRequired = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProductModifiersCompanion(
                productId: productId,
                modifierGroupId: modifierGroupId,
                isRequired: isRequired,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String productId,
                required String modifierGroupId,
                Value<bool> isRequired = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProductModifiersCompanion.insert(
                productId: productId,
                modifierGroupId: modifierGroupId,
                isRequired: isRequired,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ProductModifiersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({productId = false, modifierGroupId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable:
                                        $$ProductModifiersTableReferences
                                            ._productIdTable(db),
                                    referencedColumn:
                                        $$ProductModifiersTableReferences
                                            ._productIdTable(db)
                                            .productId,
                                  )
                                  as T;
                        }
                        if (modifierGroupId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.modifierGroupId,
                                    referencedTable:
                                        $$ProductModifiersTableReferences
                                            ._modifierGroupIdTable(db),
                                    referencedColumn:
                                        $$ProductModifiersTableReferences
                                            ._modifierGroupIdTable(db)
                                            .modifierGroupId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$ProductModifiersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ProductModifiersTable,
      ProductModifier,
      $$ProductModifiersTableFilterComposer,
      $$ProductModifiersTableOrderingComposer,
      $$ProductModifiersTableAnnotationComposer,
      $$ProductModifiersTableCreateCompanionBuilder,
      $$ProductModifiersTableUpdateCompanionBuilder,
      (ProductModifier, $$ProductModifiersTableReferences),
      ProductModifier,
      PrefetchHooks Function({bool productId, bool modifierGroupId})
    >;
typedef $$ZonesTableCreateCompanionBuilder =
    ZonesCompanion Function({
      required String zoneId,
      required String zoneName,
      required String branchId,
      Value<int> displayOrder,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$ZonesTableUpdateCompanionBuilder =
    ZonesCompanion Function({
      Value<String> zoneId,
      Value<String> zoneName,
      Value<String> branchId,
      Value<int> displayOrder,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ZonesTableReferences
    extends BaseReferences<_$AppDatabase, $ZonesTable, Zone> {
  $$ZonesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BranchesTable _branchIdTable(_$AppDatabase db) =>
      db.branches.createAlias(
        $_aliasNameGenerator(db.zones.branchId, db.branches.branchId),
      );

  $$BranchesTableProcessedTableManager get branchId {
    final $_column = $_itemColumn<String>('branch_id')!;

    final manager = $$BranchesTableTableManager(
      $_db,
      $_db.branches,
    ).filter((f) => f.branchId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_branchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$DiningTablesTable, List<DiningTable>>
  _diningTablesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.diningTables,
    aliasName: $_aliasNameGenerator(db.zones.zoneId, db.diningTables.zoneId),
  );

  $$DiningTablesTableProcessedTableManager get diningTablesRefs {
    final manager = $$DiningTablesTableTableManager($_db, $_db.diningTables)
        .filter(
          (f) => f.zoneId.zoneId.sqlEquals($_itemColumn<String>('zone_id')!),
        );

    final cache = $_typedResult.readTableOrNull(_diningTablesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ZonesTableFilterComposer extends Composer<_$AppDatabase, $ZonesTable> {
  $$ZonesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get zoneId => $composableBuilder(
    column: $table.zoneId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get zoneName => $composableBuilder(
    column: $table.zoneName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BranchesTableFilterComposer get branchId {
    final $$BranchesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableFilterComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> diningTablesRefs(
    Expression<bool> Function($$DiningTablesTableFilterComposer f) f,
  ) {
    final $$DiningTablesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.zoneId,
      referencedTable: $db.diningTables,
      getReferencedColumn: (t) => t.zoneId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DiningTablesTableFilterComposer(
            $db: $db,
            $table: $db.diningTables,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ZonesTableOrderingComposer
    extends Composer<_$AppDatabase, $ZonesTable> {
  $$ZonesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get zoneId => $composableBuilder(
    column: $table.zoneId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get zoneName => $composableBuilder(
    column: $table.zoneName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BranchesTableOrderingComposer get branchId {
    final $$BranchesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableOrderingComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ZonesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ZonesTable> {
  $$ZonesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get zoneId =>
      $composableBuilder(column: $table.zoneId, builder: (column) => column);

  GeneratedColumn<String> get zoneName =>
      $composableBuilder(column: $table.zoneName, builder: (column) => column);

  GeneratedColumn<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$BranchesTableAnnotationComposer get branchId {
    final $$BranchesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableAnnotationComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> diningTablesRefs<T extends Object>(
    Expression<T> Function($$DiningTablesTableAnnotationComposer a) f,
  ) {
    final $$DiningTablesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.zoneId,
      referencedTable: $db.diningTables,
      getReferencedColumn: (t) => t.zoneId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DiningTablesTableAnnotationComposer(
            $db: $db,
            $table: $db.diningTables,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ZonesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ZonesTable,
          Zone,
          $$ZonesTableFilterComposer,
          $$ZonesTableOrderingComposer,
          $$ZonesTableAnnotationComposer,
          $$ZonesTableCreateCompanionBuilder,
          $$ZonesTableUpdateCompanionBuilder,
          (Zone, $$ZonesTableReferences),
          Zone,
          PrefetchHooks Function({bool branchId, bool diningTablesRefs})
        > {
  $$ZonesTableTableManager(_$AppDatabase db, $ZonesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ZonesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ZonesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ZonesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> zoneId = const Value.absent(),
                Value<String> zoneName = const Value.absent(),
                Value<String> branchId = const Value.absent(),
                Value<int> displayOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ZonesCompanion(
                zoneId: zoneId,
                zoneName: zoneName,
                branchId: branchId,
                displayOrder: displayOrder,
                isActive: isActive,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String zoneId,
                required String zoneName,
                required String branchId,
                Value<int> displayOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ZonesCompanion.insert(
                zoneId: zoneId,
                zoneName: zoneName,
                branchId: branchId,
                displayOrder: displayOrder,
                isActive: isActive,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$ZonesTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({branchId = false, diningTablesRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (diningTablesRefs) db.diningTables,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (branchId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.branchId,
                                    referencedTable: $$ZonesTableReferences
                                        ._branchIdTable(db),
                                    referencedColumn: $$ZonesTableReferences
                                        ._branchIdTable(db)
                                        .branchId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (diningTablesRefs)
                        await $_getPrefetchedData<
                          Zone,
                          $ZonesTable,
                          DiningTable
                        >(
                          currentTable: table,
                          referencedTable: $$ZonesTableReferences
                              ._diningTablesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ZonesTableReferences(
                                db,
                                table,
                                p0,
                              ).diningTablesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.zoneId == item.zoneId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ZonesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ZonesTable,
      Zone,
      $$ZonesTableFilterComposer,
      $$ZonesTableOrderingComposer,
      $$ZonesTableAnnotationComposer,
      $$ZonesTableCreateCompanionBuilder,
      $$ZonesTableUpdateCompanionBuilder,
      (Zone, $$ZonesTableReferences),
      Zone,
      PrefetchHooks Function({bool branchId, bool diningTablesRefs})
    >;
typedef $$DiningTablesTableCreateCompanionBuilder =
    DiningTablesCompanion Function({
      required String tableId,
      required String tableNo,
      Value<String?> tableDisplayName,
      required String zoneId,
      Value<int> capacity,
      Value<String> status,
      Value<String?> currentOrderId,
      Value<DateTime?> lastOccupiedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$DiningTablesTableUpdateCompanionBuilder =
    DiningTablesCompanion Function({
      Value<String> tableId,
      Value<String> tableNo,
      Value<String?> tableDisplayName,
      Value<String> zoneId,
      Value<int> capacity,
      Value<String> status,
      Value<String?> currentOrderId,
      Value<DateTime?> lastOccupiedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$DiningTablesTableReferences
    extends BaseReferences<_$AppDatabase, $DiningTablesTable, DiningTable> {
  $$DiningTablesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ZonesTable _zoneIdTable(_$AppDatabase db) => db.zones.createAlias(
    $_aliasNameGenerator(db.diningTables.zoneId, db.zones.zoneId),
  );

  $$ZonesTableProcessedTableManager get zoneId {
    final $_column = $_itemColumn<String>('zone_id')!;

    final manager = $$ZonesTableTableManager(
      $_db,
      $_db.zones,
    ).filter((f) => f.zoneId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_zoneIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$DiningTablesTableFilterComposer
    extends Composer<_$AppDatabase, $DiningTablesTable> {
  $$DiningTablesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get tableId => $composableBuilder(
    column: $table.tableId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tableNo => $composableBuilder(
    column: $table.tableNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tableDisplayName => $composableBuilder(
    column: $table.tableDisplayName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get capacity => $composableBuilder(
    column: $table.capacity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get currentOrderId => $composableBuilder(
    column: $table.currentOrderId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastOccupiedAt => $composableBuilder(
    column: $table.lastOccupiedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ZonesTableFilterComposer get zoneId {
    final $$ZonesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.zoneId,
      referencedTable: $db.zones,
      getReferencedColumn: (t) => t.zoneId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ZonesTableFilterComposer(
            $db: $db,
            $table: $db.zones,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$DiningTablesTableOrderingComposer
    extends Composer<_$AppDatabase, $DiningTablesTable> {
  $$DiningTablesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get tableId => $composableBuilder(
    column: $table.tableId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tableNo => $composableBuilder(
    column: $table.tableNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tableDisplayName => $composableBuilder(
    column: $table.tableDisplayName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get capacity => $composableBuilder(
    column: $table.capacity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currentOrderId => $composableBuilder(
    column: $table.currentOrderId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastOccupiedAt => $composableBuilder(
    column: $table.lastOccupiedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ZonesTableOrderingComposer get zoneId {
    final $$ZonesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.zoneId,
      referencedTable: $db.zones,
      getReferencedColumn: (t) => t.zoneId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ZonesTableOrderingComposer(
            $db: $db,
            $table: $db.zones,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$DiningTablesTableAnnotationComposer
    extends Composer<_$AppDatabase, $DiningTablesTable> {
  $$DiningTablesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get tableId =>
      $composableBuilder(column: $table.tableId, builder: (column) => column);

  GeneratedColumn<String> get tableNo =>
      $composableBuilder(column: $table.tableNo, builder: (column) => column);

  GeneratedColumn<String> get tableDisplayName => $composableBuilder(
    column: $table.tableDisplayName,
    builder: (column) => column,
  );

  GeneratedColumn<int> get capacity =>
      $composableBuilder(column: $table.capacity, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get currentOrderId => $composableBuilder(
    column: $table.currentOrderId,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastOccupiedAt => $composableBuilder(
    column: $table.lastOccupiedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$ZonesTableAnnotationComposer get zoneId {
    final $$ZonesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.zoneId,
      referencedTable: $db.zones,
      getReferencedColumn: (t) => t.zoneId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ZonesTableAnnotationComposer(
            $db: $db,
            $table: $db.zones,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$DiningTablesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $DiningTablesTable,
          DiningTable,
          $$DiningTablesTableFilterComposer,
          $$DiningTablesTableOrderingComposer,
          $$DiningTablesTableAnnotationComposer,
          $$DiningTablesTableCreateCompanionBuilder,
          $$DiningTablesTableUpdateCompanionBuilder,
          (DiningTable, $$DiningTablesTableReferences),
          DiningTable,
          PrefetchHooks Function({bool zoneId})
        > {
  $$DiningTablesTableTableManager(_$AppDatabase db, $DiningTablesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DiningTablesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DiningTablesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DiningTablesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> tableId = const Value.absent(),
                Value<String> tableNo = const Value.absent(),
                Value<String?> tableDisplayName = const Value.absent(),
                Value<String> zoneId = const Value.absent(),
                Value<int> capacity = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> currentOrderId = const Value.absent(),
                Value<DateTime?> lastOccupiedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => DiningTablesCompanion(
                tableId: tableId,
                tableNo: tableNo,
                tableDisplayName: tableDisplayName,
                zoneId: zoneId,
                capacity: capacity,
                status: status,
                currentOrderId: currentOrderId,
                lastOccupiedAt: lastOccupiedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String tableId,
                required String tableNo,
                Value<String?> tableDisplayName = const Value.absent(),
                required String zoneId,
                Value<int> capacity = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> currentOrderId = const Value.absent(),
                Value<DateTime?> lastOccupiedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => DiningTablesCompanion.insert(
                tableId: tableId,
                tableNo: tableNo,
                tableDisplayName: tableDisplayName,
                zoneId: zoneId,
                capacity: capacity,
                status: status,
                currentOrderId: currentOrderId,
                lastOccupiedAt: lastOccupiedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$DiningTablesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({zoneId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (zoneId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.zoneId,
                                referencedTable: $$DiningTablesTableReferences
                                    ._zoneIdTable(db),
                                referencedColumn: $$DiningTablesTableReferences
                                    ._zoneIdTable(db)
                                    .zoneId,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$DiningTablesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $DiningTablesTable,
      DiningTable,
      $$DiningTablesTableFilterComposer,
      $$DiningTablesTableOrderingComposer,
      $$DiningTablesTableAnnotationComposer,
      $$DiningTablesTableCreateCompanionBuilder,
      $$DiningTablesTableUpdateCompanionBuilder,
      (DiningTable, $$DiningTablesTableReferences),
      DiningTable,
      PrefetchHooks Function({bool zoneId})
    >;
typedef $$CustomerGroupsTableCreateCompanionBuilder =
    CustomerGroupsCompanion Function({
      required String customerGroupId,
      required String groupName,
      Value<double> discountRate,
      Value<int> priceLevel,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$CustomerGroupsTableUpdateCompanionBuilder =
    CustomerGroupsCompanion Function({
      Value<String> customerGroupId,
      Value<String> groupName,
      Value<double> discountRate,
      Value<int> priceLevel,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$CustomerGroupsTableReferences
    extends BaseReferences<_$AppDatabase, $CustomerGroupsTable, CustomerGroup> {
  $$CustomerGroupsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$CustomersTable, List<Customer>>
  _customersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.customers,
    aliasName: $_aliasNameGenerator(
      db.customerGroups.customerGroupId,
      db.customers.customerGroupId,
    ),
  );

  $$CustomersTableProcessedTableManager get customersRefs {
    final manager = $$CustomersTableTableManager($_db, $_db.customers).filter(
      (f) => f.customerGroupId.customerGroupId.sqlEquals(
        $_itemColumn<String>('customer_group_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_customersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CustomerGroupsTableFilterComposer
    extends Composer<_$AppDatabase, $CustomerGroupsTable> {
  $$CustomerGroupsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get customerGroupId => $composableBuilder(
    column: $table.customerGroupId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get groupName => $composableBuilder(
    column: $table.groupName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get discountRate => $composableBuilder(
    column: $table.discountRate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get priceLevel => $composableBuilder(
    column: $table.priceLevel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> customersRefs(
    Expression<bool> Function($$CustomersTableFilterComposer f) f,
  ) {
    final $$CustomersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerGroupId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableFilterComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CustomerGroupsTableOrderingComposer
    extends Composer<_$AppDatabase, $CustomerGroupsTable> {
  $$CustomerGroupsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get customerGroupId => $composableBuilder(
    column: $table.customerGroupId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get groupName => $composableBuilder(
    column: $table.groupName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get discountRate => $composableBuilder(
    column: $table.discountRate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get priceLevel => $composableBuilder(
    column: $table.priceLevel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CustomerGroupsTableAnnotationComposer
    extends Composer<_$AppDatabase, $CustomerGroupsTable> {
  $$CustomerGroupsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get customerGroupId => $composableBuilder(
    column: $table.customerGroupId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get groupName =>
      $composableBuilder(column: $table.groupName, builder: (column) => column);

  GeneratedColumn<double> get discountRate => $composableBuilder(
    column: $table.discountRate,
    builder: (column) => column,
  );

  GeneratedColumn<int> get priceLevel => $composableBuilder(
    column: $table.priceLevel,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  Expression<T> customersRefs<T extends Object>(
    Expression<T> Function($$CustomersTableAnnotationComposer a) f,
  ) {
    final $$CustomersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerGroupId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableAnnotationComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CustomerGroupsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CustomerGroupsTable,
          CustomerGroup,
          $$CustomerGroupsTableFilterComposer,
          $$CustomerGroupsTableOrderingComposer,
          $$CustomerGroupsTableAnnotationComposer,
          $$CustomerGroupsTableCreateCompanionBuilder,
          $$CustomerGroupsTableUpdateCompanionBuilder,
          (CustomerGroup, $$CustomerGroupsTableReferences),
          CustomerGroup,
          PrefetchHooks Function({bool customersRefs})
        > {
  $$CustomerGroupsTableTableManager(
    _$AppDatabase db,
    $CustomerGroupsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CustomerGroupsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CustomerGroupsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CustomerGroupsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> customerGroupId = const Value.absent(),
                Value<String> groupName = const Value.absent(),
                Value<double> discountRate = const Value.absent(),
                Value<int> priceLevel = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CustomerGroupsCompanion(
                customerGroupId: customerGroupId,
                groupName: groupName,
                discountRate: discountRate,
                priceLevel: priceLevel,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String customerGroupId,
                required String groupName,
                Value<double> discountRate = const Value.absent(),
                Value<int> priceLevel = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CustomerGroupsCompanion.insert(
                customerGroupId: customerGroupId,
                groupName: groupName,
                discountRate: discountRate,
                priceLevel: priceLevel,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CustomerGroupsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({customersRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (customersRefs) db.customers],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (customersRefs)
                    await $_getPrefetchedData<
                      CustomerGroup,
                      $CustomerGroupsTable,
                      Customer
                    >(
                      currentTable: table,
                      referencedTable: $$CustomerGroupsTableReferences
                          ._customersRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$CustomerGroupsTableReferences(
                            db,
                            table,
                            p0,
                          ).customersRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.customerGroupId == item.customerGroupId,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$CustomerGroupsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CustomerGroupsTable,
      CustomerGroup,
      $$CustomerGroupsTableFilterComposer,
      $$CustomerGroupsTableOrderingComposer,
      $$CustomerGroupsTableAnnotationComposer,
      $$CustomerGroupsTableCreateCompanionBuilder,
      $$CustomerGroupsTableUpdateCompanionBuilder,
      (CustomerGroup, $$CustomerGroupsTableReferences),
      CustomerGroup,
      PrefetchHooks Function({bool customersRefs})
    >;
typedef $$CustomersTableCreateCompanionBuilder =
    CustomersCompanion Function({
      required String customerId,
      required String customerCode,
      required String customerName,
      Value<String?> customerGroupId,
      Value<String?> address,
      Value<String?> phone,
      Value<String?> email,
      Value<String?> taxId,
      Value<double> creditLimit,
      Value<int> creditDays,
      Value<double> currentBalance,
      Value<String?> memberNo,
      Value<int> points,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$CustomersTableUpdateCompanionBuilder =
    CustomersCompanion Function({
      Value<String> customerId,
      Value<String> customerCode,
      Value<String> customerName,
      Value<String?> customerGroupId,
      Value<String?> address,
      Value<String?> phone,
      Value<String?> email,
      Value<String?> taxId,
      Value<double> creditLimit,
      Value<int> creditDays,
      Value<double> currentBalance,
      Value<String?> memberNo,
      Value<int> points,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$CustomersTableReferences
    extends BaseReferences<_$AppDatabase, $CustomersTable, Customer> {
  $$CustomersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $CustomerGroupsTable _customerGroupIdTable(_$AppDatabase db) =>
      db.customerGroups.createAlias(
        $_aliasNameGenerator(
          db.customers.customerGroupId,
          db.customerGroups.customerGroupId,
        ),
      );

  $$CustomerGroupsTableProcessedTableManager? get customerGroupId {
    final $_column = $_itemColumn<String>('customer_group_id');
    if ($_column == null) return null;
    final manager = $$CustomerGroupsTableTableManager(
      $_db,
      $_db.customerGroups,
    ).filter((f) => f.customerGroupId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_customerGroupIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$SalesOrdersTable, List<SalesOrder>>
  _salesOrdersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.salesOrders,
    aliasName: $_aliasNameGenerator(
      db.customers.customerId,
      db.salesOrders.customerId,
    ),
  );

  $$SalesOrdersTableProcessedTableManager get salesOrdersRefs {
    final manager = $$SalesOrdersTableTableManager($_db, $_db.salesOrders)
        .filter(
          (f) => f.customerId.customerId.sqlEquals(
            $_itemColumn<String>('customer_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(_salesOrdersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PromotionUsagesTable, List<PromotionUsage>>
  _promotionUsagesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.promotionUsages,
    aliasName: $_aliasNameGenerator(
      db.customers.customerId,
      db.promotionUsages.customerId,
    ),
  );

  $$PromotionUsagesTableProcessedTableManager get promotionUsagesRefs {
    final manager =
        $$PromotionUsagesTableTableManager($_db, $_db.promotionUsages).filter(
          (f) => f.customerId.customerId.sqlEquals(
            $_itemColumn<String>('customer_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _promotionUsagesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$CouponsTable, List<Coupon>> _couponsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.coupons,
    aliasName: $_aliasNameGenerator(db.customers.customerId, db.coupons.usedBy),
  );

  $$CouponsTableProcessedTableManager get couponsRefs {
    final manager = $$CouponsTableTableManager($_db, $_db.coupons).filter(
      (f) =>
          f.usedBy.customerId.sqlEquals($_itemColumn<String>('customer_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_couponsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ArInvoicesTable, List<ArInvoice>>
  _arInvoicesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.arInvoices,
    aliasName: $_aliasNameGenerator(
      db.customers.customerId,
      db.arInvoices.customerId,
    ),
  );

  $$ArInvoicesTableProcessedTableManager get arInvoicesRefs {
    final manager = $$ArInvoicesTableTableManager($_db, $_db.arInvoices).filter(
      (f) => f.customerId.customerId.sqlEquals(
        $_itemColumn<String>('customer_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_arInvoicesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ArReceiptsTable, List<ArReceipt>>
  _arReceiptsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.arReceipts,
    aliasName: $_aliasNameGenerator(
      db.customers.customerId,
      db.arReceipts.customerId,
    ),
  );

  $$ArReceiptsTableProcessedTableManager get arReceiptsRefs {
    final manager = $$ArReceiptsTableTableManager($_db, $_db.arReceipts).filter(
      (f) => f.customerId.customerId.sqlEquals(
        $_itemColumn<String>('customer_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_arReceiptsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CustomersTableFilterComposer
    extends Composer<_$AppDatabase, $CustomersTable> {
  $$CustomersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get customerId => $composableBuilder(
    column: $table.customerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get customerCode => $composableBuilder(
    column: $table.customerCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get customerName => $composableBuilder(
    column: $table.customerName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get taxId => $composableBuilder(
    column: $table.taxId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get creditLimit => $composableBuilder(
    column: $table.creditLimit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get creditDays => $composableBuilder(
    column: $table.creditDays,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get currentBalance => $composableBuilder(
    column: $table.currentBalance,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get memberNo => $composableBuilder(
    column: $table.memberNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get points => $composableBuilder(
    column: $table.points,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CustomerGroupsTableFilterComposer get customerGroupId {
    final $$CustomerGroupsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerGroupId,
      referencedTable: $db.customerGroups,
      getReferencedColumn: (t) => t.customerGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomerGroupsTableFilterComposer(
            $db: $db,
            $table: $db.customerGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> salesOrdersRefs(
    Expression<bool> Function($$SalesOrdersTableFilterComposer f) f,
  ) {
    final $$SalesOrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableFilterComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> promotionUsagesRefs(
    Expression<bool> Function($$PromotionUsagesTableFilterComposer f) f,
  ) {
    final $$PromotionUsagesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.promotionUsages,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionUsagesTableFilterComposer(
            $db: $db,
            $table: $db.promotionUsages,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> couponsRefs(
    Expression<bool> Function($$CouponsTableFilterComposer f) f,
  ) {
    final $$CouponsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.coupons,
      getReferencedColumn: (t) => t.usedBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CouponsTableFilterComposer(
            $db: $db,
            $table: $db.coupons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> arInvoicesRefs(
    Expression<bool> Function($$ArInvoicesTableFilterComposer f) f,
  ) {
    final $$ArInvoicesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.arInvoices,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArInvoicesTableFilterComposer(
            $db: $db,
            $table: $db.arInvoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> arReceiptsRefs(
    Expression<bool> Function($$ArReceiptsTableFilterComposer f) f,
  ) {
    final $$ArReceiptsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.arReceipts,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArReceiptsTableFilterComposer(
            $db: $db,
            $table: $db.arReceipts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CustomersTableOrderingComposer
    extends Composer<_$AppDatabase, $CustomersTable> {
  $$CustomersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get customerId => $composableBuilder(
    column: $table.customerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get customerCode => $composableBuilder(
    column: $table.customerCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get customerName => $composableBuilder(
    column: $table.customerName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get taxId => $composableBuilder(
    column: $table.taxId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get creditLimit => $composableBuilder(
    column: $table.creditLimit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get creditDays => $composableBuilder(
    column: $table.creditDays,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get currentBalance => $composableBuilder(
    column: $table.currentBalance,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get memberNo => $composableBuilder(
    column: $table.memberNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get points => $composableBuilder(
    column: $table.points,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CustomerGroupsTableOrderingComposer get customerGroupId {
    final $$CustomerGroupsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerGroupId,
      referencedTable: $db.customerGroups,
      getReferencedColumn: (t) => t.customerGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomerGroupsTableOrderingComposer(
            $db: $db,
            $table: $db.customerGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CustomersTableAnnotationComposer
    extends Composer<_$AppDatabase, $CustomersTable> {
  $$CustomersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get customerId => $composableBuilder(
    column: $table.customerId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get customerCode => $composableBuilder(
    column: $table.customerCode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get customerName => $composableBuilder(
    column: $table.customerName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get taxId =>
      $composableBuilder(column: $table.taxId, builder: (column) => column);

  GeneratedColumn<double> get creditLimit => $composableBuilder(
    column: $table.creditLimit,
    builder: (column) => column,
  );

  GeneratedColumn<int> get creditDays => $composableBuilder(
    column: $table.creditDays,
    builder: (column) => column,
  );

  GeneratedColumn<double> get currentBalance => $composableBuilder(
    column: $table.currentBalance,
    builder: (column) => column,
  );

  GeneratedColumn<String> get memberNo =>
      $composableBuilder(column: $table.memberNo, builder: (column) => column);

  GeneratedColumn<int> get points =>
      $composableBuilder(column: $table.points, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$CustomerGroupsTableAnnotationComposer get customerGroupId {
    final $$CustomerGroupsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerGroupId,
      referencedTable: $db.customerGroups,
      getReferencedColumn: (t) => t.customerGroupId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomerGroupsTableAnnotationComposer(
            $db: $db,
            $table: $db.customerGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> salesOrdersRefs<T extends Object>(
    Expression<T> Function($$SalesOrdersTableAnnotationComposer a) f,
  ) {
    final $$SalesOrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> promotionUsagesRefs<T extends Object>(
    Expression<T> Function($$PromotionUsagesTableAnnotationComposer a) f,
  ) {
    final $$PromotionUsagesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.promotionUsages,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionUsagesTableAnnotationComposer(
            $db: $db,
            $table: $db.promotionUsages,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> couponsRefs<T extends Object>(
    Expression<T> Function($$CouponsTableAnnotationComposer a) f,
  ) {
    final $$CouponsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.coupons,
      getReferencedColumn: (t) => t.usedBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CouponsTableAnnotationComposer(
            $db: $db,
            $table: $db.coupons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> arInvoicesRefs<T extends Object>(
    Expression<T> Function($$ArInvoicesTableAnnotationComposer a) f,
  ) {
    final $$ArInvoicesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.arInvoices,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArInvoicesTableAnnotationComposer(
            $db: $db,
            $table: $db.arInvoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> arReceiptsRefs<T extends Object>(
    Expression<T> Function($$ArReceiptsTableAnnotationComposer a) f,
  ) {
    final $$ArReceiptsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.arReceipts,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArReceiptsTableAnnotationComposer(
            $db: $db,
            $table: $db.arReceipts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CustomersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CustomersTable,
          Customer,
          $$CustomersTableFilterComposer,
          $$CustomersTableOrderingComposer,
          $$CustomersTableAnnotationComposer,
          $$CustomersTableCreateCompanionBuilder,
          $$CustomersTableUpdateCompanionBuilder,
          (Customer, $$CustomersTableReferences),
          Customer,
          PrefetchHooks Function({
            bool customerGroupId,
            bool salesOrdersRefs,
            bool promotionUsagesRefs,
            bool couponsRefs,
            bool arInvoicesRefs,
            bool arReceiptsRefs,
          })
        > {
  $$CustomersTableTableManager(_$AppDatabase db, $CustomersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CustomersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CustomersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CustomersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> customerId = const Value.absent(),
                Value<String> customerCode = const Value.absent(),
                Value<String> customerName = const Value.absent(),
                Value<String?> customerGroupId = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> taxId = const Value.absent(),
                Value<double> creditLimit = const Value.absent(),
                Value<int> creditDays = const Value.absent(),
                Value<double> currentBalance = const Value.absent(),
                Value<String?> memberNo = const Value.absent(),
                Value<int> points = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CustomersCompanion(
                customerId: customerId,
                customerCode: customerCode,
                customerName: customerName,
                customerGroupId: customerGroupId,
                address: address,
                phone: phone,
                email: email,
                taxId: taxId,
                creditLimit: creditLimit,
                creditDays: creditDays,
                currentBalance: currentBalance,
                memberNo: memberNo,
                points: points,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String customerId,
                required String customerCode,
                required String customerName,
                Value<String?> customerGroupId = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> taxId = const Value.absent(),
                Value<double> creditLimit = const Value.absent(),
                Value<int> creditDays = const Value.absent(),
                Value<double> currentBalance = const Value.absent(),
                Value<String?> memberNo = const Value.absent(),
                Value<int> points = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CustomersCompanion.insert(
                customerId: customerId,
                customerCode: customerCode,
                customerName: customerName,
                customerGroupId: customerGroupId,
                address: address,
                phone: phone,
                email: email,
                taxId: taxId,
                creditLimit: creditLimit,
                creditDays: creditDays,
                currentBalance: currentBalance,
                memberNo: memberNo,
                points: points,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CustomersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                customerGroupId = false,
                salesOrdersRefs = false,
                promotionUsagesRefs = false,
                couponsRefs = false,
                arInvoicesRefs = false,
                arReceiptsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (salesOrdersRefs) db.salesOrders,
                    if (promotionUsagesRefs) db.promotionUsages,
                    if (couponsRefs) db.coupons,
                    if (arInvoicesRefs) db.arInvoices,
                    if (arReceiptsRefs) db.arReceipts,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (customerGroupId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.customerGroupId,
                                    referencedTable: $$CustomersTableReferences
                                        ._customerGroupIdTable(db),
                                    referencedColumn: $$CustomersTableReferences
                                        ._customerGroupIdTable(db)
                                        .customerGroupId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (salesOrdersRefs)
                        await $_getPrefetchedData<
                          Customer,
                          $CustomersTable,
                          SalesOrder
                        >(
                          currentTable: table,
                          referencedTable: $$CustomersTableReferences
                              ._salesOrdersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CustomersTableReferences(
                                db,
                                table,
                                p0,
                              ).salesOrdersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.customerId == item.customerId,
                              ),
                          typedResults: items,
                        ),
                      if (promotionUsagesRefs)
                        await $_getPrefetchedData<
                          Customer,
                          $CustomersTable,
                          PromotionUsage
                        >(
                          currentTable: table,
                          referencedTable: $$CustomersTableReferences
                              ._promotionUsagesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CustomersTableReferences(
                                db,
                                table,
                                p0,
                              ).promotionUsagesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.customerId == item.customerId,
                              ),
                          typedResults: items,
                        ),
                      if (couponsRefs)
                        await $_getPrefetchedData<
                          Customer,
                          $CustomersTable,
                          Coupon
                        >(
                          currentTable: table,
                          referencedTable: $$CustomersTableReferences
                              ._couponsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CustomersTableReferences(
                                db,
                                table,
                                p0,
                              ).couponsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.usedBy == item.customerId,
                              ),
                          typedResults: items,
                        ),
                      if (arInvoicesRefs)
                        await $_getPrefetchedData<
                          Customer,
                          $CustomersTable,
                          ArInvoice
                        >(
                          currentTable: table,
                          referencedTable: $$CustomersTableReferences
                              ._arInvoicesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CustomersTableReferences(
                                db,
                                table,
                                p0,
                              ).arInvoicesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.customerId == item.customerId,
                              ),
                          typedResults: items,
                        ),
                      if (arReceiptsRefs)
                        await $_getPrefetchedData<
                          Customer,
                          $CustomersTable,
                          ArReceipt
                        >(
                          currentTable: table,
                          referencedTable: $$CustomersTableReferences
                              ._arReceiptsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CustomersTableReferences(
                                db,
                                table,
                                p0,
                              ).arReceiptsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.customerId == item.customerId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$CustomersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CustomersTable,
      Customer,
      $$CustomersTableFilterComposer,
      $$CustomersTableOrderingComposer,
      $$CustomersTableAnnotationComposer,
      $$CustomersTableCreateCompanionBuilder,
      $$CustomersTableUpdateCompanionBuilder,
      (Customer, $$CustomersTableReferences),
      Customer,
      PrefetchHooks Function({
        bool customerGroupId,
        bool salesOrdersRefs,
        bool promotionUsagesRefs,
        bool couponsRefs,
        bool arInvoicesRefs,
        bool arReceiptsRefs,
      })
    >;
typedef $$SuppliersTableCreateCompanionBuilder =
    SuppliersCompanion Function({
      required String supplierId,
      required String supplierCode,
      required String supplierName,
      Value<String?> address,
      Value<String?> phone,
      Value<String?> email,
      Value<String?> taxId,
      Value<int> creditDays,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$SuppliersTableUpdateCompanionBuilder =
    SuppliersCompanion Function({
      Value<String> supplierId,
      Value<String> supplierCode,
      Value<String> supplierName,
      Value<String?> address,
      Value<String?> phone,
      Value<String?> email,
      Value<String?> taxId,
      Value<int> creditDays,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$SuppliersTableReferences
    extends BaseReferences<_$AppDatabase, $SuppliersTable, Supplier> {
  $$SuppliersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$PurchaseOrdersTable, List<PurchaseOrder>>
  _purchaseOrdersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.purchaseOrders,
    aliasName: $_aliasNameGenerator(
      db.suppliers.supplierId,
      db.purchaseOrders.supplierId,
    ),
  );

  $$PurchaseOrdersTableProcessedTableManager get purchaseOrdersRefs {
    final manager = $$PurchaseOrdersTableTableManager($_db, $_db.purchaseOrders)
        .filter(
          (f) => f.supplierId.supplierId.sqlEquals(
            $_itemColumn<String>('supplier_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(_purchaseOrdersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ApInvoicesTable, List<ApInvoice>>
  _apInvoicesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.apInvoices,
    aliasName: $_aliasNameGenerator(
      db.suppliers.supplierId,
      db.apInvoices.supplierId,
    ),
  );

  $$ApInvoicesTableProcessedTableManager get apInvoicesRefs {
    final manager = $$ApInvoicesTableTableManager($_db, $_db.apInvoices).filter(
      (f) => f.supplierId.supplierId.sqlEquals(
        $_itemColumn<String>('supplier_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_apInvoicesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ApPaymentsTable, List<ApPayment>>
  _apPaymentsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.apPayments,
    aliasName: $_aliasNameGenerator(
      db.suppliers.supplierId,
      db.apPayments.supplierId,
    ),
  );

  $$ApPaymentsTableProcessedTableManager get apPaymentsRefs {
    final manager = $$ApPaymentsTableTableManager($_db, $_db.apPayments).filter(
      (f) => f.supplierId.supplierId.sqlEquals(
        $_itemColumn<String>('supplier_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_apPaymentsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$SuppliersTableFilterComposer
    extends Composer<_$AppDatabase, $SuppliersTable> {
  $$SuppliersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get supplierId => $composableBuilder(
    column: $table.supplierId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get supplierCode => $composableBuilder(
    column: $table.supplierCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get supplierName => $composableBuilder(
    column: $table.supplierName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get taxId => $composableBuilder(
    column: $table.taxId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get creditDays => $composableBuilder(
    column: $table.creditDays,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> purchaseOrdersRefs(
    Expression<bool> Function($$PurchaseOrdersTableFilterComposer f) f,
  ) {
    final $$PurchaseOrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.purchaseOrders,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrdersTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> apInvoicesRefs(
    Expression<bool> Function($$ApInvoicesTableFilterComposer f) f,
  ) {
    final $$ApInvoicesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.apInvoices,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApInvoicesTableFilterComposer(
            $db: $db,
            $table: $db.apInvoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> apPaymentsRefs(
    Expression<bool> Function($$ApPaymentsTableFilterComposer f) f,
  ) {
    final $$ApPaymentsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.apPayments,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApPaymentsTableFilterComposer(
            $db: $db,
            $table: $db.apPayments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SuppliersTableOrderingComposer
    extends Composer<_$AppDatabase, $SuppliersTable> {
  $$SuppliersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get supplierId => $composableBuilder(
    column: $table.supplierId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get supplierCode => $composableBuilder(
    column: $table.supplierCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get supplierName => $composableBuilder(
    column: $table.supplierName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get taxId => $composableBuilder(
    column: $table.taxId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get creditDays => $composableBuilder(
    column: $table.creditDays,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SuppliersTableAnnotationComposer
    extends Composer<_$AppDatabase, $SuppliersTable> {
  $$SuppliersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get supplierId => $composableBuilder(
    column: $table.supplierId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get supplierCode => $composableBuilder(
    column: $table.supplierCode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get supplierName => $composableBuilder(
    column: $table.supplierName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get taxId =>
      $composableBuilder(column: $table.taxId, builder: (column) => column);

  GeneratedColumn<int> get creditDays => $composableBuilder(
    column: $table.creditDays,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> purchaseOrdersRefs<T extends Object>(
    Expression<T> Function($$PurchaseOrdersTableAnnotationComposer a) f,
  ) {
    final $$PurchaseOrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.purchaseOrders,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.purchaseOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> apInvoicesRefs<T extends Object>(
    Expression<T> Function($$ApInvoicesTableAnnotationComposer a) f,
  ) {
    final $$ApInvoicesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.apInvoices,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApInvoicesTableAnnotationComposer(
            $db: $db,
            $table: $db.apInvoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> apPaymentsRefs<T extends Object>(
    Expression<T> Function($$ApPaymentsTableAnnotationComposer a) f,
  ) {
    final $$ApPaymentsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.apPayments,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApPaymentsTableAnnotationComposer(
            $db: $db,
            $table: $db.apPayments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SuppliersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SuppliersTable,
          Supplier,
          $$SuppliersTableFilterComposer,
          $$SuppliersTableOrderingComposer,
          $$SuppliersTableAnnotationComposer,
          $$SuppliersTableCreateCompanionBuilder,
          $$SuppliersTableUpdateCompanionBuilder,
          (Supplier, $$SuppliersTableReferences),
          Supplier,
          PrefetchHooks Function({
            bool purchaseOrdersRefs,
            bool apInvoicesRefs,
            bool apPaymentsRefs,
          })
        > {
  $$SuppliersTableTableManager(_$AppDatabase db, $SuppliersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SuppliersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SuppliersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SuppliersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> supplierId = const Value.absent(),
                Value<String> supplierCode = const Value.absent(),
                Value<String> supplierName = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> taxId = const Value.absent(),
                Value<int> creditDays = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SuppliersCompanion(
                supplierId: supplierId,
                supplierCode: supplierCode,
                supplierName: supplierName,
                address: address,
                phone: phone,
                email: email,
                taxId: taxId,
                creditDays: creditDays,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String supplierId,
                required String supplierCode,
                required String supplierName,
                Value<String?> address = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> taxId = const Value.absent(),
                Value<int> creditDays = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SuppliersCompanion.insert(
                supplierId: supplierId,
                supplierCode: supplierCode,
                supplierName: supplierName,
                address: address,
                phone: phone,
                email: email,
                taxId: taxId,
                creditDays: creditDays,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SuppliersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                purchaseOrdersRefs = false,
                apInvoicesRefs = false,
                apPaymentsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (purchaseOrdersRefs) db.purchaseOrders,
                    if (apInvoicesRefs) db.apInvoices,
                    if (apPaymentsRefs) db.apPayments,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (purchaseOrdersRefs)
                        await $_getPrefetchedData<
                          Supplier,
                          $SuppliersTable,
                          PurchaseOrder
                        >(
                          currentTable: table,
                          referencedTable: $$SuppliersTableReferences
                              ._purchaseOrdersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SuppliersTableReferences(
                                db,
                                table,
                                p0,
                              ).purchaseOrdersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.supplierId == item.supplierId,
                              ),
                          typedResults: items,
                        ),
                      if (apInvoicesRefs)
                        await $_getPrefetchedData<
                          Supplier,
                          $SuppliersTable,
                          ApInvoice
                        >(
                          currentTable: table,
                          referencedTable: $$SuppliersTableReferences
                              ._apInvoicesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SuppliersTableReferences(
                                db,
                                table,
                                p0,
                              ).apInvoicesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.supplierId == item.supplierId,
                              ),
                          typedResults: items,
                        ),
                      if (apPaymentsRefs)
                        await $_getPrefetchedData<
                          Supplier,
                          $SuppliersTable,
                          ApPayment
                        >(
                          currentTable: table,
                          referencedTable: $$SuppliersTableReferences
                              ._apPaymentsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SuppliersTableReferences(
                                db,
                                table,
                                p0,
                              ).apPaymentsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.supplierId == item.supplierId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$SuppliersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SuppliersTable,
      Supplier,
      $$SuppliersTableFilterComposer,
      $$SuppliersTableOrderingComposer,
      $$SuppliersTableAnnotationComposer,
      $$SuppliersTableCreateCompanionBuilder,
      $$SuppliersTableUpdateCompanionBuilder,
      (Supplier, $$SuppliersTableReferences),
      Supplier,
      PrefetchHooks Function({
        bool purchaseOrdersRefs,
        bool apInvoicesRefs,
        bool apPaymentsRefs,
      })
    >;
typedef $$SalesOrdersTableCreateCompanionBuilder =
    SalesOrdersCompanion Function({
      required String orderId,
      required String orderNo,
      required DateTime orderDate,
      Value<String> orderType,
      Value<String?> customerId,
      Value<String?> customerName,
      Value<String?> customerAddress,
      Value<String?> customerTaxId,
      required String branchId,
      required String warehouseId,
      required String userId,
      Value<String?> tableId,
      Value<int?> partySize,
      Value<double> subtotal,
      Value<double> discountAmount,
      Value<double> amountBeforeVat,
      Value<double> vatAmount,
      Value<double> totalAmount,
      Value<String> paymentType,
      Value<double> paidAmount,
      Value<double> changeAmount,
      Value<String> status,
      Value<bool> isVatInclude,
      Value<String?> remark,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$SalesOrdersTableUpdateCompanionBuilder =
    SalesOrdersCompanion Function({
      Value<String> orderId,
      Value<String> orderNo,
      Value<DateTime> orderDate,
      Value<String> orderType,
      Value<String?> customerId,
      Value<String?> customerName,
      Value<String?> customerAddress,
      Value<String?> customerTaxId,
      Value<String> branchId,
      Value<String> warehouseId,
      Value<String> userId,
      Value<String?> tableId,
      Value<int?> partySize,
      Value<double> subtotal,
      Value<double> discountAmount,
      Value<double> amountBeforeVat,
      Value<double> vatAmount,
      Value<double> totalAmount,
      Value<String> paymentType,
      Value<double> paidAmount,
      Value<double> changeAmount,
      Value<String> status,
      Value<bool> isVatInclude,
      Value<String?> remark,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$SalesOrdersTableReferences
    extends BaseReferences<_$AppDatabase, $SalesOrdersTable, SalesOrder> {
  $$SalesOrdersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $CustomersTable _customerIdTable(_$AppDatabase db) =>
      db.customers.createAlias(
        $_aliasNameGenerator(
          db.salesOrders.customerId,
          db.customers.customerId,
        ),
      );

  $$CustomersTableProcessedTableManager? get customerId {
    final $_column = $_itemColumn<String>('customer_id');
    if ($_column == null) return null;
    final manager = $$CustomersTableTableManager(
      $_db,
      $_db.customers,
    ).filter((f) => f.customerId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_customerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $BranchesTable _branchIdTable(_$AppDatabase db) =>
      db.branches.createAlias(
        $_aliasNameGenerator(db.salesOrders.branchId, db.branches.branchId),
      );

  $$BranchesTableProcessedTableManager get branchId {
    final $_column = $_itemColumn<String>('branch_id')!;

    final manager = $$BranchesTableTableManager(
      $_db,
      $_db.branches,
    ).filter((f) => f.branchId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_branchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $WarehousesTable _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias(
        $_aliasNameGenerator(
          db.salesOrders.warehouseId,
          db.warehouses.warehouseId,
        ),
      );

  $$WarehousesTableProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<String>('warehouse_id')!;

    final manager = $$WarehousesTableTableManager(
      $_db,
      $_db.warehouses,
    ).filter((f) => f.warehouseId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.salesOrders.userId, db.users.userId),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.userId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$SalesOrderItemsTable, List<SalesOrderItem>>
  _salesOrderItemsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.salesOrderItems,
    aliasName: $_aliasNameGenerator(
      db.salesOrders.orderId,
      db.salesOrderItems.orderId,
    ),
  );

  $$SalesOrderItemsTableProcessedTableManager get salesOrderItemsRefs {
    final manager =
        $$SalesOrderItemsTableTableManager($_db, $_db.salesOrderItems).filter(
          (f) => f.orderId.orderId.sqlEquals($_itemColumn<String>('order_id')!),
        );

    final cache = $_typedResult.readTableOrNull(
      _salesOrderItemsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PromotionUsagesTable, List<PromotionUsage>>
  _promotionUsagesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.promotionUsages,
    aliasName: $_aliasNameGenerator(
      db.salesOrders.orderId,
      db.promotionUsages.orderId,
    ),
  );

  $$PromotionUsagesTableProcessedTableManager get promotionUsagesRefs {
    final manager =
        $$PromotionUsagesTableTableManager($_db, $_db.promotionUsages).filter(
          (f) => f.orderId.orderId.sqlEquals($_itemColumn<String>('order_id')!),
        );

    final cache = $_typedResult.readTableOrNull(
      _promotionUsagesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$SalesOrdersTableFilterComposer
    extends Composer<_$AppDatabase, $SalesOrdersTable> {
  $$SalesOrdersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get orderId => $composableBuilder(
    column: $table.orderId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get orderNo => $composableBuilder(
    column: $table.orderNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get orderDate => $composableBuilder(
    column: $table.orderDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get orderType => $composableBuilder(
    column: $table.orderType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get customerName => $composableBuilder(
    column: $table.customerName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get customerAddress => $composableBuilder(
    column: $table.customerAddress,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get customerTaxId => $composableBuilder(
    column: $table.customerTaxId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tableId => $composableBuilder(
    column: $table.tableId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get partySize => $composableBuilder(
    column: $table.partySize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get subtotal => $composableBuilder(
    column: $table.subtotal,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get amountBeforeVat => $composableBuilder(
    column: $table.amountBeforeVat,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get vatAmount => $composableBuilder(
    column: $table.vatAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get paymentType => $composableBuilder(
    column: $table.paymentType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get paidAmount => $composableBuilder(
    column: $table.paidAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get changeAmount => $composableBuilder(
    column: $table.changeAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isVatInclude => $composableBuilder(
    column: $table.isVatInclude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get remark => $composableBuilder(
    column: $table.remark,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CustomersTableFilterComposer get customerId {
    final $$CustomersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableFilterComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableFilterComposer get branchId {
    final $$BranchesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableFilterComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableFilterComposer get warehouseId {
    final $$WarehousesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableFilterComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> salesOrderItemsRefs(
    Expression<bool> Function($$SalesOrderItemsTableFilterComposer f) f,
  ) {
    final $$SalesOrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.salesOrderItems,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.salesOrderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> promotionUsagesRefs(
    Expression<bool> Function($$PromotionUsagesTableFilterComposer f) f,
  ) {
    final $$PromotionUsagesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.promotionUsages,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionUsagesTableFilterComposer(
            $db: $db,
            $table: $db.promotionUsages,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SalesOrdersTableOrderingComposer
    extends Composer<_$AppDatabase, $SalesOrdersTable> {
  $$SalesOrdersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get orderId => $composableBuilder(
    column: $table.orderId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get orderNo => $composableBuilder(
    column: $table.orderNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get orderDate => $composableBuilder(
    column: $table.orderDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get orderType => $composableBuilder(
    column: $table.orderType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get customerName => $composableBuilder(
    column: $table.customerName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get customerAddress => $composableBuilder(
    column: $table.customerAddress,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get customerTaxId => $composableBuilder(
    column: $table.customerTaxId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tableId => $composableBuilder(
    column: $table.tableId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get partySize => $composableBuilder(
    column: $table.partySize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get subtotal => $composableBuilder(
    column: $table.subtotal,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get amountBeforeVat => $composableBuilder(
    column: $table.amountBeforeVat,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get vatAmount => $composableBuilder(
    column: $table.vatAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get paymentType => $composableBuilder(
    column: $table.paymentType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get paidAmount => $composableBuilder(
    column: $table.paidAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get changeAmount => $composableBuilder(
    column: $table.changeAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isVatInclude => $composableBuilder(
    column: $table.isVatInclude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get remark => $composableBuilder(
    column: $table.remark,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CustomersTableOrderingComposer get customerId {
    final $$CustomersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableOrderingComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableOrderingComposer get branchId {
    final $$BranchesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableOrderingComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableOrderingComposer get warehouseId {
    final $$WarehousesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableOrderingComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SalesOrdersTableAnnotationComposer
    extends Composer<_$AppDatabase, $SalesOrdersTable> {
  $$SalesOrdersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get orderId =>
      $composableBuilder(column: $table.orderId, builder: (column) => column);

  GeneratedColumn<String> get orderNo =>
      $composableBuilder(column: $table.orderNo, builder: (column) => column);

  GeneratedColumn<DateTime> get orderDate =>
      $composableBuilder(column: $table.orderDate, builder: (column) => column);

  GeneratedColumn<String> get orderType =>
      $composableBuilder(column: $table.orderType, builder: (column) => column);

  GeneratedColumn<String> get customerName => $composableBuilder(
    column: $table.customerName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get customerAddress => $composableBuilder(
    column: $table.customerAddress,
    builder: (column) => column,
  );

  GeneratedColumn<String> get customerTaxId => $composableBuilder(
    column: $table.customerTaxId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get tableId =>
      $composableBuilder(column: $table.tableId, builder: (column) => column);

  GeneratedColumn<int> get partySize =>
      $composableBuilder(column: $table.partySize, builder: (column) => column);

  GeneratedColumn<double> get subtotal =>
      $composableBuilder(column: $table.subtotal, builder: (column) => column);

  GeneratedColumn<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => column,
  );

  GeneratedColumn<double> get amountBeforeVat => $composableBuilder(
    column: $table.amountBeforeVat,
    builder: (column) => column,
  );

  GeneratedColumn<double> get vatAmount =>
      $composableBuilder(column: $table.vatAmount, builder: (column) => column);

  GeneratedColumn<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get paymentType => $composableBuilder(
    column: $table.paymentType,
    builder: (column) => column,
  );

  GeneratedColumn<double> get paidAmount => $composableBuilder(
    column: $table.paidAmount,
    builder: (column) => column,
  );

  GeneratedColumn<double> get changeAmount => $composableBuilder(
    column: $table.changeAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<bool> get isVatInclude => $composableBuilder(
    column: $table.isVatInclude,
    builder: (column) => column,
  );

  GeneratedColumn<String> get remark =>
      $composableBuilder(column: $table.remark, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$CustomersTableAnnotationComposer get customerId {
    final $$CustomersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableAnnotationComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableAnnotationComposer get branchId {
    final $$BranchesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableAnnotationComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableAnnotationComposer get warehouseId {
    final $$WarehousesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableAnnotationComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> salesOrderItemsRefs<T extends Object>(
    Expression<T> Function($$SalesOrderItemsTableAnnotationComposer a) f,
  ) {
    final $$SalesOrderItemsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.salesOrderItems,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrderItemsTableAnnotationComposer(
            $db: $db,
            $table: $db.salesOrderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> promotionUsagesRefs<T extends Object>(
    Expression<T> Function($$PromotionUsagesTableAnnotationComposer a) f,
  ) {
    final $$PromotionUsagesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.promotionUsages,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionUsagesTableAnnotationComposer(
            $db: $db,
            $table: $db.promotionUsages,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SalesOrdersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SalesOrdersTable,
          SalesOrder,
          $$SalesOrdersTableFilterComposer,
          $$SalesOrdersTableOrderingComposer,
          $$SalesOrdersTableAnnotationComposer,
          $$SalesOrdersTableCreateCompanionBuilder,
          $$SalesOrdersTableUpdateCompanionBuilder,
          (SalesOrder, $$SalesOrdersTableReferences),
          SalesOrder,
          PrefetchHooks Function({
            bool customerId,
            bool branchId,
            bool warehouseId,
            bool userId,
            bool salesOrderItemsRefs,
            bool promotionUsagesRefs,
          })
        > {
  $$SalesOrdersTableTableManager(_$AppDatabase db, $SalesOrdersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SalesOrdersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SalesOrdersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SalesOrdersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> orderId = const Value.absent(),
                Value<String> orderNo = const Value.absent(),
                Value<DateTime> orderDate = const Value.absent(),
                Value<String> orderType = const Value.absent(),
                Value<String?> customerId = const Value.absent(),
                Value<String?> customerName = const Value.absent(),
                Value<String?> customerAddress = const Value.absent(),
                Value<String?> customerTaxId = const Value.absent(),
                Value<String> branchId = const Value.absent(),
                Value<String> warehouseId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> tableId = const Value.absent(),
                Value<int?> partySize = const Value.absent(),
                Value<double> subtotal = const Value.absent(),
                Value<double> discountAmount = const Value.absent(),
                Value<double> amountBeforeVat = const Value.absent(),
                Value<double> vatAmount = const Value.absent(),
                Value<double> totalAmount = const Value.absent(),
                Value<String> paymentType = const Value.absent(),
                Value<double> paidAmount = const Value.absent(),
                Value<double> changeAmount = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<bool> isVatInclude = const Value.absent(),
                Value<String?> remark = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SalesOrdersCompanion(
                orderId: orderId,
                orderNo: orderNo,
                orderDate: orderDate,
                orderType: orderType,
                customerId: customerId,
                customerName: customerName,
                customerAddress: customerAddress,
                customerTaxId: customerTaxId,
                branchId: branchId,
                warehouseId: warehouseId,
                userId: userId,
                tableId: tableId,
                partySize: partySize,
                subtotal: subtotal,
                discountAmount: discountAmount,
                amountBeforeVat: amountBeforeVat,
                vatAmount: vatAmount,
                totalAmount: totalAmount,
                paymentType: paymentType,
                paidAmount: paidAmount,
                changeAmount: changeAmount,
                status: status,
                isVatInclude: isVatInclude,
                remark: remark,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String orderId,
                required String orderNo,
                required DateTime orderDate,
                Value<String> orderType = const Value.absent(),
                Value<String?> customerId = const Value.absent(),
                Value<String?> customerName = const Value.absent(),
                Value<String?> customerAddress = const Value.absent(),
                Value<String?> customerTaxId = const Value.absent(),
                required String branchId,
                required String warehouseId,
                required String userId,
                Value<String?> tableId = const Value.absent(),
                Value<int?> partySize = const Value.absent(),
                Value<double> subtotal = const Value.absent(),
                Value<double> discountAmount = const Value.absent(),
                Value<double> amountBeforeVat = const Value.absent(),
                Value<double> vatAmount = const Value.absent(),
                Value<double> totalAmount = const Value.absent(),
                Value<String> paymentType = const Value.absent(),
                Value<double> paidAmount = const Value.absent(),
                Value<double> changeAmount = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<bool> isVatInclude = const Value.absent(),
                Value<String?> remark = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SalesOrdersCompanion.insert(
                orderId: orderId,
                orderNo: orderNo,
                orderDate: orderDate,
                orderType: orderType,
                customerId: customerId,
                customerName: customerName,
                customerAddress: customerAddress,
                customerTaxId: customerTaxId,
                branchId: branchId,
                warehouseId: warehouseId,
                userId: userId,
                tableId: tableId,
                partySize: partySize,
                subtotal: subtotal,
                discountAmount: discountAmount,
                amountBeforeVat: amountBeforeVat,
                vatAmount: vatAmount,
                totalAmount: totalAmount,
                paymentType: paymentType,
                paidAmount: paidAmount,
                changeAmount: changeAmount,
                status: status,
                isVatInclude: isVatInclude,
                remark: remark,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SalesOrdersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                customerId = false,
                branchId = false,
                warehouseId = false,
                userId = false,
                salesOrderItemsRefs = false,
                promotionUsagesRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (salesOrderItemsRefs) db.salesOrderItems,
                    if (promotionUsagesRefs) db.promotionUsages,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (customerId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.customerId,
                                    referencedTable:
                                        $$SalesOrdersTableReferences
                                            ._customerIdTable(db),
                                    referencedColumn:
                                        $$SalesOrdersTableReferences
                                            ._customerIdTable(db)
                                            .customerId,
                                  )
                                  as T;
                        }
                        if (branchId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.branchId,
                                    referencedTable:
                                        $$SalesOrdersTableReferences
                                            ._branchIdTable(db),
                                    referencedColumn:
                                        $$SalesOrdersTableReferences
                                            ._branchIdTable(db)
                                            .branchId,
                                  )
                                  as T;
                        }
                        if (warehouseId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.warehouseId,
                                    referencedTable:
                                        $$SalesOrdersTableReferences
                                            ._warehouseIdTable(db),
                                    referencedColumn:
                                        $$SalesOrdersTableReferences
                                            ._warehouseIdTable(db)
                                            .warehouseId,
                                  )
                                  as T;
                        }
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable:
                                        $$SalesOrdersTableReferences
                                            ._userIdTable(db),
                                    referencedColumn:
                                        $$SalesOrdersTableReferences
                                            ._userIdTable(db)
                                            .userId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (salesOrderItemsRefs)
                        await $_getPrefetchedData<
                          SalesOrder,
                          $SalesOrdersTable,
                          SalesOrderItem
                        >(
                          currentTable: table,
                          referencedTable: $$SalesOrdersTableReferences
                              ._salesOrderItemsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SalesOrdersTableReferences(
                                db,
                                table,
                                p0,
                              ).salesOrderItemsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.orderId == item.orderId,
                              ),
                          typedResults: items,
                        ),
                      if (promotionUsagesRefs)
                        await $_getPrefetchedData<
                          SalesOrder,
                          $SalesOrdersTable,
                          PromotionUsage
                        >(
                          currentTable: table,
                          referencedTable: $$SalesOrdersTableReferences
                              ._promotionUsagesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SalesOrdersTableReferences(
                                db,
                                table,
                                p0,
                              ).promotionUsagesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.orderId == item.orderId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$SalesOrdersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SalesOrdersTable,
      SalesOrder,
      $$SalesOrdersTableFilterComposer,
      $$SalesOrdersTableOrderingComposer,
      $$SalesOrdersTableAnnotationComposer,
      $$SalesOrdersTableCreateCompanionBuilder,
      $$SalesOrdersTableUpdateCompanionBuilder,
      (SalesOrder, $$SalesOrdersTableReferences),
      SalesOrder,
      PrefetchHooks Function({
        bool customerId,
        bool branchId,
        bool warehouseId,
        bool userId,
        bool salesOrderItemsRefs,
        bool promotionUsagesRefs,
      })
    >;
typedef $$SalesOrderItemsTableCreateCompanionBuilder =
    SalesOrderItemsCompanion Function({
      required String itemId,
      required String orderId,
      required int lineNo,
      required String productId,
      required String productCode,
      required String productName,
      required String unit,
      required double quantity,
      required double unitPrice,
      Value<double> discountPercent,
      Value<double> discountAmount,
      required double amount,
      Value<double> cost,
      required String warehouseId,
      Value<String?> serialNo,
      Value<String> kitchenStatus,
      Value<DateTime?> preparedAt,
      Value<String?> specialInstructions,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$SalesOrderItemsTableUpdateCompanionBuilder =
    SalesOrderItemsCompanion Function({
      Value<String> itemId,
      Value<String> orderId,
      Value<int> lineNo,
      Value<String> productId,
      Value<String> productCode,
      Value<String> productName,
      Value<String> unit,
      Value<double> quantity,
      Value<double> unitPrice,
      Value<double> discountPercent,
      Value<double> discountAmount,
      Value<double> amount,
      Value<double> cost,
      Value<String> warehouseId,
      Value<String?> serialNo,
      Value<String> kitchenStatus,
      Value<DateTime?> preparedAt,
      Value<String?> specialInstructions,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$SalesOrderItemsTableReferences
    extends
        BaseReferences<_$AppDatabase, $SalesOrderItemsTable, SalesOrderItem> {
  $$SalesOrderItemsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $SalesOrdersTable _orderIdTable(_$AppDatabase db) =>
      db.salesOrders.createAlias(
        $_aliasNameGenerator(
          db.salesOrderItems.orderId,
          db.salesOrders.orderId,
        ),
      );

  $$SalesOrdersTableProcessedTableManager get orderId {
    final $_column = $_itemColumn<String>('order_id')!;

    final manager = $$SalesOrdersTableTableManager(
      $_db,
      $_db.salesOrders,
    ).filter((f) => f.orderId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductsTable _productIdTable(_$AppDatabase db) =>
      db.products.createAlias(
        $_aliasNameGenerator(
          db.salesOrderItems.productId,
          db.products.productId,
        ),
      );

  $$ProductsTableProcessedTableManager get productId {
    final $_column = $_itemColumn<String>('product_id')!;

    final manager = $$ProductsTableTableManager(
      $_db,
      $_db.products,
    ).filter((f) => f.productId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $WarehousesTable _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias(
        $_aliasNameGenerator(
          db.salesOrderItems.warehouseId,
          db.warehouses.warehouseId,
        ),
      );

  $$WarehousesTableProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<String>('warehouse_id')!;

    final manager = $$WarehousesTableTableManager(
      $_db,
      $_db.warehouses,
    ).filter((f) => f.warehouseId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$OrderItemModifiersTable, List<OrderItemModifier>>
  _orderItemModifiersRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.orderItemModifiers,
        aliasName: $_aliasNameGenerator(
          db.salesOrderItems.itemId,
          db.orderItemModifiers.orderItemId,
        ),
      );

  $$OrderItemModifiersTableProcessedTableManager get orderItemModifiersRefs {
    final manager =
        $$OrderItemModifiersTableTableManager(
          $_db,
          $_db.orderItemModifiers,
        ).filter(
          (f) =>
              f.orderItemId.itemId.sqlEquals($_itemColumn<String>('item_id')!),
        );

    final cache = $_typedResult.readTableOrNull(
      _orderItemModifiersRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$SalesOrderItemsTableFilterComposer
    extends Composer<_$AppDatabase, $SalesOrderItemsTable> {
  $$SalesOrderItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get itemId => $composableBuilder(
    column: $table.itemId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lineNo => $composableBuilder(
    column: $table.lineNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get productCode => $composableBuilder(
    column: $table.productCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get unitPrice => $composableBuilder(
    column: $table.unitPrice,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get discountPercent => $composableBuilder(
    column: $table.discountPercent,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get cost => $composableBuilder(
    column: $table.cost,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get serialNo => $composableBuilder(
    column: $table.serialNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get kitchenStatus => $composableBuilder(
    column: $table.kitchenStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get preparedAt => $composableBuilder(
    column: $table.preparedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get specialInstructions => $composableBuilder(
    column: $table.specialInstructions,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$SalesOrdersTableFilterComposer get orderId {
    final $$SalesOrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableFilterComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableFilterComposer get productId {
    final $$ProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableFilterComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableFilterComposer get warehouseId {
    final $$WarehousesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableFilterComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> orderItemModifiersRefs(
    Expression<bool> Function($$OrderItemModifiersTableFilterComposer f) f,
  ) {
    final $$OrderItemModifiersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.itemId,
      referencedTable: $db.orderItemModifiers,
      getReferencedColumn: (t) => t.orderItemId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemModifiersTableFilterComposer(
            $db: $db,
            $table: $db.orderItemModifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SalesOrderItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $SalesOrderItemsTable> {
  $$SalesOrderItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get itemId => $composableBuilder(
    column: $table.itemId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lineNo => $composableBuilder(
    column: $table.lineNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get productCode => $composableBuilder(
    column: $table.productCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get unitPrice => $composableBuilder(
    column: $table.unitPrice,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get discountPercent => $composableBuilder(
    column: $table.discountPercent,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get cost => $composableBuilder(
    column: $table.cost,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get serialNo => $composableBuilder(
    column: $table.serialNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get kitchenStatus => $composableBuilder(
    column: $table.kitchenStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get preparedAt => $composableBuilder(
    column: $table.preparedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get specialInstructions => $composableBuilder(
    column: $table.specialInstructions,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$SalesOrdersTableOrderingComposer get orderId {
    final $$SalesOrdersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableOrderingComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableOrderingComposer get productId {
    final $$ProductsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableOrderingComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableOrderingComposer get warehouseId {
    final $$WarehousesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableOrderingComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SalesOrderItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SalesOrderItemsTable> {
  $$SalesOrderItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get itemId =>
      $composableBuilder(column: $table.itemId, builder: (column) => column);

  GeneratedColumn<int> get lineNo =>
      $composableBuilder(column: $table.lineNo, builder: (column) => column);

  GeneratedColumn<String> get productCode => $composableBuilder(
    column: $table.productCode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get unit =>
      $composableBuilder(column: $table.unit, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get unitPrice =>
      $composableBuilder(column: $table.unitPrice, builder: (column) => column);

  GeneratedColumn<double> get discountPercent => $composableBuilder(
    column: $table.discountPercent,
    builder: (column) => column,
  );

  GeneratedColumn<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => column,
  );

  GeneratedColumn<double> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<double> get cost =>
      $composableBuilder(column: $table.cost, builder: (column) => column);

  GeneratedColumn<String> get serialNo =>
      $composableBuilder(column: $table.serialNo, builder: (column) => column);

  GeneratedColumn<String> get kitchenStatus => $composableBuilder(
    column: $table.kitchenStatus,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get preparedAt => $composableBuilder(
    column: $table.preparedAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get specialInstructions => $composableBuilder(
    column: $table.specialInstructions,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$SalesOrdersTableAnnotationComposer get orderId {
    final $$SalesOrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableAnnotationComposer get productId {
    final $$ProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableAnnotationComposer get warehouseId {
    final $$WarehousesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableAnnotationComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> orderItemModifiersRefs<T extends Object>(
    Expression<T> Function($$OrderItemModifiersTableAnnotationComposer a) f,
  ) {
    final $$OrderItemModifiersTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.itemId,
          referencedTable: $db.orderItemModifiers,
          getReferencedColumn: (t) => t.orderItemId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$OrderItemModifiersTableAnnotationComposer(
                $db: $db,
                $table: $db.orderItemModifiers,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$SalesOrderItemsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SalesOrderItemsTable,
          SalesOrderItem,
          $$SalesOrderItemsTableFilterComposer,
          $$SalesOrderItemsTableOrderingComposer,
          $$SalesOrderItemsTableAnnotationComposer,
          $$SalesOrderItemsTableCreateCompanionBuilder,
          $$SalesOrderItemsTableUpdateCompanionBuilder,
          (SalesOrderItem, $$SalesOrderItemsTableReferences),
          SalesOrderItem,
          PrefetchHooks Function({
            bool orderId,
            bool productId,
            bool warehouseId,
            bool orderItemModifiersRefs,
          })
        > {
  $$SalesOrderItemsTableTableManager(
    _$AppDatabase db,
    $SalesOrderItemsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SalesOrderItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SalesOrderItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SalesOrderItemsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> itemId = const Value.absent(),
                Value<String> orderId = const Value.absent(),
                Value<int> lineNo = const Value.absent(),
                Value<String> productId = const Value.absent(),
                Value<String> productCode = const Value.absent(),
                Value<String> productName = const Value.absent(),
                Value<String> unit = const Value.absent(),
                Value<double> quantity = const Value.absent(),
                Value<double> unitPrice = const Value.absent(),
                Value<double> discountPercent = const Value.absent(),
                Value<double> discountAmount = const Value.absent(),
                Value<double> amount = const Value.absent(),
                Value<double> cost = const Value.absent(),
                Value<String> warehouseId = const Value.absent(),
                Value<String?> serialNo = const Value.absent(),
                Value<String> kitchenStatus = const Value.absent(),
                Value<DateTime?> preparedAt = const Value.absent(),
                Value<String?> specialInstructions = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SalesOrderItemsCompanion(
                itemId: itemId,
                orderId: orderId,
                lineNo: lineNo,
                productId: productId,
                productCode: productCode,
                productName: productName,
                unit: unit,
                quantity: quantity,
                unitPrice: unitPrice,
                discountPercent: discountPercent,
                discountAmount: discountAmount,
                amount: amount,
                cost: cost,
                warehouseId: warehouseId,
                serialNo: serialNo,
                kitchenStatus: kitchenStatus,
                preparedAt: preparedAt,
                specialInstructions: specialInstructions,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String itemId,
                required String orderId,
                required int lineNo,
                required String productId,
                required String productCode,
                required String productName,
                required String unit,
                required double quantity,
                required double unitPrice,
                Value<double> discountPercent = const Value.absent(),
                Value<double> discountAmount = const Value.absent(),
                required double amount,
                Value<double> cost = const Value.absent(),
                required String warehouseId,
                Value<String?> serialNo = const Value.absent(),
                Value<String> kitchenStatus = const Value.absent(),
                Value<DateTime?> preparedAt = const Value.absent(),
                Value<String?> specialInstructions = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SalesOrderItemsCompanion.insert(
                itemId: itemId,
                orderId: orderId,
                lineNo: lineNo,
                productId: productId,
                productCode: productCode,
                productName: productName,
                unit: unit,
                quantity: quantity,
                unitPrice: unitPrice,
                discountPercent: discountPercent,
                discountAmount: discountAmount,
                amount: amount,
                cost: cost,
                warehouseId: warehouseId,
                serialNo: serialNo,
                kitchenStatus: kitchenStatus,
                preparedAt: preparedAt,
                specialInstructions: specialInstructions,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SalesOrderItemsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                orderId = false,
                productId = false,
                warehouseId = false,
                orderItemModifiersRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (orderItemModifiersRefs) db.orderItemModifiers,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (orderId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.orderId,
                                    referencedTable:
                                        $$SalesOrderItemsTableReferences
                                            ._orderIdTable(db),
                                    referencedColumn:
                                        $$SalesOrderItemsTableReferences
                                            ._orderIdTable(db)
                                            .orderId,
                                  )
                                  as T;
                        }
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable:
                                        $$SalesOrderItemsTableReferences
                                            ._productIdTable(db),
                                    referencedColumn:
                                        $$SalesOrderItemsTableReferences
                                            ._productIdTable(db)
                                            .productId,
                                  )
                                  as T;
                        }
                        if (warehouseId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.warehouseId,
                                    referencedTable:
                                        $$SalesOrderItemsTableReferences
                                            ._warehouseIdTable(db),
                                    referencedColumn:
                                        $$SalesOrderItemsTableReferences
                                            ._warehouseIdTable(db)
                                            .warehouseId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (orderItemModifiersRefs)
                        await $_getPrefetchedData<
                          SalesOrderItem,
                          $SalesOrderItemsTable,
                          OrderItemModifier
                        >(
                          currentTable: table,
                          referencedTable: $$SalesOrderItemsTableReferences
                              ._orderItemModifiersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SalesOrderItemsTableReferences(
                                db,
                                table,
                                p0,
                              ).orderItemModifiersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.orderItemId == item.itemId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$SalesOrderItemsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SalesOrderItemsTable,
      SalesOrderItem,
      $$SalesOrderItemsTableFilterComposer,
      $$SalesOrderItemsTableOrderingComposer,
      $$SalesOrderItemsTableAnnotationComposer,
      $$SalesOrderItemsTableCreateCompanionBuilder,
      $$SalesOrderItemsTableUpdateCompanionBuilder,
      (SalesOrderItem, $$SalesOrderItemsTableReferences),
      SalesOrderItem,
      PrefetchHooks Function({
        bool orderId,
        bool productId,
        bool warehouseId,
        bool orderItemModifiersRefs,
      })
    >;
typedef $$OrderItemModifiersTableCreateCompanionBuilder =
    OrderItemModifiersCompanion Function({
      required String itemModifierId,
      required String orderItemId,
      required String modifierId,
      required String modifierName,
      Value<double> priceAdjustment,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$OrderItemModifiersTableUpdateCompanionBuilder =
    OrderItemModifiersCompanion Function({
      Value<String> itemModifierId,
      Value<String> orderItemId,
      Value<String> modifierId,
      Value<String> modifierName,
      Value<double> priceAdjustment,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$OrderItemModifiersTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $OrderItemModifiersTable,
          OrderItemModifier
        > {
  $$OrderItemModifiersTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $SalesOrderItemsTable _orderItemIdTable(_$AppDatabase db) =>
      db.salesOrderItems.createAlias(
        $_aliasNameGenerator(
          db.orderItemModifiers.orderItemId,
          db.salesOrderItems.itemId,
        ),
      );

  $$SalesOrderItemsTableProcessedTableManager get orderItemId {
    final $_column = $_itemColumn<String>('order_item_id')!;

    final manager = $$SalesOrderItemsTableTableManager(
      $_db,
      $_db.salesOrderItems,
    ).filter((f) => f.itemId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderItemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ModifiersTable _modifierIdTable(_$AppDatabase db) =>
      db.modifiers.createAlias(
        $_aliasNameGenerator(
          db.orderItemModifiers.modifierId,
          db.modifiers.modifierId,
        ),
      );

  $$ModifiersTableProcessedTableManager get modifierId {
    final $_column = $_itemColumn<String>('modifier_id')!;

    final manager = $$ModifiersTableTableManager(
      $_db,
      $_db.modifiers,
    ).filter((f) => f.modifierId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_modifierIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$OrderItemModifiersTableFilterComposer
    extends Composer<_$AppDatabase, $OrderItemModifiersTable> {
  $$OrderItemModifiersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get itemModifierId => $composableBuilder(
    column: $table.itemModifierId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get modifierName => $composableBuilder(
    column: $table.modifierName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get priceAdjustment => $composableBuilder(
    column: $table.priceAdjustment,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$SalesOrderItemsTableFilterComposer get orderItemId {
    final $$SalesOrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderItemId,
      referencedTable: $db.salesOrderItems,
      getReferencedColumn: (t) => t.itemId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.salesOrderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ModifiersTableFilterComposer get modifierId {
    final $$ModifiersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierId,
      referencedTable: $db.modifiers,
      getReferencedColumn: (t) => t.modifierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ModifiersTableFilterComposer(
            $db: $db,
            $table: $db.modifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemModifiersTableOrderingComposer
    extends Composer<_$AppDatabase, $OrderItemModifiersTable> {
  $$OrderItemModifiersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get itemModifierId => $composableBuilder(
    column: $table.itemModifierId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get modifierName => $composableBuilder(
    column: $table.modifierName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get priceAdjustment => $composableBuilder(
    column: $table.priceAdjustment,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$SalesOrderItemsTableOrderingComposer get orderItemId {
    final $$SalesOrderItemsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderItemId,
      referencedTable: $db.salesOrderItems,
      getReferencedColumn: (t) => t.itemId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrderItemsTableOrderingComposer(
            $db: $db,
            $table: $db.salesOrderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ModifiersTableOrderingComposer get modifierId {
    final $$ModifiersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierId,
      referencedTable: $db.modifiers,
      getReferencedColumn: (t) => t.modifierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ModifiersTableOrderingComposer(
            $db: $db,
            $table: $db.modifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemModifiersTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrderItemModifiersTable> {
  $$OrderItemModifiersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get itemModifierId => $composableBuilder(
    column: $table.itemModifierId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get modifierName => $composableBuilder(
    column: $table.modifierName,
    builder: (column) => column,
  );

  GeneratedColumn<double> get priceAdjustment => $composableBuilder(
    column: $table.priceAdjustment,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$SalesOrderItemsTableAnnotationComposer get orderItemId {
    final $$SalesOrderItemsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderItemId,
      referencedTable: $db.salesOrderItems,
      getReferencedColumn: (t) => t.itemId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrderItemsTableAnnotationComposer(
            $db: $db,
            $table: $db.salesOrderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ModifiersTableAnnotationComposer get modifierId {
    final $$ModifiersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.modifierId,
      referencedTable: $db.modifiers,
      getReferencedColumn: (t) => t.modifierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ModifiersTableAnnotationComposer(
            $db: $db,
            $table: $db.modifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemModifiersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OrderItemModifiersTable,
          OrderItemModifier,
          $$OrderItemModifiersTableFilterComposer,
          $$OrderItemModifiersTableOrderingComposer,
          $$OrderItemModifiersTableAnnotationComposer,
          $$OrderItemModifiersTableCreateCompanionBuilder,
          $$OrderItemModifiersTableUpdateCompanionBuilder,
          (OrderItemModifier, $$OrderItemModifiersTableReferences),
          OrderItemModifier,
          PrefetchHooks Function({bool orderItemId, bool modifierId})
        > {
  $$OrderItemModifiersTableTableManager(
    _$AppDatabase db,
    $OrderItemModifiersTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrderItemModifiersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrderItemModifiersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrderItemModifiersTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> itemModifierId = const Value.absent(),
                Value<String> orderItemId = const Value.absent(),
                Value<String> modifierId = const Value.absent(),
                Value<String> modifierName = const Value.absent(),
                Value<double> priceAdjustment = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrderItemModifiersCompanion(
                itemModifierId: itemModifierId,
                orderItemId: orderItemId,
                modifierId: modifierId,
                modifierName: modifierName,
                priceAdjustment: priceAdjustment,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String itemModifierId,
                required String orderItemId,
                required String modifierId,
                required String modifierName,
                Value<double> priceAdjustment = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrderItemModifiersCompanion.insert(
                itemModifierId: itemModifierId,
                orderItemId: orderItemId,
                modifierId: modifierId,
                modifierName: modifierName,
                priceAdjustment: priceAdjustment,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OrderItemModifiersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({orderItemId = false, modifierId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (orderItemId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.orderItemId,
                                referencedTable:
                                    $$OrderItemModifiersTableReferences
                                        ._orderItemIdTable(db),
                                referencedColumn:
                                    $$OrderItemModifiersTableReferences
                                        ._orderItemIdTable(db)
                                        .itemId,
                              )
                              as T;
                    }
                    if (modifierId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.modifierId,
                                referencedTable:
                                    $$OrderItemModifiersTableReferences
                                        ._modifierIdTable(db),
                                referencedColumn:
                                    $$OrderItemModifiersTableReferences
                                        ._modifierIdTable(db)
                                        .modifierId,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$OrderItemModifiersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OrderItemModifiersTable,
      OrderItemModifier,
      $$OrderItemModifiersTableFilterComposer,
      $$OrderItemModifiersTableOrderingComposer,
      $$OrderItemModifiersTableAnnotationComposer,
      $$OrderItemModifiersTableCreateCompanionBuilder,
      $$OrderItemModifiersTableUpdateCompanionBuilder,
      (OrderItemModifier, $$OrderItemModifiersTableReferences),
      OrderItemModifier,
      PrefetchHooks Function({bool orderItemId, bool modifierId})
    >;
typedef $$PurchaseOrdersTableCreateCompanionBuilder =
    PurchaseOrdersCompanion Function({
      required String poId,
      required String poNo,
      required DateTime poDate,
      Value<String> poType,
      required String supplierId,
      required String supplierName,
      required String branchId,
      required String warehouseId,
      required String userId,
      Value<double> subtotal,
      Value<double> discountAmount,
      Value<double> amountBeforeVat,
      Value<double> vatAmount,
      Value<double> totalAmount,
      Value<String> status,
      Value<String?> remark,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$PurchaseOrdersTableUpdateCompanionBuilder =
    PurchaseOrdersCompanion Function({
      Value<String> poId,
      Value<String> poNo,
      Value<DateTime> poDate,
      Value<String> poType,
      Value<String> supplierId,
      Value<String> supplierName,
      Value<String> branchId,
      Value<String> warehouseId,
      Value<String> userId,
      Value<double> subtotal,
      Value<double> discountAmount,
      Value<double> amountBeforeVat,
      Value<double> vatAmount,
      Value<double> totalAmount,
      Value<String> status,
      Value<String?> remark,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$PurchaseOrdersTableReferences
    extends BaseReferences<_$AppDatabase, $PurchaseOrdersTable, PurchaseOrder> {
  $$PurchaseOrdersTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $SuppliersTable _supplierIdTable(_$AppDatabase db) =>
      db.suppliers.createAlias(
        $_aliasNameGenerator(
          db.purchaseOrders.supplierId,
          db.suppliers.supplierId,
        ),
      );

  $$SuppliersTableProcessedTableManager get supplierId {
    final $_column = $_itemColumn<String>('supplier_id')!;

    final manager = $$SuppliersTableTableManager(
      $_db,
      $_db.suppliers,
    ).filter((f) => f.supplierId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_supplierIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $BranchesTable _branchIdTable(_$AppDatabase db) =>
      db.branches.createAlias(
        $_aliasNameGenerator(db.purchaseOrders.branchId, db.branches.branchId),
      );

  $$BranchesTableProcessedTableManager get branchId {
    final $_column = $_itemColumn<String>('branch_id')!;

    final manager = $$BranchesTableTableManager(
      $_db,
      $_db.branches,
    ).filter((f) => f.branchId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_branchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $WarehousesTable _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias(
        $_aliasNameGenerator(
          db.purchaseOrders.warehouseId,
          db.warehouses.warehouseId,
        ),
      );

  $$WarehousesTableProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<String>('warehouse_id')!;

    final manager = $$WarehousesTableTableManager(
      $_db,
      $_db.warehouses,
    ).filter((f) => f.warehouseId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.purchaseOrders.userId, db.users.userId),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.userId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$PurchaseOrderItemsTable, List<PurchaseOrderItem>>
  _purchaseOrderItemsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.purchaseOrderItems,
        aliasName: $_aliasNameGenerator(
          db.purchaseOrders.poId,
          db.purchaseOrderItems.poId,
        ),
      );

  $$PurchaseOrderItemsTableProcessedTableManager get purchaseOrderItemsRefs {
    final manager = $$PurchaseOrderItemsTableTableManager(
      $_db,
      $_db.purchaseOrderItems,
    ).filter((f) => f.poId.poId.sqlEquals($_itemColumn<String>('po_id')!));

    final cache = $_typedResult.readTableOrNull(
      _purchaseOrderItemsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$PurchaseOrdersTableFilterComposer
    extends Composer<_$AppDatabase, $PurchaseOrdersTable> {
  $$PurchaseOrdersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get poId => $composableBuilder(
    column: $table.poId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get poNo => $composableBuilder(
    column: $table.poNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get poDate => $composableBuilder(
    column: $table.poDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get poType => $composableBuilder(
    column: $table.poType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get supplierName => $composableBuilder(
    column: $table.supplierName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get subtotal => $composableBuilder(
    column: $table.subtotal,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get amountBeforeVat => $composableBuilder(
    column: $table.amountBeforeVat,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get vatAmount => $composableBuilder(
    column: $table.vatAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get remark => $composableBuilder(
    column: $table.remark,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$SuppliersTableFilterComposer get supplierId {
    final $$SuppliersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.suppliers,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SuppliersTableFilterComposer(
            $db: $db,
            $table: $db.suppliers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableFilterComposer get branchId {
    final $$BranchesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableFilterComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableFilterComposer get warehouseId {
    final $$WarehousesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableFilterComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> purchaseOrderItemsRefs(
    Expression<bool> Function($$PurchaseOrderItemsTableFilterComposer f) f,
  ) {
    final $$PurchaseOrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.poId,
      referencedTable: $db.purchaseOrderItems,
      getReferencedColumn: (t) => t.poId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$PurchaseOrdersTableOrderingComposer
    extends Composer<_$AppDatabase, $PurchaseOrdersTable> {
  $$PurchaseOrdersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get poId => $composableBuilder(
    column: $table.poId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get poNo => $composableBuilder(
    column: $table.poNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get poDate => $composableBuilder(
    column: $table.poDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get poType => $composableBuilder(
    column: $table.poType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get supplierName => $composableBuilder(
    column: $table.supplierName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get subtotal => $composableBuilder(
    column: $table.subtotal,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get amountBeforeVat => $composableBuilder(
    column: $table.amountBeforeVat,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get vatAmount => $composableBuilder(
    column: $table.vatAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get remark => $composableBuilder(
    column: $table.remark,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$SuppliersTableOrderingComposer get supplierId {
    final $$SuppliersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.suppliers,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SuppliersTableOrderingComposer(
            $db: $db,
            $table: $db.suppliers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableOrderingComposer get branchId {
    final $$BranchesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableOrderingComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableOrderingComposer get warehouseId {
    final $$WarehousesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableOrderingComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PurchaseOrdersTableAnnotationComposer
    extends Composer<_$AppDatabase, $PurchaseOrdersTable> {
  $$PurchaseOrdersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get poId =>
      $composableBuilder(column: $table.poId, builder: (column) => column);

  GeneratedColumn<String> get poNo =>
      $composableBuilder(column: $table.poNo, builder: (column) => column);

  GeneratedColumn<DateTime> get poDate =>
      $composableBuilder(column: $table.poDate, builder: (column) => column);

  GeneratedColumn<String> get poType =>
      $composableBuilder(column: $table.poType, builder: (column) => column);

  GeneratedColumn<String> get supplierName => $composableBuilder(
    column: $table.supplierName,
    builder: (column) => column,
  );

  GeneratedColumn<double> get subtotal =>
      $composableBuilder(column: $table.subtotal, builder: (column) => column);

  GeneratedColumn<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => column,
  );

  GeneratedColumn<double> get amountBeforeVat => $composableBuilder(
    column: $table.amountBeforeVat,
    builder: (column) => column,
  );

  GeneratedColumn<double> get vatAmount =>
      $composableBuilder(column: $table.vatAmount, builder: (column) => column);

  GeneratedColumn<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get remark =>
      $composableBuilder(column: $table.remark, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$SuppliersTableAnnotationComposer get supplierId {
    final $$SuppliersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.suppliers,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SuppliersTableAnnotationComposer(
            $db: $db,
            $table: $db.suppliers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableAnnotationComposer get branchId {
    final $$BranchesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableAnnotationComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableAnnotationComposer get warehouseId {
    final $$WarehousesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableAnnotationComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> purchaseOrderItemsRefs<T extends Object>(
    Expression<T> Function($$PurchaseOrderItemsTableAnnotationComposer a) f,
  ) {
    final $$PurchaseOrderItemsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.poId,
          referencedTable: $db.purchaseOrderItems,
          getReferencedColumn: (t) => t.poId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$PurchaseOrderItemsTableAnnotationComposer(
                $db: $db,
                $table: $db.purchaseOrderItems,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$PurchaseOrdersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PurchaseOrdersTable,
          PurchaseOrder,
          $$PurchaseOrdersTableFilterComposer,
          $$PurchaseOrdersTableOrderingComposer,
          $$PurchaseOrdersTableAnnotationComposer,
          $$PurchaseOrdersTableCreateCompanionBuilder,
          $$PurchaseOrdersTableUpdateCompanionBuilder,
          (PurchaseOrder, $$PurchaseOrdersTableReferences),
          PurchaseOrder,
          PrefetchHooks Function({
            bool supplierId,
            bool branchId,
            bool warehouseId,
            bool userId,
            bool purchaseOrderItemsRefs,
          })
        > {
  $$PurchaseOrdersTableTableManager(
    _$AppDatabase db,
    $PurchaseOrdersTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PurchaseOrdersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PurchaseOrdersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PurchaseOrdersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> poId = const Value.absent(),
                Value<String> poNo = const Value.absent(),
                Value<DateTime> poDate = const Value.absent(),
                Value<String> poType = const Value.absent(),
                Value<String> supplierId = const Value.absent(),
                Value<String> supplierName = const Value.absent(),
                Value<String> branchId = const Value.absent(),
                Value<String> warehouseId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<double> subtotal = const Value.absent(),
                Value<double> discountAmount = const Value.absent(),
                Value<double> amountBeforeVat = const Value.absent(),
                Value<double> vatAmount = const Value.absent(),
                Value<double> totalAmount = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> remark = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PurchaseOrdersCompanion(
                poId: poId,
                poNo: poNo,
                poDate: poDate,
                poType: poType,
                supplierId: supplierId,
                supplierName: supplierName,
                branchId: branchId,
                warehouseId: warehouseId,
                userId: userId,
                subtotal: subtotal,
                discountAmount: discountAmount,
                amountBeforeVat: amountBeforeVat,
                vatAmount: vatAmount,
                totalAmount: totalAmount,
                status: status,
                remark: remark,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String poId,
                required String poNo,
                required DateTime poDate,
                Value<String> poType = const Value.absent(),
                required String supplierId,
                required String supplierName,
                required String branchId,
                required String warehouseId,
                required String userId,
                Value<double> subtotal = const Value.absent(),
                Value<double> discountAmount = const Value.absent(),
                Value<double> amountBeforeVat = const Value.absent(),
                Value<double> vatAmount = const Value.absent(),
                Value<double> totalAmount = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> remark = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PurchaseOrdersCompanion.insert(
                poId: poId,
                poNo: poNo,
                poDate: poDate,
                poType: poType,
                supplierId: supplierId,
                supplierName: supplierName,
                branchId: branchId,
                warehouseId: warehouseId,
                userId: userId,
                subtotal: subtotal,
                discountAmount: discountAmount,
                amountBeforeVat: amountBeforeVat,
                vatAmount: vatAmount,
                totalAmount: totalAmount,
                status: status,
                remark: remark,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PurchaseOrdersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                supplierId = false,
                branchId = false,
                warehouseId = false,
                userId = false,
                purchaseOrderItemsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (purchaseOrderItemsRefs) db.purchaseOrderItems,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (supplierId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.supplierId,
                                    referencedTable:
                                        $$PurchaseOrdersTableReferences
                                            ._supplierIdTable(db),
                                    referencedColumn:
                                        $$PurchaseOrdersTableReferences
                                            ._supplierIdTable(db)
                                            .supplierId,
                                  )
                                  as T;
                        }
                        if (branchId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.branchId,
                                    referencedTable:
                                        $$PurchaseOrdersTableReferences
                                            ._branchIdTable(db),
                                    referencedColumn:
                                        $$PurchaseOrdersTableReferences
                                            ._branchIdTable(db)
                                            .branchId,
                                  )
                                  as T;
                        }
                        if (warehouseId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.warehouseId,
                                    referencedTable:
                                        $$PurchaseOrdersTableReferences
                                            ._warehouseIdTable(db),
                                    referencedColumn:
                                        $$PurchaseOrdersTableReferences
                                            ._warehouseIdTable(db)
                                            .warehouseId,
                                  )
                                  as T;
                        }
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable:
                                        $$PurchaseOrdersTableReferences
                                            ._userIdTable(db),
                                    referencedColumn:
                                        $$PurchaseOrdersTableReferences
                                            ._userIdTable(db)
                                            .userId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (purchaseOrderItemsRefs)
                        await $_getPrefetchedData<
                          PurchaseOrder,
                          $PurchaseOrdersTable,
                          PurchaseOrderItem
                        >(
                          currentTable: table,
                          referencedTable: $$PurchaseOrdersTableReferences
                              ._purchaseOrderItemsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$PurchaseOrdersTableReferences(
                                db,
                                table,
                                p0,
                              ).purchaseOrderItemsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.poId == item.poId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$PurchaseOrdersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PurchaseOrdersTable,
      PurchaseOrder,
      $$PurchaseOrdersTableFilterComposer,
      $$PurchaseOrdersTableOrderingComposer,
      $$PurchaseOrdersTableAnnotationComposer,
      $$PurchaseOrdersTableCreateCompanionBuilder,
      $$PurchaseOrdersTableUpdateCompanionBuilder,
      (PurchaseOrder, $$PurchaseOrdersTableReferences),
      PurchaseOrder,
      PrefetchHooks Function({
        bool supplierId,
        bool branchId,
        bool warehouseId,
        bool userId,
        bool purchaseOrderItemsRefs,
      })
    >;
typedef $$PurchaseOrderItemsTableCreateCompanionBuilder =
    PurchaseOrderItemsCompanion Function({
      required String itemId,
      required String poId,
      required int lineNo,
      required String productId,
      required String productCode,
      required String productName,
      required String unit,
      required double quantity,
      required double unitPrice,
      Value<double> discountPercent,
      Value<double> discountAmount,
      required double amount,
      Value<double> receivedQty,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$PurchaseOrderItemsTableUpdateCompanionBuilder =
    PurchaseOrderItemsCompanion Function({
      Value<String> itemId,
      Value<String> poId,
      Value<int> lineNo,
      Value<String> productId,
      Value<String> productCode,
      Value<String> productName,
      Value<String> unit,
      Value<double> quantity,
      Value<double> unitPrice,
      Value<double> discountPercent,
      Value<double> discountAmount,
      Value<double> amount,
      Value<double> receivedQty,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$PurchaseOrderItemsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $PurchaseOrderItemsTable,
          PurchaseOrderItem
        > {
  $$PurchaseOrderItemsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PurchaseOrdersTable _poIdTable(_$AppDatabase db) =>
      db.purchaseOrders.createAlias(
        $_aliasNameGenerator(
          db.purchaseOrderItems.poId,
          db.purchaseOrders.poId,
        ),
      );

  $$PurchaseOrdersTableProcessedTableManager get poId {
    final $_column = $_itemColumn<String>('po_id')!;

    final manager = $$PurchaseOrdersTableTableManager(
      $_db,
      $_db.purchaseOrders,
    ).filter((f) => f.poId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_poIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductsTable _productIdTable(_$AppDatabase db) =>
      db.products.createAlias(
        $_aliasNameGenerator(
          db.purchaseOrderItems.productId,
          db.products.productId,
        ),
      );

  $$ProductsTableProcessedTableManager get productId {
    final $_column = $_itemColumn<String>('product_id')!;

    final manager = $$ProductsTableTableManager(
      $_db,
      $_db.products,
    ).filter((f) => f.productId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$PurchaseOrderItemsTableFilterComposer
    extends Composer<_$AppDatabase, $PurchaseOrderItemsTable> {
  $$PurchaseOrderItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get itemId => $composableBuilder(
    column: $table.itemId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lineNo => $composableBuilder(
    column: $table.lineNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get productCode => $composableBuilder(
    column: $table.productCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get unitPrice => $composableBuilder(
    column: $table.unitPrice,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get discountPercent => $composableBuilder(
    column: $table.discountPercent,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get receivedQty => $composableBuilder(
    column: $table.receivedQty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$PurchaseOrdersTableFilterComposer get poId {
    final $$PurchaseOrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.poId,
      referencedTable: $db.purchaseOrders,
      getReferencedColumn: (t) => t.poId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrdersTableFilterComposer(
            $db: $db,
            $table: $db.purchaseOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableFilterComposer get productId {
    final $$ProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableFilterComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PurchaseOrderItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $PurchaseOrderItemsTable> {
  $$PurchaseOrderItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get itemId => $composableBuilder(
    column: $table.itemId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lineNo => $composableBuilder(
    column: $table.lineNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get productCode => $composableBuilder(
    column: $table.productCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get unitPrice => $composableBuilder(
    column: $table.unitPrice,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get discountPercent => $composableBuilder(
    column: $table.discountPercent,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get receivedQty => $composableBuilder(
    column: $table.receivedQty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$PurchaseOrdersTableOrderingComposer get poId {
    final $$PurchaseOrdersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.poId,
      referencedTable: $db.purchaseOrders,
      getReferencedColumn: (t) => t.poId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrdersTableOrderingComposer(
            $db: $db,
            $table: $db.purchaseOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableOrderingComposer get productId {
    final $$ProductsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableOrderingComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PurchaseOrderItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $PurchaseOrderItemsTable> {
  $$PurchaseOrderItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get itemId =>
      $composableBuilder(column: $table.itemId, builder: (column) => column);

  GeneratedColumn<int> get lineNo =>
      $composableBuilder(column: $table.lineNo, builder: (column) => column);

  GeneratedColumn<String> get productCode => $composableBuilder(
    column: $table.productCode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get productName => $composableBuilder(
    column: $table.productName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get unit =>
      $composableBuilder(column: $table.unit, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get unitPrice =>
      $composableBuilder(column: $table.unitPrice, builder: (column) => column);

  GeneratedColumn<double> get discountPercent => $composableBuilder(
    column: $table.discountPercent,
    builder: (column) => column,
  );

  GeneratedColumn<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => column,
  );

  GeneratedColumn<double> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<double> get receivedQty => $composableBuilder(
    column: $table.receivedQty,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$PurchaseOrdersTableAnnotationComposer get poId {
    final $$PurchaseOrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.poId,
      referencedTable: $db.purchaseOrders,
      getReferencedColumn: (t) => t.poId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PurchaseOrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.purchaseOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableAnnotationComposer get productId {
    final $$ProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PurchaseOrderItemsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PurchaseOrderItemsTable,
          PurchaseOrderItem,
          $$PurchaseOrderItemsTableFilterComposer,
          $$PurchaseOrderItemsTableOrderingComposer,
          $$PurchaseOrderItemsTableAnnotationComposer,
          $$PurchaseOrderItemsTableCreateCompanionBuilder,
          $$PurchaseOrderItemsTableUpdateCompanionBuilder,
          (PurchaseOrderItem, $$PurchaseOrderItemsTableReferences),
          PurchaseOrderItem,
          PrefetchHooks Function({bool poId, bool productId})
        > {
  $$PurchaseOrderItemsTableTableManager(
    _$AppDatabase db,
    $PurchaseOrderItemsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PurchaseOrderItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PurchaseOrderItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PurchaseOrderItemsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> itemId = const Value.absent(),
                Value<String> poId = const Value.absent(),
                Value<int> lineNo = const Value.absent(),
                Value<String> productId = const Value.absent(),
                Value<String> productCode = const Value.absent(),
                Value<String> productName = const Value.absent(),
                Value<String> unit = const Value.absent(),
                Value<double> quantity = const Value.absent(),
                Value<double> unitPrice = const Value.absent(),
                Value<double> discountPercent = const Value.absent(),
                Value<double> discountAmount = const Value.absent(),
                Value<double> amount = const Value.absent(),
                Value<double> receivedQty = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PurchaseOrderItemsCompanion(
                itemId: itemId,
                poId: poId,
                lineNo: lineNo,
                productId: productId,
                productCode: productCode,
                productName: productName,
                unit: unit,
                quantity: quantity,
                unitPrice: unitPrice,
                discountPercent: discountPercent,
                discountAmount: discountAmount,
                amount: amount,
                receivedQty: receivedQty,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String itemId,
                required String poId,
                required int lineNo,
                required String productId,
                required String productCode,
                required String productName,
                required String unit,
                required double quantity,
                required double unitPrice,
                Value<double> discountPercent = const Value.absent(),
                Value<double> discountAmount = const Value.absent(),
                required double amount,
                Value<double> receivedQty = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PurchaseOrderItemsCompanion.insert(
                itemId: itemId,
                poId: poId,
                lineNo: lineNo,
                productId: productId,
                productCode: productCode,
                productName: productName,
                unit: unit,
                quantity: quantity,
                unitPrice: unitPrice,
                discountPercent: discountPercent,
                discountAmount: discountAmount,
                amount: amount,
                receivedQty: receivedQty,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PurchaseOrderItemsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({poId = false, productId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (poId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.poId,
                                referencedTable:
                                    $$PurchaseOrderItemsTableReferences
                                        ._poIdTable(db),
                                referencedColumn:
                                    $$PurchaseOrderItemsTableReferences
                                        ._poIdTable(db)
                                        .poId,
                              )
                              as T;
                    }
                    if (productId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.productId,
                                referencedTable:
                                    $$PurchaseOrderItemsTableReferences
                                        ._productIdTable(db),
                                referencedColumn:
                                    $$PurchaseOrderItemsTableReferences
                                        ._productIdTable(db)
                                        .productId,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$PurchaseOrderItemsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PurchaseOrderItemsTable,
      PurchaseOrderItem,
      $$PurchaseOrderItemsTableFilterComposer,
      $$PurchaseOrderItemsTableOrderingComposer,
      $$PurchaseOrderItemsTableAnnotationComposer,
      $$PurchaseOrderItemsTableCreateCompanionBuilder,
      $$PurchaseOrderItemsTableUpdateCompanionBuilder,
      (PurchaseOrderItem, $$PurchaseOrderItemsTableReferences),
      PurchaseOrderItem,
      PrefetchHooks Function({bool poId, bool productId})
    >;
typedef $$StockMovementsTableCreateCompanionBuilder =
    StockMovementsCompanion Function({
      required String movementId,
      required String movementNo,
      required DateTime movementDate,
      required String movementType,
      required String productId,
      required String warehouseId,
      required double quantity,
      Value<double> unitCost,
      Value<String?> referenceType,
      Value<String?> referenceId,
      required String userId,
      Value<String?> remark,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$StockMovementsTableUpdateCompanionBuilder =
    StockMovementsCompanion Function({
      Value<String> movementId,
      Value<String> movementNo,
      Value<DateTime> movementDate,
      Value<String> movementType,
      Value<String> productId,
      Value<String> warehouseId,
      Value<double> quantity,
      Value<double> unitCost,
      Value<String?> referenceType,
      Value<String?> referenceId,
      Value<String> userId,
      Value<String?> remark,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$StockMovementsTableReferences
    extends BaseReferences<_$AppDatabase, $StockMovementsTable, StockMovement> {
  $$StockMovementsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ProductsTable _productIdTable(_$AppDatabase db) =>
      db.products.createAlias(
        $_aliasNameGenerator(
          db.stockMovements.productId,
          db.products.productId,
        ),
      );

  $$ProductsTableProcessedTableManager get productId {
    final $_column = $_itemColumn<String>('product_id')!;

    final manager = $$ProductsTableTableManager(
      $_db,
      $_db.products,
    ).filter((f) => f.productId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $WarehousesTable _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias(
        $_aliasNameGenerator(
          db.stockMovements.warehouseId,
          db.warehouses.warehouseId,
        ),
      );

  $$WarehousesTableProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<String>('warehouse_id')!;

    final manager = $$WarehousesTableTableManager(
      $_db,
      $_db.warehouses,
    ).filter((f) => f.warehouseId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.stockMovements.userId, db.users.userId),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.userId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$StockMovementsTableFilterComposer
    extends Composer<_$AppDatabase, $StockMovementsTable> {
  $$StockMovementsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get movementId => $composableBuilder(
    column: $table.movementId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get movementNo => $composableBuilder(
    column: $table.movementNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get movementDate => $composableBuilder(
    column: $table.movementDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get movementType => $composableBuilder(
    column: $table.movementType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get unitCost => $composableBuilder(
    column: $table.unitCost,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get referenceType => $composableBuilder(
    column: $table.referenceType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get referenceId => $composableBuilder(
    column: $table.referenceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get remark => $composableBuilder(
    column: $table.remark,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ProductsTableFilterComposer get productId {
    final $$ProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableFilterComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableFilterComposer get warehouseId {
    final $$WarehousesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableFilterComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StockMovementsTableOrderingComposer
    extends Composer<_$AppDatabase, $StockMovementsTable> {
  $$StockMovementsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get movementId => $composableBuilder(
    column: $table.movementId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get movementNo => $composableBuilder(
    column: $table.movementNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get movementDate => $composableBuilder(
    column: $table.movementDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get movementType => $composableBuilder(
    column: $table.movementType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get unitCost => $composableBuilder(
    column: $table.unitCost,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get referenceType => $composableBuilder(
    column: $table.referenceType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get referenceId => $composableBuilder(
    column: $table.referenceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get remark => $composableBuilder(
    column: $table.remark,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ProductsTableOrderingComposer get productId {
    final $$ProductsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableOrderingComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableOrderingComposer get warehouseId {
    final $$WarehousesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableOrderingComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StockMovementsTableAnnotationComposer
    extends Composer<_$AppDatabase, $StockMovementsTable> {
  $$StockMovementsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get movementId => $composableBuilder(
    column: $table.movementId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get movementNo => $composableBuilder(
    column: $table.movementNo,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get movementDate => $composableBuilder(
    column: $table.movementDate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get movementType => $composableBuilder(
    column: $table.movementType,
    builder: (column) => column,
  );

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get unitCost =>
      $composableBuilder(column: $table.unitCost, builder: (column) => column);

  GeneratedColumn<String> get referenceType => $composableBuilder(
    column: $table.referenceType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get referenceId => $composableBuilder(
    column: $table.referenceId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get remark =>
      $composableBuilder(column: $table.remark, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$ProductsTableAnnotationComposer get productId {
    final $$ProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$WarehousesTableAnnotationComposer get warehouseId {
    final $$WarehousesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.warehouseId,
      referencedTable: $db.warehouses,
      getReferencedColumn: (t) => t.warehouseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$WarehousesTableAnnotationComposer(
            $db: $db,
            $table: $db.warehouses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$StockMovementsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $StockMovementsTable,
          StockMovement,
          $$StockMovementsTableFilterComposer,
          $$StockMovementsTableOrderingComposer,
          $$StockMovementsTableAnnotationComposer,
          $$StockMovementsTableCreateCompanionBuilder,
          $$StockMovementsTableUpdateCompanionBuilder,
          (StockMovement, $$StockMovementsTableReferences),
          StockMovement,
          PrefetchHooks Function({
            bool productId,
            bool warehouseId,
            bool userId,
          })
        > {
  $$StockMovementsTableTableManager(
    _$AppDatabase db,
    $StockMovementsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StockMovementsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StockMovementsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StockMovementsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> movementId = const Value.absent(),
                Value<String> movementNo = const Value.absent(),
                Value<DateTime> movementDate = const Value.absent(),
                Value<String> movementType = const Value.absent(),
                Value<String> productId = const Value.absent(),
                Value<String> warehouseId = const Value.absent(),
                Value<double> quantity = const Value.absent(),
                Value<double> unitCost = const Value.absent(),
                Value<String?> referenceType = const Value.absent(),
                Value<String?> referenceId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> remark = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => StockMovementsCompanion(
                movementId: movementId,
                movementNo: movementNo,
                movementDate: movementDate,
                movementType: movementType,
                productId: productId,
                warehouseId: warehouseId,
                quantity: quantity,
                unitCost: unitCost,
                referenceType: referenceType,
                referenceId: referenceId,
                userId: userId,
                remark: remark,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String movementId,
                required String movementNo,
                required DateTime movementDate,
                required String movementType,
                required String productId,
                required String warehouseId,
                required double quantity,
                Value<double> unitCost = const Value.absent(),
                Value<String?> referenceType = const Value.absent(),
                Value<String?> referenceId = const Value.absent(),
                required String userId,
                Value<String?> remark = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => StockMovementsCompanion.insert(
                movementId: movementId,
                movementNo: movementNo,
                movementDate: movementDate,
                movementType: movementType,
                productId: productId,
                warehouseId: warehouseId,
                quantity: quantity,
                unitCost: unitCost,
                referenceType: referenceType,
                referenceId: referenceId,
                userId: userId,
                remark: remark,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$StockMovementsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({productId = false, warehouseId = false, userId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable:
                                        $$StockMovementsTableReferences
                                            ._productIdTable(db),
                                    referencedColumn:
                                        $$StockMovementsTableReferences
                                            ._productIdTable(db)
                                            .productId,
                                  )
                                  as T;
                        }
                        if (warehouseId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.warehouseId,
                                    referencedTable:
                                        $$StockMovementsTableReferences
                                            ._warehouseIdTable(db),
                                    referencedColumn:
                                        $$StockMovementsTableReferences
                                            ._warehouseIdTable(db)
                                            .warehouseId,
                                  )
                                  as T;
                        }
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable:
                                        $$StockMovementsTableReferences
                                            ._userIdTable(db),
                                    referencedColumn:
                                        $$StockMovementsTableReferences
                                            ._userIdTable(db)
                                            .userId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$StockMovementsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $StockMovementsTable,
      StockMovement,
      $$StockMovementsTableFilterComposer,
      $$StockMovementsTableOrderingComposer,
      $$StockMovementsTableAnnotationComposer,
      $$StockMovementsTableCreateCompanionBuilder,
      $$StockMovementsTableUpdateCompanionBuilder,
      (StockMovement, $$StockMovementsTableReferences),
      StockMovement,
      PrefetchHooks Function({bool productId, bool warehouseId, bool userId})
    >;
typedef $$PromotionsTableCreateCompanionBuilder =
    PromotionsCompanion Function({
      required String promotionId,
      required String promotionCode,
      required String promotionName,
      required String promotionType,
      Value<String?> discountType,
      Value<double> discountValue,
      Value<double?> maxDiscountAmount,
      Value<int?> buyQty,
      Value<int?> getQty,
      Value<String?> getProductId,
      Value<double> minAmount,
      Value<double> minQty,
      required String applyTo,
      Value<Map<String, dynamic>?> applyToIds,
      required DateTime startDate,
      required DateTime endDate,
      Value<String?> startTime,
      Value<String?> endTime,
      Value<Map<String, dynamic>?> applyDays,
      Value<int?> maxUses,
      Value<int?> maxUsesPerCustomer,
      Value<int> currentUses,
      Value<bool> isExclusive,
      Value<bool> isActive,
      Value<String?> createdBy,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$PromotionsTableUpdateCompanionBuilder =
    PromotionsCompanion Function({
      Value<String> promotionId,
      Value<String> promotionCode,
      Value<String> promotionName,
      Value<String> promotionType,
      Value<String?> discountType,
      Value<double> discountValue,
      Value<double?> maxDiscountAmount,
      Value<int?> buyQty,
      Value<int?> getQty,
      Value<String?> getProductId,
      Value<double> minAmount,
      Value<double> minQty,
      Value<String> applyTo,
      Value<Map<String, dynamic>?> applyToIds,
      Value<DateTime> startDate,
      Value<DateTime> endDate,
      Value<String?> startTime,
      Value<String?> endTime,
      Value<Map<String, dynamic>?> applyDays,
      Value<int?> maxUses,
      Value<int?> maxUsesPerCustomer,
      Value<int> currentUses,
      Value<bool> isExclusive,
      Value<bool> isActive,
      Value<String?> createdBy,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$PromotionsTableReferences
    extends BaseReferences<_$AppDatabase, $PromotionsTable, Promotion> {
  $$PromotionsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _createdByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.promotions.createdBy, db.users.userId),
  );

  $$UsersTableProcessedTableManager? get createdBy {
    final $_column = $_itemColumn<String>('created_by');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.userId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_createdByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$PromotionUsagesTable, List<PromotionUsage>>
  _promotionUsagesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.promotionUsages,
    aliasName: $_aliasNameGenerator(
      db.promotions.promotionId,
      db.promotionUsages.promotionId,
    ),
  );

  $$PromotionUsagesTableProcessedTableManager get promotionUsagesRefs {
    final manager =
        $$PromotionUsagesTableTableManager($_db, $_db.promotionUsages).filter(
          (f) => f.promotionId.promotionId.sqlEquals(
            $_itemColumn<String>('promotion_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _promotionUsagesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$CouponsTable, List<Coupon>> _couponsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.coupons,
    aliasName: $_aliasNameGenerator(
      db.promotions.promotionId,
      db.coupons.promotionId,
    ),
  );

  $$CouponsTableProcessedTableManager get couponsRefs {
    final manager = $$CouponsTableTableManager($_db, $_db.coupons).filter(
      (f) => f.promotionId.promotionId.sqlEquals(
        $_itemColumn<String>('promotion_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_couponsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$PromotionsTableFilterComposer
    extends Composer<_$AppDatabase, $PromotionsTable> {
  $$PromotionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get promotionId => $composableBuilder(
    column: $table.promotionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get promotionCode => $composableBuilder(
    column: $table.promotionCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get promotionName => $composableBuilder(
    column: $table.promotionName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get promotionType => $composableBuilder(
    column: $table.promotionType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get discountType => $composableBuilder(
    column: $table.discountType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get discountValue => $composableBuilder(
    column: $table.discountValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get maxDiscountAmount => $composableBuilder(
    column: $table.maxDiscountAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get buyQty => $composableBuilder(
    column: $table.buyQty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get getQty => $composableBuilder(
    column: $table.getQty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get getProductId => $composableBuilder(
    column: $table.getProductId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get minAmount => $composableBuilder(
    column: $table.minAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get minQty => $composableBuilder(
    column: $table.minQty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get applyTo => $composableBuilder(
    column: $table.applyTo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get applyToIds => $composableBuilder(
    column: $table.applyToIds,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get startDate => $composableBuilder(
    column: $table.startDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get startTime => $composableBuilder(
    column: $table.startTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get endTime => $composableBuilder(
    column: $table.endTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get applyDays => $composableBuilder(
    column: $table.applyDays,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<int> get maxUses => $composableBuilder(
    column: $table.maxUses,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get maxUsesPerCustomer => $composableBuilder(
    column: $table.maxUsesPerCustomer,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get currentUses => $composableBuilder(
    column: $table.currentUses,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isExclusive => $composableBuilder(
    column: $table.isExclusive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get createdBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> promotionUsagesRefs(
    Expression<bool> Function($$PromotionUsagesTableFilterComposer f) f,
  ) {
    final $$PromotionUsagesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.promotionId,
      referencedTable: $db.promotionUsages,
      getReferencedColumn: (t) => t.promotionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionUsagesTableFilterComposer(
            $db: $db,
            $table: $db.promotionUsages,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> couponsRefs(
    Expression<bool> Function($$CouponsTableFilterComposer f) f,
  ) {
    final $$CouponsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.promotionId,
      referencedTable: $db.coupons,
      getReferencedColumn: (t) => t.promotionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CouponsTableFilterComposer(
            $db: $db,
            $table: $db.coupons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$PromotionsTableOrderingComposer
    extends Composer<_$AppDatabase, $PromotionsTable> {
  $$PromotionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get promotionId => $composableBuilder(
    column: $table.promotionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get promotionCode => $composableBuilder(
    column: $table.promotionCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get promotionName => $composableBuilder(
    column: $table.promotionName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get promotionType => $composableBuilder(
    column: $table.promotionType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get discountType => $composableBuilder(
    column: $table.discountType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get discountValue => $composableBuilder(
    column: $table.discountValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get maxDiscountAmount => $composableBuilder(
    column: $table.maxDiscountAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get buyQty => $composableBuilder(
    column: $table.buyQty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get getQty => $composableBuilder(
    column: $table.getQty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get getProductId => $composableBuilder(
    column: $table.getProductId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get minAmount => $composableBuilder(
    column: $table.minAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get minQty => $composableBuilder(
    column: $table.minQty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get applyTo => $composableBuilder(
    column: $table.applyTo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get applyToIds => $composableBuilder(
    column: $table.applyToIds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get startDate => $composableBuilder(
    column: $table.startDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get startTime => $composableBuilder(
    column: $table.startTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get endTime => $composableBuilder(
    column: $table.endTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get applyDays => $composableBuilder(
    column: $table.applyDays,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get maxUses => $composableBuilder(
    column: $table.maxUses,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get maxUsesPerCustomer => $composableBuilder(
    column: $table.maxUsesPerCustomer,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get currentUses => $composableBuilder(
    column: $table.currentUses,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isExclusive => $composableBuilder(
    column: $table.isExclusive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get createdBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PromotionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $PromotionsTable> {
  $$PromotionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get promotionId => $composableBuilder(
    column: $table.promotionId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get promotionCode => $composableBuilder(
    column: $table.promotionCode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get promotionName => $composableBuilder(
    column: $table.promotionName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get promotionType => $composableBuilder(
    column: $table.promotionType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get discountType => $composableBuilder(
    column: $table.discountType,
    builder: (column) => column,
  );

  GeneratedColumn<double> get discountValue => $composableBuilder(
    column: $table.discountValue,
    builder: (column) => column,
  );

  GeneratedColumn<double> get maxDiscountAmount => $composableBuilder(
    column: $table.maxDiscountAmount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get buyQty =>
      $composableBuilder(column: $table.buyQty, builder: (column) => column);

  GeneratedColumn<int> get getQty =>
      $composableBuilder(column: $table.getQty, builder: (column) => column);

  GeneratedColumn<String> get getProductId => $composableBuilder(
    column: $table.getProductId,
    builder: (column) => column,
  );

  GeneratedColumn<double> get minAmount =>
      $composableBuilder(column: $table.minAmount, builder: (column) => column);

  GeneratedColumn<double> get minQty =>
      $composableBuilder(column: $table.minQty, builder: (column) => column);

  GeneratedColumn<String> get applyTo =>
      $composableBuilder(column: $table.applyTo, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get applyToIds => $composableBuilder(
    column: $table.applyToIds,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get startDate =>
      $composableBuilder(column: $table.startDate, builder: (column) => column);

  GeneratedColumn<DateTime> get endDate =>
      $composableBuilder(column: $table.endDate, builder: (column) => column);

  GeneratedColumn<String> get startTime =>
      $composableBuilder(column: $table.startTime, builder: (column) => column);

  GeneratedColumn<String> get endTime =>
      $composableBuilder(column: $table.endTime, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get applyDays =>
      $composableBuilder(column: $table.applyDays, builder: (column) => column);

  GeneratedColumn<int> get maxUses =>
      $composableBuilder(column: $table.maxUses, builder: (column) => column);

  GeneratedColumn<int> get maxUsesPerCustomer => $composableBuilder(
    column: $table.maxUsesPerCustomer,
    builder: (column) => column,
  );

  GeneratedColumn<int> get currentUses => $composableBuilder(
    column: $table.currentUses,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isExclusive => $composableBuilder(
    column: $table.isExclusive,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$UsersTableAnnotationComposer get createdBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> promotionUsagesRefs<T extends Object>(
    Expression<T> Function($$PromotionUsagesTableAnnotationComposer a) f,
  ) {
    final $$PromotionUsagesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.promotionId,
      referencedTable: $db.promotionUsages,
      getReferencedColumn: (t) => t.promotionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionUsagesTableAnnotationComposer(
            $db: $db,
            $table: $db.promotionUsages,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> couponsRefs<T extends Object>(
    Expression<T> Function($$CouponsTableAnnotationComposer a) f,
  ) {
    final $$CouponsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.promotionId,
      referencedTable: $db.coupons,
      getReferencedColumn: (t) => t.promotionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CouponsTableAnnotationComposer(
            $db: $db,
            $table: $db.coupons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$PromotionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PromotionsTable,
          Promotion,
          $$PromotionsTableFilterComposer,
          $$PromotionsTableOrderingComposer,
          $$PromotionsTableAnnotationComposer,
          $$PromotionsTableCreateCompanionBuilder,
          $$PromotionsTableUpdateCompanionBuilder,
          (Promotion, $$PromotionsTableReferences),
          Promotion,
          PrefetchHooks Function({
            bool createdBy,
            bool promotionUsagesRefs,
            bool couponsRefs,
          })
        > {
  $$PromotionsTableTableManager(_$AppDatabase db, $PromotionsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PromotionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PromotionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PromotionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> promotionId = const Value.absent(),
                Value<String> promotionCode = const Value.absent(),
                Value<String> promotionName = const Value.absent(),
                Value<String> promotionType = const Value.absent(),
                Value<String?> discountType = const Value.absent(),
                Value<double> discountValue = const Value.absent(),
                Value<double?> maxDiscountAmount = const Value.absent(),
                Value<int?> buyQty = const Value.absent(),
                Value<int?> getQty = const Value.absent(),
                Value<String?> getProductId = const Value.absent(),
                Value<double> minAmount = const Value.absent(),
                Value<double> minQty = const Value.absent(),
                Value<String> applyTo = const Value.absent(),
                Value<Map<String, dynamic>?> applyToIds = const Value.absent(),
                Value<DateTime> startDate = const Value.absent(),
                Value<DateTime> endDate = const Value.absent(),
                Value<String?> startTime = const Value.absent(),
                Value<String?> endTime = const Value.absent(),
                Value<Map<String, dynamic>?> applyDays = const Value.absent(),
                Value<int?> maxUses = const Value.absent(),
                Value<int?> maxUsesPerCustomer = const Value.absent(),
                Value<int> currentUses = const Value.absent(),
                Value<bool> isExclusive = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<String?> createdBy = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PromotionsCompanion(
                promotionId: promotionId,
                promotionCode: promotionCode,
                promotionName: promotionName,
                promotionType: promotionType,
                discountType: discountType,
                discountValue: discountValue,
                maxDiscountAmount: maxDiscountAmount,
                buyQty: buyQty,
                getQty: getQty,
                getProductId: getProductId,
                minAmount: minAmount,
                minQty: minQty,
                applyTo: applyTo,
                applyToIds: applyToIds,
                startDate: startDate,
                endDate: endDate,
                startTime: startTime,
                endTime: endTime,
                applyDays: applyDays,
                maxUses: maxUses,
                maxUsesPerCustomer: maxUsesPerCustomer,
                currentUses: currentUses,
                isExclusive: isExclusive,
                isActive: isActive,
                createdBy: createdBy,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String promotionId,
                required String promotionCode,
                required String promotionName,
                required String promotionType,
                Value<String?> discountType = const Value.absent(),
                Value<double> discountValue = const Value.absent(),
                Value<double?> maxDiscountAmount = const Value.absent(),
                Value<int?> buyQty = const Value.absent(),
                Value<int?> getQty = const Value.absent(),
                Value<String?> getProductId = const Value.absent(),
                Value<double> minAmount = const Value.absent(),
                Value<double> minQty = const Value.absent(),
                required String applyTo,
                Value<Map<String, dynamic>?> applyToIds = const Value.absent(),
                required DateTime startDate,
                required DateTime endDate,
                Value<String?> startTime = const Value.absent(),
                Value<String?> endTime = const Value.absent(),
                Value<Map<String, dynamic>?> applyDays = const Value.absent(),
                Value<int?> maxUses = const Value.absent(),
                Value<int?> maxUsesPerCustomer = const Value.absent(),
                Value<int> currentUses = const Value.absent(),
                Value<bool> isExclusive = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<String?> createdBy = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PromotionsCompanion.insert(
                promotionId: promotionId,
                promotionCode: promotionCode,
                promotionName: promotionName,
                promotionType: promotionType,
                discountType: discountType,
                discountValue: discountValue,
                maxDiscountAmount: maxDiscountAmount,
                buyQty: buyQty,
                getQty: getQty,
                getProductId: getProductId,
                minAmount: minAmount,
                minQty: minQty,
                applyTo: applyTo,
                applyToIds: applyToIds,
                startDate: startDate,
                endDate: endDate,
                startTime: startTime,
                endTime: endTime,
                applyDays: applyDays,
                maxUses: maxUses,
                maxUsesPerCustomer: maxUsesPerCustomer,
                currentUses: currentUses,
                isExclusive: isExclusive,
                isActive: isActive,
                createdBy: createdBy,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PromotionsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                createdBy = false,
                promotionUsagesRefs = false,
                couponsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (promotionUsagesRefs) db.promotionUsages,
                    if (couponsRefs) db.coupons,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (createdBy) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.createdBy,
                                    referencedTable: $$PromotionsTableReferences
                                        ._createdByTable(db),
                                    referencedColumn:
                                        $$PromotionsTableReferences
                                            ._createdByTable(db)
                                            .userId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (promotionUsagesRefs)
                        await $_getPrefetchedData<
                          Promotion,
                          $PromotionsTable,
                          PromotionUsage
                        >(
                          currentTable: table,
                          referencedTable: $$PromotionsTableReferences
                              ._promotionUsagesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$PromotionsTableReferences(
                                db,
                                table,
                                p0,
                              ).promotionUsagesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.promotionId == item.promotionId,
                              ),
                          typedResults: items,
                        ),
                      if (couponsRefs)
                        await $_getPrefetchedData<
                          Promotion,
                          $PromotionsTable,
                          Coupon
                        >(
                          currentTable: table,
                          referencedTable: $$PromotionsTableReferences
                              ._couponsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$PromotionsTableReferences(
                                db,
                                table,
                                p0,
                              ).couponsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.promotionId == item.promotionId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$PromotionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PromotionsTable,
      Promotion,
      $$PromotionsTableFilterComposer,
      $$PromotionsTableOrderingComposer,
      $$PromotionsTableAnnotationComposer,
      $$PromotionsTableCreateCompanionBuilder,
      $$PromotionsTableUpdateCompanionBuilder,
      (Promotion, $$PromotionsTableReferences),
      Promotion,
      PrefetchHooks Function({
        bool createdBy,
        bool promotionUsagesRefs,
        bool couponsRefs,
      })
    >;
typedef $$PromotionUsagesTableCreateCompanionBuilder =
    PromotionUsagesCompanion Function({
      required String usageId,
      required String promotionId,
      required String orderId,
      Value<String?> customerId,
      required double discountAmount,
      Value<DateTime> usedAt,
      Value<int> rowid,
    });
typedef $$PromotionUsagesTableUpdateCompanionBuilder =
    PromotionUsagesCompanion Function({
      Value<String> usageId,
      Value<String> promotionId,
      Value<String> orderId,
      Value<String?> customerId,
      Value<double> discountAmount,
      Value<DateTime> usedAt,
      Value<int> rowid,
    });

final class $$PromotionUsagesTableReferences
    extends
        BaseReferences<_$AppDatabase, $PromotionUsagesTable, PromotionUsage> {
  $$PromotionUsagesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PromotionsTable _promotionIdTable(_$AppDatabase db) =>
      db.promotions.createAlias(
        $_aliasNameGenerator(
          db.promotionUsages.promotionId,
          db.promotions.promotionId,
        ),
      );

  $$PromotionsTableProcessedTableManager get promotionId {
    final $_column = $_itemColumn<String>('promotion_id')!;

    final manager = $$PromotionsTableTableManager(
      $_db,
      $_db.promotions,
    ).filter((f) => f.promotionId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_promotionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $SalesOrdersTable _orderIdTable(_$AppDatabase db) =>
      db.salesOrders.createAlias(
        $_aliasNameGenerator(
          db.promotionUsages.orderId,
          db.salesOrders.orderId,
        ),
      );

  $$SalesOrdersTableProcessedTableManager get orderId {
    final $_column = $_itemColumn<String>('order_id')!;

    final manager = $$SalesOrdersTableTableManager(
      $_db,
      $_db.salesOrders,
    ).filter((f) => f.orderId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $CustomersTable _customerIdTable(_$AppDatabase db) =>
      db.customers.createAlias(
        $_aliasNameGenerator(
          db.promotionUsages.customerId,
          db.customers.customerId,
        ),
      );

  $$CustomersTableProcessedTableManager? get customerId {
    final $_column = $_itemColumn<String>('customer_id');
    if ($_column == null) return null;
    final manager = $$CustomersTableTableManager(
      $_db,
      $_db.customers,
    ).filter((f) => f.customerId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_customerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$PromotionUsagesTableFilterComposer
    extends Composer<_$AppDatabase, $PromotionUsagesTable> {
  $$PromotionUsagesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get usageId => $composableBuilder(
    column: $table.usageId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get usedAt => $composableBuilder(
    column: $table.usedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$PromotionsTableFilterComposer get promotionId {
    final $$PromotionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.promotionId,
      referencedTable: $db.promotions,
      getReferencedColumn: (t) => t.promotionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionsTableFilterComposer(
            $db: $db,
            $table: $db.promotions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SalesOrdersTableFilterComposer get orderId {
    final $$SalesOrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableFilterComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CustomersTableFilterComposer get customerId {
    final $$CustomersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableFilterComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PromotionUsagesTableOrderingComposer
    extends Composer<_$AppDatabase, $PromotionUsagesTable> {
  $$PromotionUsagesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get usageId => $composableBuilder(
    column: $table.usageId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get usedAt => $composableBuilder(
    column: $table.usedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$PromotionsTableOrderingComposer get promotionId {
    final $$PromotionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.promotionId,
      referencedTable: $db.promotions,
      getReferencedColumn: (t) => t.promotionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionsTableOrderingComposer(
            $db: $db,
            $table: $db.promotions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SalesOrdersTableOrderingComposer get orderId {
    final $$SalesOrdersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableOrderingComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CustomersTableOrderingComposer get customerId {
    final $$CustomersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableOrderingComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PromotionUsagesTableAnnotationComposer
    extends Composer<_$AppDatabase, $PromotionUsagesTable> {
  $$PromotionUsagesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get usageId =>
      $composableBuilder(column: $table.usageId, builder: (column) => column);

  GeneratedColumn<double> get discountAmount => $composableBuilder(
    column: $table.discountAmount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get usedAt =>
      $composableBuilder(column: $table.usedAt, builder: (column) => column);

  $$PromotionsTableAnnotationComposer get promotionId {
    final $$PromotionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.promotionId,
      referencedTable: $db.promotions,
      getReferencedColumn: (t) => t.promotionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionsTableAnnotationComposer(
            $db: $db,
            $table: $db.promotions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SalesOrdersTableAnnotationComposer get orderId {
    final $$SalesOrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.salesOrders,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SalesOrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.salesOrders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CustomersTableAnnotationComposer get customerId {
    final $$CustomersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableAnnotationComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PromotionUsagesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PromotionUsagesTable,
          PromotionUsage,
          $$PromotionUsagesTableFilterComposer,
          $$PromotionUsagesTableOrderingComposer,
          $$PromotionUsagesTableAnnotationComposer,
          $$PromotionUsagesTableCreateCompanionBuilder,
          $$PromotionUsagesTableUpdateCompanionBuilder,
          (PromotionUsage, $$PromotionUsagesTableReferences),
          PromotionUsage,
          PrefetchHooks Function({
            bool promotionId,
            bool orderId,
            bool customerId,
          })
        > {
  $$PromotionUsagesTableTableManager(
    _$AppDatabase db,
    $PromotionUsagesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PromotionUsagesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PromotionUsagesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PromotionUsagesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> usageId = const Value.absent(),
                Value<String> promotionId = const Value.absent(),
                Value<String> orderId = const Value.absent(),
                Value<String?> customerId = const Value.absent(),
                Value<double> discountAmount = const Value.absent(),
                Value<DateTime> usedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PromotionUsagesCompanion(
                usageId: usageId,
                promotionId: promotionId,
                orderId: orderId,
                customerId: customerId,
                discountAmount: discountAmount,
                usedAt: usedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String usageId,
                required String promotionId,
                required String orderId,
                Value<String?> customerId = const Value.absent(),
                required double discountAmount,
                Value<DateTime> usedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PromotionUsagesCompanion.insert(
                usageId: usageId,
                promotionId: promotionId,
                orderId: orderId,
                customerId: customerId,
                discountAmount: discountAmount,
                usedAt: usedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PromotionUsagesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({promotionId = false, orderId = false, customerId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (promotionId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.promotionId,
                                    referencedTable:
                                        $$PromotionUsagesTableReferences
                                            ._promotionIdTable(db),
                                    referencedColumn:
                                        $$PromotionUsagesTableReferences
                                            ._promotionIdTable(db)
                                            .promotionId,
                                  )
                                  as T;
                        }
                        if (orderId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.orderId,
                                    referencedTable:
                                        $$PromotionUsagesTableReferences
                                            ._orderIdTable(db),
                                    referencedColumn:
                                        $$PromotionUsagesTableReferences
                                            ._orderIdTable(db)
                                            .orderId,
                                  )
                                  as T;
                        }
                        if (customerId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.customerId,
                                    referencedTable:
                                        $$PromotionUsagesTableReferences
                                            ._customerIdTable(db),
                                    referencedColumn:
                                        $$PromotionUsagesTableReferences
                                            ._customerIdTable(db)
                                            .customerId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$PromotionUsagesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PromotionUsagesTable,
      PromotionUsage,
      $$PromotionUsagesTableFilterComposer,
      $$PromotionUsagesTableOrderingComposer,
      $$PromotionUsagesTableAnnotationComposer,
      $$PromotionUsagesTableCreateCompanionBuilder,
      $$PromotionUsagesTableUpdateCompanionBuilder,
      (PromotionUsage, $$PromotionUsagesTableReferences),
      PromotionUsage,
      PrefetchHooks Function({bool promotionId, bool orderId, bool customerId})
    >;
typedef $$CouponsTableCreateCompanionBuilder =
    CouponsCompanion Function({
      required String couponId,
      required String couponCode,
      required String promotionId,
      Value<bool> isUsed,
      Value<String?> usedBy,
      Value<DateTime?> usedAt,
      Value<DateTime?> expiresAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$CouponsTableUpdateCompanionBuilder =
    CouponsCompanion Function({
      Value<String> couponId,
      Value<String> couponCode,
      Value<String> promotionId,
      Value<bool> isUsed,
      Value<String?> usedBy,
      Value<DateTime?> usedAt,
      Value<DateTime?> expiresAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$CouponsTableReferences
    extends BaseReferences<_$AppDatabase, $CouponsTable, Coupon> {
  $$CouponsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PromotionsTable _promotionIdTable(_$AppDatabase db) =>
      db.promotions.createAlias(
        $_aliasNameGenerator(db.coupons.promotionId, db.promotions.promotionId),
      );

  $$PromotionsTableProcessedTableManager get promotionId {
    final $_column = $_itemColumn<String>('promotion_id')!;

    final manager = $$PromotionsTableTableManager(
      $_db,
      $_db.promotions,
    ).filter((f) => f.promotionId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_promotionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $CustomersTable _usedByTable(_$AppDatabase db) =>
      db.customers.createAlias(
        $_aliasNameGenerator(db.coupons.usedBy, db.customers.customerId),
      );

  $$CustomersTableProcessedTableManager? get usedBy {
    final $_column = $_itemColumn<String>('used_by');
    if ($_column == null) return null;
    final manager = $$CustomersTableTableManager(
      $_db,
      $_db.customers,
    ).filter((f) => f.customerId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_usedByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$CouponsTableFilterComposer
    extends Composer<_$AppDatabase, $CouponsTable> {
  $$CouponsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get couponId => $composableBuilder(
    column: $table.couponId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get couponCode => $composableBuilder(
    column: $table.couponCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isUsed => $composableBuilder(
    column: $table.isUsed,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get usedAt => $composableBuilder(
    column: $table.usedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$PromotionsTableFilterComposer get promotionId {
    final $$PromotionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.promotionId,
      referencedTable: $db.promotions,
      getReferencedColumn: (t) => t.promotionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionsTableFilterComposer(
            $db: $db,
            $table: $db.promotions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CustomersTableFilterComposer get usedBy {
    final $$CustomersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.usedBy,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableFilterComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CouponsTableOrderingComposer
    extends Composer<_$AppDatabase, $CouponsTable> {
  $$CouponsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get couponId => $composableBuilder(
    column: $table.couponId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get couponCode => $composableBuilder(
    column: $table.couponCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isUsed => $composableBuilder(
    column: $table.isUsed,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get usedAt => $composableBuilder(
    column: $table.usedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$PromotionsTableOrderingComposer get promotionId {
    final $$PromotionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.promotionId,
      referencedTable: $db.promotions,
      getReferencedColumn: (t) => t.promotionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionsTableOrderingComposer(
            $db: $db,
            $table: $db.promotions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CustomersTableOrderingComposer get usedBy {
    final $$CustomersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.usedBy,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableOrderingComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CouponsTableAnnotationComposer
    extends Composer<_$AppDatabase, $CouponsTable> {
  $$CouponsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get couponId =>
      $composableBuilder(column: $table.couponId, builder: (column) => column);

  GeneratedColumn<String> get couponCode => $composableBuilder(
    column: $table.couponCode,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isUsed =>
      $composableBuilder(column: $table.isUsed, builder: (column) => column);

  GeneratedColumn<DateTime> get usedAt =>
      $composableBuilder(column: $table.usedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$PromotionsTableAnnotationComposer get promotionId {
    final $$PromotionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.promotionId,
      referencedTable: $db.promotions,
      getReferencedColumn: (t) => t.promotionId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PromotionsTableAnnotationComposer(
            $db: $db,
            $table: $db.promotions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CustomersTableAnnotationComposer get usedBy {
    final $$CustomersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.usedBy,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableAnnotationComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CouponsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CouponsTable,
          Coupon,
          $$CouponsTableFilterComposer,
          $$CouponsTableOrderingComposer,
          $$CouponsTableAnnotationComposer,
          $$CouponsTableCreateCompanionBuilder,
          $$CouponsTableUpdateCompanionBuilder,
          (Coupon, $$CouponsTableReferences),
          Coupon,
          PrefetchHooks Function({bool promotionId, bool usedBy})
        > {
  $$CouponsTableTableManager(_$AppDatabase db, $CouponsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CouponsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CouponsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CouponsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> couponId = const Value.absent(),
                Value<String> couponCode = const Value.absent(),
                Value<String> promotionId = const Value.absent(),
                Value<bool> isUsed = const Value.absent(),
                Value<String?> usedBy = const Value.absent(),
                Value<DateTime?> usedAt = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CouponsCompanion(
                couponId: couponId,
                couponCode: couponCode,
                promotionId: promotionId,
                isUsed: isUsed,
                usedBy: usedBy,
                usedAt: usedAt,
                expiresAt: expiresAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String couponId,
                required String couponCode,
                required String promotionId,
                Value<bool> isUsed = const Value.absent(),
                Value<String?> usedBy = const Value.absent(),
                Value<DateTime?> usedAt = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CouponsCompanion.insert(
                couponId: couponId,
                couponCode: couponCode,
                promotionId: promotionId,
                isUsed: isUsed,
                usedBy: usedBy,
                usedAt: usedAt,
                expiresAt: expiresAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CouponsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({promotionId = false, usedBy = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (promotionId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.promotionId,
                                referencedTable: $$CouponsTableReferences
                                    ._promotionIdTable(db),
                                referencedColumn: $$CouponsTableReferences
                                    ._promotionIdTable(db)
                                    .promotionId,
                              )
                              as T;
                    }
                    if (usedBy) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.usedBy,
                                referencedTable: $$CouponsTableReferences
                                    ._usedByTable(db),
                                referencedColumn: $$CouponsTableReferences
                                    ._usedByTable(db)
                                    .customerId,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$CouponsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CouponsTable,
      Coupon,
      $$CouponsTableFilterComposer,
      $$CouponsTableOrderingComposer,
      $$CouponsTableAnnotationComposer,
      $$CouponsTableCreateCompanionBuilder,
      $$CouponsTableUpdateCompanionBuilder,
      (Coupon, $$CouponsTableReferences),
      Coupon,
      PrefetchHooks Function({bool promotionId, bool usedBy})
    >;
typedef $$ArInvoicesTableCreateCompanionBuilder =
    ArInvoicesCompanion Function({
      required String invoiceId,
      required String invoiceNo,
      required DateTime invoiceDate,
      Value<DateTime?> dueDate,
      required String customerId,
      required String customerName,
      required double totalAmount,
      Value<double> paidAmount,
      Value<String?> referenceType,
      Value<String?> referenceId,
      Value<String> status,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$ArInvoicesTableUpdateCompanionBuilder =
    ArInvoicesCompanion Function({
      Value<String> invoiceId,
      Value<String> invoiceNo,
      Value<DateTime> invoiceDate,
      Value<DateTime?> dueDate,
      Value<String> customerId,
      Value<String> customerName,
      Value<double> totalAmount,
      Value<double> paidAmount,
      Value<String?> referenceType,
      Value<String?> referenceId,
      Value<String> status,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$ArInvoicesTableReferences
    extends BaseReferences<_$AppDatabase, $ArInvoicesTable, ArInvoice> {
  $$ArInvoicesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $CustomersTable _customerIdTable(_$AppDatabase db) =>
      db.customers.createAlias(
        $_aliasNameGenerator(db.arInvoices.customerId, db.customers.customerId),
      );

  $$CustomersTableProcessedTableManager get customerId {
    final $_column = $_itemColumn<String>('customer_id')!;

    final manager = $$CustomersTableTableManager(
      $_db,
      $_db.customers,
    ).filter((f) => f.customerId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_customerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<
    $ArReceiptAllocationsTable,
    List<ArReceiptAllocation>
  >
  _arReceiptAllocationsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.arReceiptAllocations,
        aliasName: $_aliasNameGenerator(
          db.arInvoices.invoiceId,
          db.arReceiptAllocations.invoiceId,
        ),
      );

  $$ArReceiptAllocationsTableProcessedTableManager
  get arReceiptAllocationsRefs {
    final manager =
        $$ArReceiptAllocationsTableTableManager(
          $_db,
          $_db.arReceiptAllocations,
        ).filter(
          (f) => f.invoiceId.invoiceId.sqlEquals(
            $_itemColumn<String>('invoice_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _arReceiptAllocationsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ArInvoicesTableFilterComposer
    extends Composer<_$AppDatabase, $ArInvoicesTable> {
  $$ArInvoicesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get invoiceId => $composableBuilder(
    column: $table.invoiceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get invoiceNo => $composableBuilder(
    column: $table.invoiceNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get invoiceDate => $composableBuilder(
    column: $table.invoiceDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get dueDate => $composableBuilder(
    column: $table.dueDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get customerName => $composableBuilder(
    column: $table.customerName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get paidAmount => $composableBuilder(
    column: $table.paidAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get referenceType => $composableBuilder(
    column: $table.referenceType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get referenceId => $composableBuilder(
    column: $table.referenceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CustomersTableFilterComposer get customerId {
    final $$CustomersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableFilterComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> arReceiptAllocationsRefs(
    Expression<bool> Function($$ArReceiptAllocationsTableFilterComposer f) f,
  ) {
    final $$ArReceiptAllocationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.invoiceId,
      referencedTable: $db.arReceiptAllocations,
      getReferencedColumn: (t) => t.invoiceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArReceiptAllocationsTableFilterComposer(
            $db: $db,
            $table: $db.arReceiptAllocations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ArInvoicesTableOrderingComposer
    extends Composer<_$AppDatabase, $ArInvoicesTable> {
  $$ArInvoicesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get invoiceId => $composableBuilder(
    column: $table.invoiceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get invoiceNo => $composableBuilder(
    column: $table.invoiceNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get invoiceDate => $composableBuilder(
    column: $table.invoiceDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get dueDate => $composableBuilder(
    column: $table.dueDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get customerName => $composableBuilder(
    column: $table.customerName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get paidAmount => $composableBuilder(
    column: $table.paidAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get referenceType => $composableBuilder(
    column: $table.referenceType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get referenceId => $composableBuilder(
    column: $table.referenceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CustomersTableOrderingComposer get customerId {
    final $$CustomersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableOrderingComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ArInvoicesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ArInvoicesTable> {
  $$ArInvoicesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get invoiceId =>
      $composableBuilder(column: $table.invoiceId, builder: (column) => column);

  GeneratedColumn<String> get invoiceNo =>
      $composableBuilder(column: $table.invoiceNo, builder: (column) => column);

  GeneratedColumn<DateTime> get invoiceDate => $composableBuilder(
    column: $table.invoiceDate,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get dueDate =>
      $composableBuilder(column: $table.dueDate, builder: (column) => column);

  GeneratedColumn<String> get customerName => $composableBuilder(
    column: $table.customerName,
    builder: (column) => column,
  );

  GeneratedColumn<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => column,
  );

  GeneratedColumn<double> get paidAmount => $composableBuilder(
    column: $table.paidAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get referenceType => $composableBuilder(
    column: $table.referenceType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get referenceId => $composableBuilder(
    column: $table.referenceId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$CustomersTableAnnotationComposer get customerId {
    final $$CustomersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableAnnotationComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> arReceiptAllocationsRefs<T extends Object>(
    Expression<T> Function($$ArReceiptAllocationsTableAnnotationComposer a) f,
  ) {
    final $$ArReceiptAllocationsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.invoiceId,
          referencedTable: $db.arReceiptAllocations,
          getReferencedColumn: (t) => t.invoiceId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$ArReceiptAllocationsTableAnnotationComposer(
                $db: $db,
                $table: $db.arReceiptAllocations,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$ArInvoicesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ArInvoicesTable,
          ArInvoice,
          $$ArInvoicesTableFilterComposer,
          $$ArInvoicesTableOrderingComposer,
          $$ArInvoicesTableAnnotationComposer,
          $$ArInvoicesTableCreateCompanionBuilder,
          $$ArInvoicesTableUpdateCompanionBuilder,
          (ArInvoice, $$ArInvoicesTableReferences),
          ArInvoice,
          PrefetchHooks Function({
            bool customerId,
            bool arReceiptAllocationsRefs,
          })
        > {
  $$ArInvoicesTableTableManager(_$AppDatabase db, $ArInvoicesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ArInvoicesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ArInvoicesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ArInvoicesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> invoiceId = const Value.absent(),
                Value<String> invoiceNo = const Value.absent(),
                Value<DateTime> invoiceDate = const Value.absent(),
                Value<DateTime?> dueDate = const Value.absent(),
                Value<String> customerId = const Value.absent(),
                Value<String> customerName = const Value.absent(),
                Value<double> totalAmount = const Value.absent(),
                Value<double> paidAmount = const Value.absent(),
                Value<String?> referenceType = const Value.absent(),
                Value<String?> referenceId = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ArInvoicesCompanion(
                invoiceId: invoiceId,
                invoiceNo: invoiceNo,
                invoiceDate: invoiceDate,
                dueDate: dueDate,
                customerId: customerId,
                customerName: customerName,
                totalAmount: totalAmount,
                paidAmount: paidAmount,
                referenceType: referenceType,
                referenceId: referenceId,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String invoiceId,
                required String invoiceNo,
                required DateTime invoiceDate,
                Value<DateTime?> dueDate = const Value.absent(),
                required String customerId,
                required String customerName,
                required double totalAmount,
                Value<double> paidAmount = const Value.absent(),
                Value<String?> referenceType = const Value.absent(),
                Value<String?> referenceId = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ArInvoicesCompanion.insert(
                invoiceId: invoiceId,
                invoiceNo: invoiceNo,
                invoiceDate: invoiceDate,
                dueDate: dueDate,
                customerId: customerId,
                customerName: customerName,
                totalAmount: totalAmount,
                paidAmount: paidAmount,
                referenceType: referenceType,
                referenceId: referenceId,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ArInvoicesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({customerId = false, arReceiptAllocationsRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (arReceiptAllocationsRefs) db.arReceiptAllocations,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (customerId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.customerId,
                                    referencedTable: $$ArInvoicesTableReferences
                                        ._customerIdTable(db),
                                    referencedColumn:
                                        $$ArInvoicesTableReferences
                                            ._customerIdTable(db)
                                            .customerId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (arReceiptAllocationsRefs)
                        await $_getPrefetchedData<
                          ArInvoice,
                          $ArInvoicesTable,
                          ArReceiptAllocation
                        >(
                          currentTable: table,
                          referencedTable: $$ArInvoicesTableReferences
                              ._arReceiptAllocationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ArInvoicesTableReferences(
                                db,
                                table,
                                p0,
                              ).arReceiptAllocationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.invoiceId == item.invoiceId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ArInvoicesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ArInvoicesTable,
      ArInvoice,
      $$ArInvoicesTableFilterComposer,
      $$ArInvoicesTableOrderingComposer,
      $$ArInvoicesTableAnnotationComposer,
      $$ArInvoicesTableCreateCompanionBuilder,
      $$ArInvoicesTableUpdateCompanionBuilder,
      (ArInvoice, $$ArInvoicesTableReferences),
      ArInvoice,
      PrefetchHooks Function({bool customerId, bool arReceiptAllocationsRefs})
    >;
typedef $$ArReceiptsTableCreateCompanionBuilder =
    ArReceiptsCompanion Function({
      required String receiptId,
      required String receiptNo,
      required DateTime receiptDate,
      required String customerId,
      required double totalAmount,
      Value<String> paymentMethod,
      Value<String?> bankName,
      Value<String?> chequeNo,
      Value<DateTime?> chequeDate,
      Value<String?> transferRef,
      required String userId,
      Value<String?> remark,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$ArReceiptsTableUpdateCompanionBuilder =
    ArReceiptsCompanion Function({
      Value<String> receiptId,
      Value<String> receiptNo,
      Value<DateTime> receiptDate,
      Value<String> customerId,
      Value<double> totalAmount,
      Value<String> paymentMethod,
      Value<String?> bankName,
      Value<String?> chequeNo,
      Value<DateTime?> chequeDate,
      Value<String?> transferRef,
      Value<String> userId,
      Value<String?> remark,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ArReceiptsTableReferences
    extends BaseReferences<_$AppDatabase, $ArReceiptsTable, ArReceipt> {
  $$ArReceiptsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $CustomersTable _customerIdTable(_$AppDatabase db) =>
      db.customers.createAlias(
        $_aliasNameGenerator(db.arReceipts.customerId, db.customers.customerId),
      );

  $$CustomersTableProcessedTableManager get customerId {
    final $_column = $_itemColumn<String>('customer_id')!;

    final manager = $$CustomersTableTableManager(
      $_db,
      $_db.customers,
    ).filter((f) => f.customerId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_customerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.arReceipts.userId, db.users.userId),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.userId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<
    $ArReceiptAllocationsTable,
    List<ArReceiptAllocation>
  >
  _arReceiptAllocationsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.arReceiptAllocations,
        aliasName: $_aliasNameGenerator(
          db.arReceipts.receiptId,
          db.arReceiptAllocations.receiptId,
        ),
      );

  $$ArReceiptAllocationsTableProcessedTableManager
  get arReceiptAllocationsRefs {
    final manager =
        $$ArReceiptAllocationsTableTableManager(
          $_db,
          $_db.arReceiptAllocations,
        ).filter(
          (f) => f.receiptId.receiptId.sqlEquals(
            $_itemColumn<String>('receipt_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _arReceiptAllocationsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ArReceiptsTableFilterComposer
    extends Composer<_$AppDatabase, $ArReceiptsTable> {
  $$ArReceiptsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get receiptId => $composableBuilder(
    column: $table.receiptId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get receiptNo => $composableBuilder(
    column: $table.receiptNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get receiptDate => $composableBuilder(
    column: $table.receiptDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bankName => $composableBuilder(
    column: $table.bankName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get chequeNo => $composableBuilder(
    column: $table.chequeNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get chequeDate => $composableBuilder(
    column: $table.chequeDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get transferRef => $composableBuilder(
    column: $table.transferRef,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get remark => $composableBuilder(
    column: $table.remark,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CustomersTableFilterComposer get customerId {
    final $$CustomersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableFilterComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> arReceiptAllocationsRefs(
    Expression<bool> Function($$ArReceiptAllocationsTableFilterComposer f) f,
  ) {
    final $$ArReceiptAllocationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiptId,
      referencedTable: $db.arReceiptAllocations,
      getReferencedColumn: (t) => t.receiptId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArReceiptAllocationsTableFilterComposer(
            $db: $db,
            $table: $db.arReceiptAllocations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ArReceiptsTableOrderingComposer
    extends Composer<_$AppDatabase, $ArReceiptsTable> {
  $$ArReceiptsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get receiptId => $composableBuilder(
    column: $table.receiptId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get receiptNo => $composableBuilder(
    column: $table.receiptNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get receiptDate => $composableBuilder(
    column: $table.receiptDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bankName => $composableBuilder(
    column: $table.bankName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get chequeNo => $composableBuilder(
    column: $table.chequeNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get chequeDate => $composableBuilder(
    column: $table.chequeDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get transferRef => $composableBuilder(
    column: $table.transferRef,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get remark => $composableBuilder(
    column: $table.remark,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CustomersTableOrderingComposer get customerId {
    final $$CustomersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableOrderingComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ArReceiptsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ArReceiptsTable> {
  $$ArReceiptsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get receiptId =>
      $composableBuilder(column: $table.receiptId, builder: (column) => column);

  GeneratedColumn<String> get receiptNo =>
      $composableBuilder(column: $table.receiptNo, builder: (column) => column);

  GeneratedColumn<DateTime> get receiptDate => $composableBuilder(
    column: $table.receiptDate,
    builder: (column) => column,
  );

  GeneratedColumn<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bankName =>
      $composableBuilder(column: $table.bankName, builder: (column) => column);

  GeneratedColumn<String> get chequeNo =>
      $composableBuilder(column: $table.chequeNo, builder: (column) => column);

  GeneratedColumn<DateTime> get chequeDate => $composableBuilder(
    column: $table.chequeDate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get transferRef => $composableBuilder(
    column: $table.transferRef,
    builder: (column) => column,
  );

  GeneratedColumn<String> get remark =>
      $composableBuilder(column: $table.remark, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$CustomersTableAnnotationComposer get customerId {
    final $$CustomersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableAnnotationComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> arReceiptAllocationsRefs<T extends Object>(
    Expression<T> Function($$ArReceiptAllocationsTableAnnotationComposer a) f,
  ) {
    final $$ArReceiptAllocationsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.receiptId,
          referencedTable: $db.arReceiptAllocations,
          getReferencedColumn: (t) => t.receiptId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$ArReceiptAllocationsTableAnnotationComposer(
                $db: $db,
                $table: $db.arReceiptAllocations,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$ArReceiptsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ArReceiptsTable,
          ArReceipt,
          $$ArReceiptsTableFilterComposer,
          $$ArReceiptsTableOrderingComposer,
          $$ArReceiptsTableAnnotationComposer,
          $$ArReceiptsTableCreateCompanionBuilder,
          $$ArReceiptsTableUpdateCompanionBuilder,
          (ArReceipt, $$ArReceiptsTableReferences),
          ArReceipt,
          PrefetchHooks Function({
            bool customerId,
            bool userId,
            bool arReceiptAllocationsRefs,
          })
        > {
  $$ArReceiptsTableTableManager(_$AppDatabase db, $ArReceiptsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ArReceiptsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ArReceiptsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ArReceiptsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> receiptId = const Value.absent(),
                Value<String> receiptNo = const Value.absent(),
                Value<DateTime> receiptDate = const Value.absent(),
                Value<String> customerId = const Value.absent(),
                Value<double> totalAmount = const Value.absent(),
                Value<String> paymentMethod = const Value.absent(),
                Value<String?> bankName = const Value.absent(),
                Value<String?> chequeNo = const Value.absent(),
                Value<DateTime?> chequeDate = const Value.absent(),
                Value<String?> transferRef = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> remark = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ArReceiptsCompanion(
                receiptId: receiptId,
                receiptNo: receiptNo,
                receiptDate: receiptDate,
                customerId: customerId,
                totalAmount: totalAmount,
                paymentMethod: paymentMethod,
                bankName: bankName,
                chequeNo: chequeNo,
                chequeDate: chequeDate,
                transferRef: transferRef,
                userId: userId,
                remark: remark,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String receiptId,
                required String receiptNo,
                required DateTime receiptDate,
                required String customerId,
                required double totalAmount,
                Value<String> paymentMethod = const Value.absent(),
                Value<String?> bankName = const Value.absent(),
                Value<String?> chequeNo = const Value.absent(),
                Value<DateTime?> chequeDate = const Value.absent(),
                Value<String?> transferRef = const Value.absent(),
                required String userId,
                Value<String?> remark = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ArReceiptsCompanion.insert(
                receiptId: receiptId,
                receiptNo: receiptNo,
                receiptDate: receiptDate,
                customerId: customerId,
                totalAmount: totalAmount,
                paymentMethod: paymentMethod,
                bankName: bankName,
                chequeNo: chequeNo,
                chequeDate: chequeDate,
                transferRef: transferRef,
                userId: userId,
                remark: remark,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ArReceiptsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                customerId = false,
                userId = false,
                arReceiptAllocationsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (arReceiptAllocationsRefs) db.arReceiptAllocations,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (customerId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.customerId,
                                    referencedTable: $$ArReceiptsTableReferences
                                        ._customerIdTable(db),
                                    referencedColumn:
                                        $$ArReceiptsTableReferences
                                            ._customerIdTable(db)
                                            .customerId,
                                  )
                                  as T;
                        }
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable: $$ArReceiptsTableReferences
                                        ._userIdTable(db),
                                    referencedColumn:
                                        $$ArReceiptsTableReferences
                                            ._userIdTable(db)
                                            .userId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (arReceiptAllocationsRefs)
                        await $_getPrefetchedData<
                          ArReceipt,
                          $ArReceiptsTable,
                          ArReceiptAllocation
                        >(
                          currentTable: table,
                          referencedTable: $$ArReceiptsTableReferences
                              ._arReceiptAllocationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ArReceiptsTableReferences(
                                db,
                                table,
                                p0,
                              ).arReceiptAllocationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.receiptId == item.receiptId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ArReceiptsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ArReceiptsTable,
      ArReceipt,
      $$ArReceiptsTableFilterComposer,
      $$ArReceiptsTableOrderingComposer,
      $$ArReceiptsTableAnnotationComposer,
      $$ArReceiptsTableCreateCompanionBuilder,
      $$ArReceiptsTableUpdateCompanionBuilder,
      (ArReceipt, $$ArReceiptsTableReferences),
      ArReceipt,
      PrefetchHooks Function({
        bool customerId,
        bool userId,
        bool arReceiptAllocationsRefs,
      })
    >;
typedef $$ArReceiptAllocationsTableCreateCompanionBuilder =
    ArReceiptAllocationsCompanion Function({
      required String allocationId,
      required String receiptId,
      required String invoiceId,
      required double allocatedAmount,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$ArReceiptAllocationsTableUpdateCompanionBuilder =
    ArReceiptAllocationsCompanion Function({
      Value<String> allocationId,
      Value<String> receiptId,
      Value<String> invoiceId,
      Value<double> allocatedAmount,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ArReceiptAllocationsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $ArReceiptAllocationsTable,
          ArReceiptAllocation
        > {
  $$ArReceiptAllocationsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ArReceiptsTable _receiptIdTable(_$AppDatabase db) =>
      db.arReceipts.createAlias(
        $_aliasNameGenerator(
          db.arReceiptAllocations.receiptId,
          db.arReceipts.receiptId,
        ),
      );

  $$ArReceiptsTableProcessedTableManager get receiptId {
    final $_column = $_itemColumn<String>('receipt_id')!;

    final manager = $$ArReceiptsTableTableManager(
      $_db,
      $_db.arReceipts,
    ).filter((f) => f.receiptId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_receiptIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ArInvoicesTable _invoiceIdTable(_$AppDatabase db) =>
      db.arInvoices.createAlias(
        $_aliasNameGenerator(
          db.arReceiptAllocations.invoiceId,
          db.arInvoices.invoiceId,
        ),
      );

  $$ArInvoicesTableProcessedTableManager get invoiceId {
    final $_column = $_itemColumn<String>('invoice_id')!;

    final manager = $$ArInvoicesTableTableManager(
      $_db,
      $_db.arInvoices,
    ).filter((f) => f.invoiceId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_invoiceIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ArReceiptAllocationsTableFilterComposer
    extends Composer<_$AppDatabase, $ArReceiptAllocationsTable> {
  $$ArReceiptAllocationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get allocationId => $composableBuilder(
    column: $table.allocationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get allocatedAmount => $composableBuilder(
    column: $table.allocatedAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ArReceiptsTableFilterComposer get receiptId {
    final $$ArReceiptsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiptId,
      referencedTable: $db.arReceipts,
      getReferencedColumn: (t) => t.receiptId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArReceiptsTableFilterComposer(
            $db: $db,
            $table: $db.arReceipts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ArInvoicesTableFilterComposer get invoiceId {
    final $$ArInvoicesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.invoiceId,
      referencedTable: $db.arInvoices,
      getReferencedColumn: (t) => t.invoiceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArInvoicesTableFilterComposer(
            $db: $db,
            $table: $db.arInvoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ArReceiptAllocationsTableOrderingComposer
    extends Composer<_$AppDatabase, $ArReceiptAllocationsTable> {
  $$ArReceiptAllocationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get allocationId => $composableBuilder(
    column: $table.allocationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get allocatedAmount => $composableBuilder(
    column: $table.allocatedAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ArReceiptsTableOrderingComposer get receiptId {
    final $$ArReceiptsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiptId,
      referencedTable: $db.arReceipts,
      getReferencedColumn: (t) => t.receiptId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArReceiptsTableOrderingComposer(
            $db: $db,
            $table: $db.arReceipts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ArInvoicesTableOrderingComposer get invoiceId {
    final $$ArInvoicesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.invoiceId,
      referencedTable: $db.arInvoices,
      getReferencedColumn: (t) => t.invoiceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArInvoicesTableOrderingComposer(
            $db: $db,
            $table: $db.arInvoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ArReceiptAllocationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ArReceiptAllocationsTable> {
  $$ArReceiptAllocationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get allocationId => $composableBuilder(
    column: $table.allocationId,
    builder: (column) => column,
  );

  GeneratedColumn<double> get allocatedAmount => $composableBuilder(
    column: $table.allocatedAmount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$ArReceiptsTableAnnotationComposer get receiptId {
    final $$ArReceiptsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiptId,
      referencedTable: $db.arReceipts,
      getReferencedColumn: (t) => t.receiptId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArReceiptsTableAnnotationComposer(
            $db: $db,
            $table: $db.arReceipts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ArInvoicesTableAnnotationComposer get invoiceId {
    final $$ArInvoicesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.invoiceId,
      referencedTable: $db.arInvoices,
      getReferencedColumn: (t) => t.invoiceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ArInvoicesTableAnnotationComposer(
            $db: $db,
            $table: $db.arInvoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ArReceiptAllocationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ArReceiptAllocationsTable,
          ArReceiptAllocation,
          $$ArReceiptAllocationsTableFilterComposer,
          $$ArReceiptAllocationsTableOrderingComposer,
          $$ArReceiptAllocationsTableAnnotationComposer,
          $$ArReceiptAllocationsTableCreateCompanionBuilder,
          $$ArReceiptAllocationsTableUpdateCompanionBuilder,
          (ArReceiptAllocation, $$ArReceiptAllocationsTableReferences),
          ArReceiptAllocation,
          PrefetchHooks Function({bool receiptId, bool invoiceId})
        > {
  $$ArReceiptAllocationsTableTableManager(
    _$AppDatabase db,
    $ArReceiptAllocationsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ArReceiptAllocationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ArReceiptAllocationsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$ArReceiptAllocationsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> allocationId = const Value.absent(),
                Value<String> receiptId = const Value.absent(),
                Value<String> invoiceId = const Value.absent(),
                Value<double> allocatedAmount = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ArReceiptAllocationsCompanion(
                allocationId: allocationId,
                receiptId: receiptId,
                invoiceId: invoiceId,
                allocatedAmount: allocatedAmount,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String allocationId,
                required String receiptId,
                required String invoiceId,
                required double allocatedAmount,
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ArReceiptAllocationsCompanion.insert(
                allocationId: allocationId,
                receiptId: receiptId,
                invoiceId: invoiceId,
                allocatedAmount: allocatedAmount,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ArReceiptAllocationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({receiptId = false, invoiceId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (receiptId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.receiptId,
                                referencedTable:
                                    $$ArReceiptAllocationsTableReferences
                                        ._receiptIdTable(db),
                                referencedColumn:
                                    $$ArReceiptAllocationsTableReferences
                                        ._receiptIdTable(db)
                                        .receiptId,
                              )
                              as T;
                    }
                    if (invoiceId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.invoiceId,
                                referencedTable:
                                    $$ArReceiptAllocationsTableReferences
                                        ._invoiceIdTable(db),
                                referencedColumn:
                                    $$ArReceiptAllocationsTableReferences
                                        ._invoiceIdTable(db)
                                        .invoiceId,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ArReceiptAllocationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ArReceiptAllocationsTable,
      ArReceiptAllocation,
      $$ArReceiptAllocationsTableFilterComposer,
      $$ArReceiptAllocationsTableOrderingComposer,
      $$ArReceiptAllocationsTableAnnotationComposer,
      $$ArReceiptAllocationsTableCreateCompanionBuilder,
      $$ArReceiptAllocationsTableUpdateCompanionBuilder,
      (ArReceiptAllocation, $$ArReceiptAllocationsTableReferences),
      ArReceiptAllocation,
      PrefetchHooks Function({bool receiptId, bool invoiceId})
    >;
typedef $$ApInvoicesTableCreateCompanionBuilder =
    ApInvoicesCompanion Function({
      required String invoiceId,
      required String invoiceNo,
      required DateTime invoiceDate,
      Value<DateTime?> dueDate,
      required String supplierId,
      required String supplierName,
      required double totalAmount,
      Value<double> paidAmount,
      Value<String?> referenceType,
      Value<String?> referenceId,
      Value<String> status,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$ApInvoicesTableUpdateCompanionBuilder =
    ApInvoicesCompanion Function({
      Value<String> invoiceId,
      Value<String> invoiceNo,
      Value<DateTime> invoiceDate,
      Value<DateTime?> dueDate,
      Value<String> supplierId,
      Value<String> supplierName,
      Value<double> totalAmount,
      Value<double> paidAmount,
      Value<String?> referenceType,
      Value<String?> referenceId,
      Value<String> status,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$ApInvoicesTableReferences
    extends BaseReferences<_$AppDatabase, $ApInvoicesTable, ApInvoice> {
  $$ApInvoicesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $SuppliersTable _supplierIdTable(_$AppDatabase db) =>
      db.suppliers.createAlias(
        $_aliasNameGenerator(db.apInvoices.supplierId, db.suppliers.supplierId),
      );

  $$SuppliersTableProcessedTableManager get supplierId {
    final $_column = $_itemColumn<String>('supplier_id')!;

    final manager = $$SuppliersTableTableManager(
      $_db,
      $_db.suppliers,
    ).filter((f) => f.supplierId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_supplierIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<
    $ApPaymentAllocationsTable,
    List<ApPaymentAllocation>
  >
  _apPaymentAllocationsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.apPaymentAllocations,
        aliasName: $_aliasNameGenerator(
          db.apInvoices.invoiceId,
          db.apPaymentAllocations.invoiceId,
        ),
      );

  $$ApPaymentAllocationsTableProcessedTableManager
  get apPaymentAllocationsRefs {
    final manager =
        $$ApPaymentAllocationsTableTableManager(
          $_db,
          $_db.apPaymentAllocations,
        ).filter(
          (f) => f.invoiceId.invoiceId.sqlEquals(
            $_itemColumn<String>('invoice_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _apPaymentAllocationsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ApInvoicesTableFilterComposer
    extends Composer<_$AppDatabase, $ApInvoicesTable> {
  $$ApInvoicesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get invoiceId => $composableBuilder(
    column: $table.invoiceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get invoiceNo => $composableBuilder(
    column: $table.invoiceNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get invoiceDate => $composableBuilder(
    column: $table.invoiceDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get dueDate => $composableBuilder(
    column: $table.dueDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get supplierName => $composableBuilder(
    column: $table.supplierName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get paidAmount => $composableBuilder(
    column: $table.paidAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get referenceType => $composableBuilder(
    column: $table.referenceType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get referenceId => $composableBuilder(
    column: $table.referenceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$SuppliersTableFilterComposer get supplierId {
    final $$SuppliersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.suppliers,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SuppliersTableFilterComposer(
            $db: $db,
            $table: $db.suppliers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> apPaymentAllocationsRefs(
    Expression<bool> Function($$ApPaymentAllocationsTableFilterComposer f) f,
  ) {
    final $$ApPaymentAllocationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.invoiceId,
      referencedTable: $db.apPaymentAllocations,
      getReferencedColumn: (t) => t.invoiceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApPaymentAllocationsTableFilterComposer(
            $db: $db,
            $table: $db.apPaymentAllocations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ApInvoicesTableOrderingComposer
    extends Composer<_$AppDatabase, $ApInvoicesTable> {
  $$ApInvoicesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get invoiceId => $composableBuilder(
    column: $table.invoiceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get invoiceNo => $composableBuilder(
    column: $table.invoiceNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get invoiceDate => $composableBuilder(
    column: $table.invoiceDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get dueDate => $composableBuilder(
    column: $table.dueDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get supplierName => $composableBuilder(
    column: $table.supplierName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get paidAmount => $composableBuilder(
    column: $table.paidAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get referenceType => $composableBuilder(
    column: $table.referenceType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get referenceId => $composableBuilder(
    column: $table.referenceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$SuppliersTableOrderingComposer get supplierId {
    final $$SuppliersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.suppliers,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SuppliersTableOrderingComposer(
            $db: $db,
            $table: $db.suppliers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ApInvoicesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ApInvoicesTable> {
  $$ApInvoicesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get invoiceId =>
      $composableBuilder(column: $table.invoiceId, builder: (column) => column);

  GeneratedColumn<String> get invoiceNo =>
      $composableBuilder(column: $table.invoiceNo, builder: (column) => column);

  GeneratedColumn<DateTime> get invoiceDate => $composableBuilder(
    column: $table.invoiceDate,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get dueDate =>
      $composableBuilder(column: $table.dueDate, builder: (column) => column);

  GeneratedColumn<String> get supplierName => $composableBuilder(
    column: $table.supplierName,
    builder: (column) => column,
  );

  GeneratedColumn<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => column,
  );

  GeneratedColumn<double> get paidAmount => $composableBuilder(
    column: $table.paidAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get referenceType => $composableBuilder(
    column: $table.referenceType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get referenceId => $composableBuilder(
    column: $table.referenceId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$SuppliersTableAnnotationComposer get supplierId {
    final $$SuppliersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.suppliers,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SuppliersTableAnnotationComposer(
            $db: $db,
            $table: $db.suppliers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> apPaymentAllocationsRefs<T extends Object>(
    Expression<T> Function($$ApPaymentAllocationsTableAnnotationComposer a) f,
  ) {
    final $$ApPaymentAllocationsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.invoiceId,
          referencedTable: $db.apPaymentAllocations,
          getReferencedColumn: (t) => t.invoiceId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$ApPaymentAllocationsTableAnnotationComposer(
                $db: $db,
                $table: $db.apPaymentAllocations,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$ApInvoicesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ApInvoicesTable,
          ApInvoice,
          $$ApInvoicesTableFilterComposer,
          $$ApInvoicesTableOrderingComposer,
          $$ApInvoicesTableAnnotationComposer,
          $$ApInvoicesTableCreateCompanionBuilder,
          $$ApInvoicesTableUpdateCompanionBuilder,
          (ApInvoice, $$ApInvoicesTableReferences),
          ApInvoice,
          PrefetchHooks Function({
            bool supplierId,
            bool apPaymentAllocationsRefs,
          })
        > {
  $$ApInvoicesTableTableManager(_$AppDatabase db, $ApInvoicesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ApInvoicesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ApInvoicesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ApInvoicesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> invoiceId = const Value.absent(),
                Value<String> invoiceNo = const Value.absent(),
                Value<DateTime> invoiceDate = const Value.absent(),
                Value<DateTime?> dueDate = const Value.absent(),
                Value<String> supplierId = const Value.absent(),
                Value<String> supplierName = const Value.absent(),
                Value<double> totalAmount = const Value.absent(),
                Value<double> paidAmount = const Value.absent(),
                Value<String?> referenceType = const Value.absent(),
                Value<String?> referenceId = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ApInvoicesCompanion(
                invoiceId: invoiceId,
                invoiceNo: invoiceNo,
                invoiceDate: invoiceDate,
                dueDate: dueDate,
                supplierId: supplierId,
                supplierName: supplierName,
                totalAmount: totalAmount,
                paidAmount: paidAmount,
                referenceType: referenceType,
                referenceId: referenceId,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String invoiceId,
                required String invoiceNo,
                required DateTime invoiceDate,
                Value<DateTime?> dueDate = const Value.absent(),
                required String supplierId,
                required String supplierName,
                required double totalAmount,
                Value<double> paidAmount = const Value.absent(),
                Value<String?> referenceType = const Value.absent(),
                Value<String?> referenceId = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ApInvoicesCompanion.insert(
                invoiceId: invoiceId,
                invoiceNo: invoiceNo,
                invoiceDate: invoiceDate,
                dueDate: dueDate,
                supplierId: supplierId,
                supplierName: supplierName,
                totalAmount: totalAmount,
                paidAmount: paidAmount,
                referenceType: referenceType,
                referenceId: referenceId,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ApInvoicesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({supplierId = false, apPaymentAllocationsRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (apPaymentAllocationsRefs) db.apPaymentAllocations,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (supplierId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.supplierId,
                                    referencedTable: $$ApInvoicesTableReferences
                                        ._supplierIdTable(db),
                                    referencedColumn:
                                        $$ApInvoicesTableReferences
                                            ._supplierIdTable(db)
                                            .supplierId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (apPaymentAllocationsRefs)
                        await $_getPrefetchedData<
                          ApInvoice,
                          $ApInvoicesTable,
                          ApPaymentAllocation
                        >(
                          currentTable: table,
                          referencedTable: $$ApInvoicesTableReferences
                              ._apPaymentAllocationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ApInvoicesTableReferences(
                                db,
                                table,
                                p0,
                              ).apPaymentAllocationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.invoiceId == item.invoiceId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ApInvoicesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ApInvoicesTable,
      ApInvoice,
      $$ApInvoicesTableFilterComposer,
      $$ApInvoicesTableOrderingComposer,
      $$ApInvoicesTableAnnotationComposer,
      $$ApInvoicesTableCreateCompanionBuilder,
      $$ApInvoicesTableUpdateCompanionBuilder,
      (ApInvoice, $$ApInvoicesTableReferences),
      ApInvoice,
      PrefetchHooks Function({bool supplierId, bool apPaymentAllocationsRefs})
    >;
typedef $$ApPaymentsTableCreateCompanionBuilder =
    ApPaymentsCompanion Function({
      required String paymentId,
      required String paymentNo,
      required DateTime paymentDate,
      required String supplierId,
      required double totalAmount,
      Value<String> paymentMethod,
      Value<String?> bankName,
      Value<String?> chequeNo,
      Value<DateTime?> chequeDate,
      Value<String?> transferRef,
      required String userId,
      Value<String?> remark,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$ApPaymentsTableUpdateCompanionBuilder =
    ApPaymentsCompanion Function({
      Value<String> paymentId,
      Value<String> paymentNo,
      Value<DateTime> paymentDate,
      Value<String> supplierId,
      Value<double> totalAmount,
      Value<String> paymentMethod,
      Value<String?> bankName,
      Value<String?> chequeNo,
      Value<DateTime?> chequeDate,
      Value<String?> transferRef,
      Value<String> userId,
      Value<String?> remark,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ApPaymentsTableReferences
    extends BaseReferences<_$AppDatabase, $ApPaymentsTable, ApPayment> {
  $$ApPaymentsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $SuppliersTable _supplierIdTable(_$AppDatabase db) =>
      db.suppliers.createAlias(
        $_aliasNameGenerator(db.apPayments.supplierId, db.suppliers.supplierId),
      );

  $$SuppliersTableProcessedTableManager get supplierId {
    final $_column = $_itemColumn<String>('supplier_id')!;

    final manager = $$SuppliersTableTableManager(
      $_db,
      $_db.suppliers,
    ).filter((f) => f.supplierId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_supplierIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.apPayments.userId, db.users.userId),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.userId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<
    $ApPaymentAllocationsTable,
    List<ApPaymentAllocation>
  >
  _apPaymentAllocationsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.apPaymentAllocations,
        aliasName: $_aliasNameGenerator(
          db.apPayments.paymentId,
          db.apPaymentAllocations.paymentId,
        ),
      );

  $$ApPaymentAllocationsTableProcessedTableManager
  get apPaymentAllocationsRefs {
    final manager =
        $$ApPaymentAllocationsTableTableManager(
          $_db,
          $_db.apPaymentAllocations,
        ).filter(
          (f) => f.paymentId.paymentId.sqlEquals(
            $_itemColumn<String>('payment_id')!,
          ),
        );

    final cache = $_typedResult.readTableOrNull(
      _apPaymentAllocationsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ApPaymentsTableFilterComposer
    extends Composer<_$AppDatabase, $ApPaymentsTable> {
  $$ApPaymentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get paymentId => $composableBuilder(
    column: $table.paymentId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get paymentNo => $composableBuilder(
    column: $table.paymentNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get paymentDate => $composableBuilder(
    column: $table.paymentDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bankName => $composableBuilder(
    column: $table.bankName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get chequeNo => $composableBuilder(
    column: $table.chequeNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get chequeDate => $composableBuilder(
    column: $table.chequeDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get transferRef => $composableBuilder(
    column: $table.transferRef,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get remark => $composableBuilder(
    column: $table.remark,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$SuppliersTableFilterComposer get supplierId {
    final $$SuppliersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.suppliers,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SuppliersTableFilterComposer(
            $db: $db,
            $table: $db.suppliers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> apPaymentAllocationsRefs(
    Expression<bool> Function($$ApPaymentAllocationsTableFilterComposer f) f,
  ) {
    final $$ApPaymentAllocationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.paymentId,
      referencedTable: $db.apPaymentAllocations,
      getReferencedColumn: (t) => t.paymentId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApPaymentAllocationsTableFilterComposer(
            $db: $db,
            $table: $db.apPaymentAllocations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ApPaymentsTableOrderingComposer
    extends Composer<_$AppDatabase, $ApPaymentsTable> {
  $$ApPaymentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get paymentId => $composableBuilder(
    column: $table.paymentId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get paymentNo => $composableBuilder(
    column: $table.paymentNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get paymentDate => $composableBuilder(
    column: $table.paymentDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bankName => $composableBuilder(
    column: $table.bankName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get chequeNo => $composableBuilder(
    column: $table.chequeNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get chequeDate => $composableBuilder(
    column: $table.chequeDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get transferRef => $composableBuilder(
    column: $table.transferRef,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get remark => $composableBuilder(
    column: $table.remark,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$SuppliersTableOrderingComposer get supplierId {
    final $$SuppliersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.suppliers,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SuppliersTableOrderingComposer(
            $db: $db,
            $table: $db.suppliers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ApPaymentsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ApPaymentsTable> {
  $$ApPaymentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get paymentId =>
      $composableBuilder(column: $table.paymentId, builder: (column) => column);

  GeneratedColumn<String> get paymentNo =>
      $composableBuilder(column: $table.paymentNo, builder: (column) => column);

  GeneratedColumn<DateTime> get paymentDate => $composableBuilder(
    column: $table.paymentDate,
    builder: (column) => column,
  );

  GeneratedColumn<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bankName =>
      $composableBuilder(column: $table.bankName, builder: (column) => column);

  GeneratedColumn<String> get chequeNo =>
      $composableBuilder(column: $table.chequeNo, builder: (column) => column);

  GeneratedColumn<DateTime> get chequeDate => $composableBuilder(
    column: $table.chequeDate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get transferRef => $composableBuilder(
    column: $table.transferRef,
    builder: (column) => column,
  );

  GeneratedColumn<String> get remark =>
      $composableBuilder(column: $table.remark, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$SuppliersTableAnnotationComposer get supplierId {
    final $$SuppliersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.supplierId,
      referencedTable: $db.suppliers,
      getReferencedColumn: (t) => t.supplierId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SuppliersTableAnnotationComposer(
            $db: $db,
            $table: $db.suppliers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> apPaymentAllocationsRefs<T extends Object>(
    Expression<T> Function($$ApPaymentAllocationsTableAnnotationComposer a) f,
  ) {
    final $$ApPaymentAllocationsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.paymentId,
          referencedTable: $db.apPaymentAllocations,
          getReferencedColumn: (t) => t.paymentId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$ApPaymentAllocationsTableAnnotationComposer(
                $db: $db,
                $table: $db.apPaymentAllocations,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$ApPaymentsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ApPaymentsTable,
          ApPayment,
          $$ApPaymentsTableFilterComposer,
          $$ApPaymentsTableOrderingComposer,
          $$ApPaymentsTableAnnotationComposer,
          $$ApPaymentsTableCreateCompanionBuilder,
          $$ApPaymentsTableUpdateCompanionBuilder,
          (ApPayment, $$ApPaymentsTableReferences),
          ApPayment,
          PrefetchHooks Function({
            bool supplierId,
            bool userId,
            bool apPaymentAllocationsRefs,
          })
        > {
  $$ApPaymentsTableTableManager(_$AppDatabase db, $ApPaymentsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ApPaymentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ApPaymentsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ApPaymentsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> paymentId = const Value.absent(),
                Value<String> paymentNo = const Value.absent(),
                Value<DateTime> paymentDate = const Value.absent(),
                Value<String> supplierId = const Value.absent(),
                Value<double> totalAmount = const Value.absent(),
                Value<String> paymentMethod = const Value.absent(),
                Value<String?> bankName = const Value.absent(),
                Value<String?> chequeNo = const Value.absent(),
                Value<DateTime?> chequeDate = const Value.absent(),
                Value<String?> transferRef = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> remark = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ApPaymentsCompanion(
                paymentId: paymentId,
                paymentNo: paymentNo,
                paymentDate: paymentDate,
                supplierId: supplierId,
                totalAmount: totalAmount,
                paymentMethod: paymentMethod,
                bankName: bankName,
                chequeNo: chequeNo,
                chequeDate: chequeDate,
                transferRef: transferRef,
                userId: userId,
                remark: remark,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String paymentId,
                required String paymentNo,
                required DateTime paymentDate,
                required String supplierId,
                required double totalAmount,
                Value<String> paymentMethod = const Value.absent(),
                Value<String?> bankName = const Value.absent(),
                Value<String?> chequeNo = const Value.absent(),
                Value<DateTime?> chequeDate = const Value.absent(),
                Value<String?> transferRef = const Value.absent(),
                required String userId,
                Value<String?> remark = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ApPaymentsCompanion.insert(
                paymentId: paymentId,
                paymentNo: paymentNo,
                paymentDate: paymentDate,
                supplierId: supplierId,
                totalAmount: totalAmount,
                paymentMethod: paymentMethod,
                bankName: bankName,
                chequeNo: chequeNo,
                chequeDate: chequeDate,
                transferRef: transferRef,
                userId: userId,
                remark: remark,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ApPaymentsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                supplierId = false,
                userId = false,
                apPaymentAllocationsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (apPaymentAllocationsRefs) db.apPaymentAllocations,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (supplierId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.supplierId,
                                    referencedTable: $$ApPaymentsTableReferences
                                        ._supplierIdTable(db),
                                    referencedColumn:
                                        $$ApPaymentsTableReferences
                                            ._supplierIdTable(db)
                                            .supplierId,
                                  )
                                  as T;
                        }
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable: $$ApPaymentsTableReferences
                                        ._userIdTable(db),
                                    referencedColumn:
                                        $$ApPaymentsTableReferences
                                            ._userIdTable(db)
                                            .userId,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (apPaymentAllocationsRefs)
                        await $_getPrefetchedData<
                          ApPayment,
                          $ApPaymentsTable,
                          ApPaymentAllocation
                        >(
                          currentTable: table,
                          referencedTable: $$ApPaymentsTableReferences
                              ._apPaymentAllocationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ApPaymentsTableReferences(
                                db,
                                table,
                                p0,
                              ).apPaymentAllocationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.paymentId == item.paymentId,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ApPaymentsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ApPaymentsTable,
      ApPayment,
      $$ApPaymentsTableFilterComposer,
      $$ApPaymentsTableOrderingComposer,
      $$ApPaymentsTableAnnotationComposer,
      $$ApPaymentsTableCreateCompanionBuilder,
      $$ApPaymentsTableUpdateCompanionBuilder,
      (ApPayment, $$ApPaymentsTableReferences),
      ApPayment,
      PrefetchHooks Function({
        bool supplierId,
        bool userId,
        bool apPaymentAllocationsRefs,
      })
    >;
typedef $$ApPaymentAllocationsTableCreateCompanionBuilder =
    ApPaymentAllocationsCompanion Function({
      required String allocationId,
      required String paymentId,
      required String invoiceId,
      required double allocatedAmount,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$ApPaymentAllocationsTableUpdateCompanionBuilder =
    ApPaymentAllocationsCompanion Function({
      Value<String> allocationId,
      Value<String> paymentId,
      Value<String> invoiceId,
      Value<double> allocatedAmount,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ApPaymentAllocationsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $ApPaymentAllocationsTable,
          ApPaymentAllocation
        > {
  $$ApPaymentAllocationsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ApPaymentsTable _paymentIdTable(_$AppDatabase db) =>
      db.apPayments.createAlias(
        $_aliasNameGenerator(
          db.apPaymentAllocations.paymentId,
          db.apPayments.paymentId,
        ),
      );

  $$ApPaymentsTableProcessedTableManager get paymentId {
    final $_column = $_itemColumn<String>('payment_id')!;

    final manager = $$ApPaymentsTableTableManager(
      $_db,
      $_db.apPayments,
    ).filter((f) => f.paymentId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_paymentIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ApInvoicesTable _invoiceIdTable(_$AppDatabase db) =>
      db.apInvoices.createAlias(
        $_aliasNameGenerator(
          db.apPaymentAllocations.invoiceId,
          db.apInvoices.invoiceId,
        ),
      );

  $$ApInvoicesTableProcessedTableManager get invoiceId {
    final $_column = $_itemColumn<String>('invoice_id')!;

    final manager = $$ApInvoicesTableTableManager(
      $_db,
      $_db.apInvoices,
    ).filter((f) => f.invoiceId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_invoiceIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ApPaymentAllocationsTableFilterComposer
    extends Composer<_$AppDatabase, $ApPaymentAllocationsTable> {
  $$ApPaymentAllocationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get allocationId => $composableBuilder(
    column: $table.allocationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get allocatedAmount => $composableBuilder(
    column: $table.allocatedAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ApPaymentsTableFilterComposer get paymentId {
    final $$ApPaymentsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.paymentId,
      referencedTable: $db.apPayments,
      getReferencedColumn: (t) => t.paymentId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApPaymentsTableFilterComposer(
            $db: $db,
            $table: $db.apPayments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ApInvoicesTableFilterComposer get invoiceId {
    final $$ApInvoicesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.invoiceId,
      referencedTable: $db.apInvoices,
      getReferencedColumn: (t) => t.invoiceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApInvoicesTableFilterComposer(
            $db: $db,
            $table: $db.apInvoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ApPaymentAllocationsTableOrderingComposer
    extends Composer<_$AppDatabase, $ApPaymentAllocationsTable> {
  $$ApPaymentAllocationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get allocationId => $composableBuilder(
    column: $table.allocationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get allocatedAmount => $composableBuilder(
    column: $table.allocatedAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ApPaymentsTableOrderingComposer get paymentId {
    final $$ApPaymentsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.paymentId,
      referencedTable: $db.apPayments,
      getReferencedColumn: (t) => t.paymentId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApPaymentsTableOrderingComposer(
            $db: $db,
            $table: $db.apPayments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ApInvoicesTableOrderingComposer get invoiceId {
    final $$ApInvoicesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.invoiceId,
      referencedTable: $db.apInvoices,
      getReferencedColumn: (t) => t.invoiceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApInvoicesTableOrderingComposer(
            $db: $db,
            $table: $db.apInvoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ApPaymentAllocationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ApPaymentAllocationsTable> {
  $$ApPaymentAllocationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get allocationId => $composableBuilder(
    column: $table.allocationId,
    builder: (column) => column,
  );

  GeneratedColumn<double> get allocatedAmount => $composableBuilder(
    column: $table.allocatedAmount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$ApPaymentsTableAnnotationComposer get paymentId {
    final $$ApPaymentsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.paymentId,
      referencedTable: $db.apPayments,
      getReferencedColumn: (t) => t.paymentId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApPaymentsTableAnnotationComposer(
            $db: $db,
            $table: $db.apPayments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ApInvoicesTableAnnotationComposer get invoiceId {
    final $$ApInvoicesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.invoiceId,
      referencedTable: $db.apInvoices,
      getReferencedColumn: (t) => t.invoiceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ApInvoicesTableAnnotationComposer(
            $db: $db,
            $table: $db.apInvoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ApPaymentAllocationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ApPaymentAllocationsTable,
          ApPaymentAllocation,
          $$ApPaymentAllocationsTableFilterComposer,
          $$ApPaymentAllocationsTableOrderingComposer,
          $$ApPaymentAllocationsTableAnnotationComposer,
          $$ApPaymentAllocationsTableCreateCompanionBuilder,
          $$ApPaymentAllocationsTableUpdateCompanionBuilder,
          (ApPaymentAllocation, $$ApPaymentAllocationsTableReferences),
          ApPaymentAllocation,
          PrefetchHooks Function({bool paymentId, bool invoiceId})
        > {
  $$ApPaymentAllocationsTableTableManager(
    _$AppDatabase db,
    $ApPaymentAllocationsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ApPaymentAllocationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ApPaymentAllocationsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$ApPaymentAllocationsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> allocationId = const Value.absent(),
                Value<String> paymentId = const Value.absent(),
                Value<String> invoiceId = const Value.absent(),
                Value<double> allocatedAmount = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ApPaymentAllocationsCompanion(
                allocationId: allocationId,
                paymentId: paymentId,
                invoiceId: invoiceId,
                allocatedAmount: allocatedAmount,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String allocationId,
                required String paymentId,
                required String invoiceId,
                required double allocatedAmount,
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ApPaymentAllocationsCompanion.insert(
                allocationId: allocationId,
                paymentId: paymentId,
                invoiceId: invoiceId,
                allocatedAmount: allocatedAmount,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ApPaymentAllocationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({paymentId = false, invoiceId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (paymentId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.paymentId,
                                referencedTable:
                                    $$ApPaymentAllocationsTableReferences
                                        ._paymentIdTable(db),
                                referencedColumn:
                                    $$ApPaymentAllocationsTableReferences
                                        ._paymentIdTable(db)
                                        .paymentId,
                              )
                              as T;
                    }
                    if (invoiceId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.invoiceId,
                                referencedTable:
                                    $$ApPaymentAllocationsTableReferences
                                        ._invoiceIdTable(db),
                                referencedColumn:
                                    $$ApPaymentAllocationsTableReferences
                                        ._invoiceIdTable(db)
                                        .invoiceId,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ApPaymentAllocationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ApPaymentAllocationsTable,
      ApPaymentAllocation,
      $$ApPaymentAllocationsTableFilterComposer,
      $$ApPaymentAllocationsTableOrderingComposer,
      $$ApPaymentAllocationsTableAnnotationComposer,
      $$ApPaymentAllocationsTableCreateCompanionBuilder,
      $$ApPaymentAllocationsTableUpdateCompanionBuilder,
      (ApPaymentAllocation, $$ApPaymentAllocationsTableReferences),
      ApPaymentAllocation,
      PrefetchHooks Function({bool paymentId, bool invoiceId})
    >;
typedef $$DevicesTableCreateCompanionBuilder =
    DevicesCompanion Function({
      required String deviceId,
      required String deviceName,
      required String deviceType,
      Value<String?> ipAddress,
      Value<String?> macAddress,
      Value<bool> isOnline,
      Value<DateTime?> lastSeen,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$DevicesTableUpdateCompanionBuilder =
    DevicesCompanion Function({
      Value<String> deviceId,
      Value<String> deviceName,
      Value<String> deviceType,
      Value<String?> ipAddress,
      Value<String?> macAddress,
      Value<bool> isOnline,
      Value<DateTime?> lastSeen,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$DevicesTableReferences
    extends BaseReferences<_$AppDatabase, $DevicesTable, Device> {
  $$DevicesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$ActiveSessionsTable, List<ActiveSession>>
  _activeSessionsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.activeSessions,
    aliasName: $_aliasNameGenerator(
      db.devices.deviceId,
      db.activeSessions.deviceId,
    ),
  );

  $$ActiveSessionsTableProcessedTableManager get activeSessionsRefs {
    final manager = $$ActiveSessionsTableTableManager($_db, $_db.activeSessions)
        .filter(
          (f) =>
              f.deviceId.deviceId.sqlEquals($_itemColumn<String>('device_id')!),
        );

    final cache = $_typedResult.readTableOrNull(_activeSessionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$DevicesTableFilterComposer
    extends Composer<_$AppDatabase, $DevicesTable> {
  $$DevicesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get deviceId => $composableBuilder(
    column: $table.deviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get deviceName => $composableBuilder(
    column: $table.deviceName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get deviceType => $composableBuilder(
    column: $table.deviceType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ipAddress => $composableBuilder(
    column: $table.ipAddress,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get macAddress => $composableBuilder(
    column: $table.macAddress,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isOnline => $composableBuilder(
    column: $table.isOnline,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSeen => $composableBuilder(
    column: $table.lastSeen,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> activeSessionsRefs(
    Expression<bool> Function($$ActiveSessionsTableFilterComposer f) f,
  ) {
    final $$ActiveSessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.deviceId,
      referencedTable: $db.activeSessions,
      getReferencedColumn: (t) => t.deviceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActiveSessionsTableFilterComposer(
            $db: $db,
            $table: $db.activeSessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$DevicesTableOrderingComposer
    extends Composer<_$AppDatabase, $DevicesTable> {
  $$DevicesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get deviceId => $composableBuilder(
    column: $table.deviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get deviceName => $composableBuilder(
    column: $table.deviceName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get deviceType => $composableBuilder(
    column: $table.deviceType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ipAddress => $composableBuilder(
    column: $table.ipAddress,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get macAddress => $composableBuilder(
    column: $table.macAddress,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isOnline => $composableBuilder(
    column: $table.isOnline,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSeen => $composableBuilder(
    column: $table.lastSeen,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$DevicesTableAnnotationComposer
    extends Composer<_$AppDatabase, $DevicesTable> {
  $$DevicesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get deviceId =>
      $composableBuilder(column: $table.deviceId, builder: (column) => column);

  GeneratedColumn<String> get deviceName => $composableBuilder(
    column: $table.deviceName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get deviceType => $composableBuilder(
    column: $table.deviceType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get ipAddress =>
      $composableBuilder(column: $table.ipAddress, builder: (column) => column);

  GeneratedColumn<String> get macAddress => $composableBuilder(
    column: $table.macAddress,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isOnline =>
      $composableBuilder(column: $table.isOnline, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSeen =>
      $composableBuilder(column: $table.lastSeen, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  Expression<T> activeSessionsRefs<T extends Object>(
    Expression<T> Function($$ActiveSessionsTableAnnotationComposer a) f,
  ) {
    final $$ActiveSessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.deviceId,
      referencedTable: $db.activeSessions,
      getReferencedColumn: (t) => t.deviceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActiveSessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.activeSessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$DevicesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $DevicesTable,
          Device,
          $$DevicesTableFilterComposer,
          $$DevicesTableOrderingComposer,
          $$DevicesTableAnnotationComposer,
          $$DevicesTableCreateCompanionBuilder,
          $$DevicesTableUpdateCompanionBuilder,
          (Device, $$DevicesTableReferences),
          Device,
          PrefetchHooks Function({bool activeSessionsRefs})
        > {
  $$DevicesTableTableManager(_$AppDatabase db, $DevicesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DevicesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DevicesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DevicesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> deviceId = const Value.absent(),
                Value<String> deviceName = const Value.absent(),
                Value<String> deviceType = const Value.absent(),
                Value<String?> ipAddress = const Value.absent(),
                Value<String?> macAddress = const Value.absent(),
                Value<bool> isOnline = const Value.absent(),
                Value<DateTime?> lastSeen = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => DevicesCompanion(
                deviceId: deviceId,
                deviceName: deviceName,
                deviceType: deviceType,
                ipAddress: ipAddress,
                macAddress: macAddress,
                isOnline: isOnline,
                lastSeen: lastSeen,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String deviceId,
                required String deviceName,
                required String deviceType,
                Value<String?> ipAddress = const Value.absent(),
                Value<String?> macAddress = const Value.absent(),
                Value<bool> isOnline = const Value.absent(),
                Value<DateTime?> lastSeen = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => DevicesCompanion.insert(
                deviceId: deviceId,
                deviceName: deviceName,
                deviceType: deviceType,
                ipAddress: ipAddress,
                macAddress: macAddress,
                isOnline: isOnline,
                lastSeen: lastSeen,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$DevicesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({activeSessionsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (activeSessionsRefs) db.activeSessions,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (activeSessionsRefs)
                    await $_getPrefetchedData<
                      Device,
                      $DevicesTable,
                      ActiveSession
                    >(
                      currentTable: table,
                      referencedTable: $$DevicesTableReferences
                          ._activeSessionsRefsTable(db),
                      managerFromTypedResult: (p0) => $$DevicesTableReferences(
                        db,
                        table,
                        p0,
                      ).activeSessionsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.deviceId == item.deviceId,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$DevicesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $DevicesTable,
      Device,
      $$DevicesTableFilterComposer,
      $$DevicesTableOrderingComposer,
      $$DevicesTableAnnotationComposer,
      $$DevicesTableCreateCompanionBuilder,
      $$DevicesTableUpdateCompanionBuilder,
      (Device, $$DevicesTableReferences),
      Device,
      PrefetchHooks Function({bool activeSessionsRefs})
    >;
typedef $$ActiveSessionsTableCreateCompanionBuilder =
    ActiveSessionsCompanion Function({
      required String sessionId,
      Value<String?> deviceId,
      Value<String?> userId,
      required String token,
      Value<String?> ipAddress,
      Value<DateTime> startedAt,
      Value<DateTime> lastActivity,
      Value<int> rowid,
    });
typedef $$ActiveSessionsTableUpdateCompanionBuilder =
    ActiveSessionsCompanion Function({
      Value<String> sessionId,
      Value<String?> deviceId,
      Value<String?> userId,
      Value<String> token,
      Value<String?> ipAddress,
      Value<DateTime> startedAt,
      Value<DateTime> lastActivity,
      Value<int> rowid,
    });

final class $$ActiveSessionsTableReferences
    extends BaseReferences<_$AppDatabase, $ActiveSessionsTable, ActiveSession> {
  $$ActiveSessionsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $DevicesTable _deviceIdTable(_$AppDatabase db) =>
      db.devices.createAlias(
        $_aliasNameGenerator(db.activeSessions.deviceId, db.devices.deviceId),
      );

  $$DevicesTableProcessedTableManager? get deviceId {
    final $_column = $_itemColumn<String>('device_id');
    if ($_column == null) return null;
    final manager = $$DevicesTableTableManager(
      $_db,
      $_db.devices,
    ).filter((f) => f.deviceId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_deviceIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.activeSessions.userId, db.users.userId),
  );

  $$UsersTableProcessedTableManager? get userId {
    final $_column = $_itemColumn<String>('user_id');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.userId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ActiveSessionsTableFilterComposer
    extends Composer<_$AppDatabase, $ActiveSessionsTable> {
  $$ActiveSessionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get token => $composableBuilder(
    column: $table.token,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ipAddress => $composableBuilder(
    column: $table.ipAddress,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastActivity => $composableBuilder(
    column: $table.lastActivity,
    builder: (column) => ColumnFilters(column),
  );

  $$DevicesTableFilterComposer get deviceId {
    final $$DevicesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.deviceId,
      referencedTable: $db.devices,
      getReferencedColumn: (t) => t.deviceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DevicesTableFilterComposer(
            $db: $db,
            $table: $db.devices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActiveSessionsTableOrderingComposer
    extends Composer<_$AppDatabase, $ActiveSessionsTable> {
  $$ActiveSessionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get token => $composableBuilder(
    column: $table.token,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ipAddress => $composableBuilder(
    column: $table.ipAddress,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastActivity => $composableBuilder(
    column: $table.lastActivity,
    builder: (column) => ColumnOrderings(column),
  );

  $$DevicesTableOrderingComposer get deviceId {
    final $$DevicesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.deviceId,
      referencedTable: $db.devices,
      getReferencedColumn: (t) => t.deviceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DevicesTableOrderingComposer(
            $db: $db,
            $table: $db.devices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActiveSessionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActiveSessionsTable> {
  $$ActiveSessionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get sessionId =>
      $composableBuilder(column: $table.sessionId, builder: (column) => column);

  GeneratedColumn<String> get token =>
      $composableBuilder(column: $table.token, builder: (column) => column);

  GeneratedColumn<String> get ipAddress =>
      $composableBuilder(column: $table.ipAddress, builder: (column) => column);

  GeneratedColumn<DateTime> get startedAt =>
      $composableBuilder(column: $table.startedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastActivity => $composableBuilder(
    column: $table.lastActivity,
    builder: (column) => column,
  );

  $$DevicesTableAnnotationComposer get deviceId {
    final $$DevicesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.deviceId,
      referencedTable: $db.devices,
      getReferencedColumn: (t) => t.deviceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DevicesTableAnnotationComposer(
            $db: $db,
            $table: $db.devices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActiveSessionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActiveSessionsTable,
          ActiveSession,
          $$ActiveSessionsTableFilterComposer,
          $$ActiveSessionsTableOrderingComposer,
          $$ActiveSessionsTableAnnotationComposer,
          $$ActiveSessionsTableCreateCompanionBuilder,
          $$ActiveSessionsTableUpdateCompanionBuilder,
          (ActiveSession, $$ActiveSessionsTableReferences),
          ActiveSession,
          PrefetchHooks Function({bool deviceId, bool userId})
        > {
  $$ActiveSessionsTableTableManager(
    _$AppDatabase db,
    $ActiveSessionsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActiveSessionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ActiveSessionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ActiveSessionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> sessionId = const Value.absent(),
                Value<String?> deviceId = const Value.absent(),
                Value<String?> userId = const Value.absent(),
                Value<String> token = const Value.absent(),
                Value<String?> ipAddress = const Value.absent(),
                Value<DateTime> startedAt = const Value.absent(),
                Value<DateTime> lastActivity = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActiveSessionsCompanion(
                sessionId: sessionId,
                deviceId: deviceId,
                userId: userId,
                token: token,
                ipAddress: ipAddress,
                startedAt: startedAt,
                lastActivity: lastActivity,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String sessionId,
                Value<String?> deviceId = const Value.absent(),
                Value<String?> userId = const Value.absent(),
                required String token,
                Value<String?> ipAddress = const Value.absent(),
                Value<DateTime> startedAt = const Value.absent(),
                Value<DateTime> lastActivity = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActiveSessionsCompanion.insert(
                sessionId: sessionId,
                deviceId: deviceId,
                userId: userId,
                token: token,
                ipAddress: ipAddress,
                startedAt: startedAt,
                lastActivity: lastActivity,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ActiveSessionsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({deviceId = false, userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (deviceId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.deviceId,
                                referencedTable: $$ActiveSessionsTableReferences
                                    ._deviceIdTable(db),
                                referencedColumn:
                                    $$ActiveSessionsTableReferences
                                        ._deviceIdTable(db)
                                        .deviceId,
                              )
                              as T;
                    }
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable: $$ActiveSessionsTableReferences
                                    ._userIdTable(db),
                                referencedColumn:
                                    $$ActiveSessionsTableReferences
                                        ._userIdTable(db)
                                        .userId,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ActiveSessionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActiveSessionsTable,
      ActiveSession,
      $$ActiveSessionsTableFilterComposer,
      $$ActiveSessionsTableOrderingComposer,
      $$ActiveSessionsTableAnnotationComposer,
      $$ActiveSessionsTableCreateCompanionBuilder,
      $$ActiveSessionsTableUpdateCompanionBuilder,
      (ActiveSession, $$ActiveSessionsTableReferences),
      ActiveSession,
      PrefetchHooks Function({bool deviceId, bool userId})
    >;
typedef $$SyncQueuesTableCreateCompanionBuilder =
    SyncQueuesCompanion Function({
      required String queueId,
      required String deviceId,
      required String tableNameValue,
      required String recordId,
      required String operation,
      Value<Map<String, dynamic>?> data,
      Value<String> syncStatus,
      Value<DateTime> createdAt,
      Value<DateTime?> syncedAt,
      Value<int> rowid,
    });
typedef $$SyncQueuesTableUpdateCompanionBuilder =
    SyncQueuesCompanion Function({
      Value<String> queueId,
      Value<String> deviceId,
      Value<String> tableNameValue,
      Value<String> recordId,
      Value<String> operation,
      Value<Map<String, dynamic>?> data,
      Value<String> syncStatus,
      Value<DateTime> createdAt,
      Value<DateTime?> syncedAt,
      Value<int> rowid,
    });

class $$SyncQueuesTableFilterComposer
    extends Composer<_$AppDatabase, $SyncQueuesTable> {
  $$SyncQueuesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get queueId => $composableBuilder(
    column: $table.queueId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get deviceId => $composableBuilder(
    column: $table.deviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tableNameValue => $composableBuilder(
    column: $table.tableNameValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get recordId => $composableBuilder(
    column: $table.recordId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operation => $composableBuilder(
    column: $table.operation,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get data => $composableBuilder(
    column: $table.data,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<String> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
    column: $table.syncedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SyncQueuesTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncQueuesTable> {
  $$SyncQueuesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get queueId => $composableBuilder(
    column: $table.queueId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get deviceId => $composableBuilder(
    column: $table.deviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tableNameValue => $composableBuilder(
    column: $table.tableNameValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get recordId => $composableBuilder(
    column: $table.recordId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operation => $composableBuilder(
    column: $table.operation,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get data => $composableBuilder(
    column: $table.data,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
    column: $table.syncedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SyncQueuesTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncQueuesTable> {
  $$SyncQueuesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get queueId =>
      $composableBuilder(column: $table.queueId, builder: (column) => column);

  GeneratedColumn<String> get deviceId =>
      $composableBuilder(column: $table.deviceId, builder: (column) => column);

  GeneratedColumn<String> get tableNameValue => $composableBuilder(
    column: $table.tableNameValue,
    builder: (column) => column,
  );

  GeneratedColumn<String> get recordId =>
      $composableBuilder(column: $table.recordId, builder: (column) => column);

  GeneratedColumn<String> get operation =>
      $composableBuilder(column: $table.operation, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get data =>
      $composableBuilder(column: $table.data, builder: (column) => column);

  GeneratedColumn<String> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);
}

class $$SyncQueuesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SyncQueuesTable,
          SyncQueue,
          $$SyncQueuesTableFilterComposer,
          $$SyncQueuesTableOrderingComposer,
          $$SyncQueuesTableAnnotationComposer,
          $$SyncQueuesTableCreateCompanionBuilder,
          $$SyncQueuesTableUpdateCompanionBuilder,
          (
            SyncQueue,
            BaseReferences<_$AppDatabase, $SyncQueuesTable, SyncQueue>,
          ),
          SyncQueue,
          PrefetchHooks Function()
        > {
  $$SyncQueuesTableTableManager(_$AppDatabase db, $SyncQueuesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncQueuesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncQueuesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SyncQueuesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> queueId = const Value.absent(),
                Value<String> deviceId = const Value.absent(),
                Value<String> tableNameValue = const Value.absent(),
                Value<String> recordId = const Value.absent(),
                Value<String> operation = const Value.absent(),
                Value<Map<String, dynamic>?> data = const Value.absent(),
                Value<String> syncStatus = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> syncedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SyncQueuesCompanion(
                queueId: queueId,
                deviceId: deviceId,
                tableNameValue: tableNameValue,
                recordId: recordId,
                operation: operation,
                data: data,
                syncStatus: syncStatus,
                createdAt: createdAt,
                syncedAt: syncedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String queueId,
                required String deviceId,
                required String tableNameValue,
                required String recordId,
                required String operation,
                Value<Map<String, dynamic>?> data = const Value.absent(),
                Value<String> syncStatus = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> syncedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SyncQueuesCompanion.insert(
                queueId: queueId,
                deviceId: deviceId,
                tableNameValue: tableNameValue,
                recordId: recordId,
                operation: operation,
                data: data,
                syncStatus: syncStatus,
                createdAt: createdAt,
                syncedAt: syncedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SyncQueuesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SyncQueuesTable,
      SyncQueue,
      $$SyncQueuesTableFilterComposer,
      $$SyncQueuesTableOrderingComposer,
      $$SyncQueuesTableAnnotationComposer,
      $$SyncQueuesTableCreateCompanionBuilder,
      $$SyncQueuesTableUpdateCompanionBuilder,
      (SyncQueue, BaseReferences<_$AppDatabase, $SyncQueuesTable, SyncQueue>),
      SyncQueue,
      PrefetchHooks Function()
    >;
typedef $$AuditLogsTableCreateCompanionBuilder =
    AuditLogsCompanion Function({
      required String logId,
      Value<String?> tableNameValue,
      Value<String?> recordId,
      Value<String?> action,
      Value<String?> userId,
      Value<Map<String, dynamic>?> oldValue,
      Value<Map<String, dynamic>?> newValue,
      Value<String?> ipAddress,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$AuditLogsTableUpdateCompanionBuilder =
    AuditLogsCompanion Function({
      Value<String> logId,
      Value<String?> tableNameValue,
      Value<String?> recordId,
      Value<String?> action,
      Value<String?> userId,
      Value<Map<String, dynamic>?> oldValue,
      Value<Map<String, dynamic>?> newValue,
      Value<String?> ipAddress,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

class $$AuditLogsTableFilterComposer
    extends Composer<_$AppDatabase, $AuditLogsTable> {
  $$AuditLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get logId => $composableBuilder(
    column: $table.logId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tableNameValue => $composableBuilder(
    column: $table.tableNameValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get recordId => $composableBuilder(
    column: $table.recordId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get oldValue => $composableBuilder(
    column: $table.oldValue,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get newValue => $composableBuilder(
    column: $table.newValue,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<String> get ipAddress => $composableBuilder(
    column: $table.ipAddress,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$AuditLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $AuditLogsTable> {
  $$AuditLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get logId => $composableBuilder(
    column: $table.logId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tableNameValue => $composableBuilder(
    column: $table.tableNameValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get recordId => $composableBuilder(
    column: $table.recordId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get oldValue => $composableBuilder(
    column: $table.oldValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get newValue => $composableBuilder(
    column: $table.newValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ipAddress => $composableBuilder(
    column: $table.ipAddress,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AuditLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AuditLogsTable> {
  $$AuditLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get logId =>
      $composableBuilder(column: $table.logId, builder: (column) => column);

  GeneratedColumn<String> get tableNameValue => $composableBuilder(
    column: $table.tableNameValue,
    builder: (column) => column,
  );

  GeneratedColumn<String> get recordId =>
      $composableBuilder(column: $table.recordId, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get oldValue =>
      $composableBuilder(column: $table.oldValue, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get newValue =>
      $composableBuilder(column: $table.newValue, builder: (column) => column);

  GeneratedColumn<String> get ipAddress =>
      $composableBuilder(column: $table.ipAddress, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$AuditLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AuditLogsTable,
          AuditLog,
          $$AuditLogsTableFilterComposer,
          $$AuditLogsTableOrderingComposer,
          $$AuditLogsTableAnnotationComposer,
          $$AuditLogsTableCreateCompanionBuilder,
          $$AuditLogsTableUpdateCompanionBuilder,
          (AuditLog, BaseReferences<_$AppDatabase, $AuditLogsTable, AuditLog>),
          AuditLog,
          PrefetchHooks Function()
        > {
  $$AuditLogsTableTableManager(_$AppDatabase db, $AuditLogsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AuditLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AuditLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AuditLogsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> logId = const Value.absent(),
                Value<String?> tableNameValue = const Value.absent(),
                Value<String?> recordId = const Value.absent(),
                Value<String?> action = const Value.absent(),
                Value<String?> userId = const Value.absent(),
                Value<Map<String, dynamic>?> oldValue = const Value.absent(),
                Value<Map<String, dynamic>?> newValue = const Value.absent(),
                Value<String?> ipAddress = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AuditLogsCompanion(
                logId: logId,
                tableNameValue: tableNameValue,
                recordId: recordId,
                action: action,
                userId: userId,
                oldValue: oldValue,
                newValue: newValue,
                ipAddress: ipAddress,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String logId,
                Value<String?> tableNameValue = const Value.absent(),
                Value<String?> recordId = const Value.absent(),
                Value<String?> action = const Value.absent(),
                Value<String?> userId = const Value.absent(),
                Value<Map<String, dynamic>?> oldValue = const Value.absent(),
                Value<Map<String, dynamic>?> newValue = const Value.absent(),
                Value<String?> ipAddress = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AuditLogsCompanion.insert(
                logId: logId,
                tableNameValue: tableNameValue,
                recordId: recordId,
                action: action,
                userId: userId,
                oldValue: oldValue,
                newValue: newValue,
                ipAddress: ipAddress,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$AuditLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AuditLogsTable,
      AuditLog,
      $$AuditLogsTableFilterComposer,
      $$AuditLogsTableOrderingComposer,
      $$AuditLogsTableAnnotationComposer,
      $$AuditLogsTableCreateCompanionBuilder,
      $$AuditLogsTableUpdateCompanionBuilder,
      (AuditLog, BaseReferences<_$AppDatabase, $AuditLogsTable, AuditLog>),
      AuditLog,
      PrefetchHooks Function()
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$CompaniesTableTableManager get companies =>
      $$CompaniesTableTableManager(_db, _db.companies);
  $$BranchesTableTableManager get branches =>
      $$BranchesTableTableManager(_db, _db.branches);
  $$RolesTableTableManager get roles =>
      $$RolesTableTableManager(_db, _db.roles);
  $$UsersTableTableManager get users =>
      $$UsersTableTableManager(_db, _db.users);
  $$ProductGroupsTableTableManager get productGroups =>
      $$ProductGroupsTableTableManager(_db, _db.productGroups);
  $$ProductsTableTableManager get products =>
      $$ProductsTableTableManager(_db, _db.products);
  $$WarehousesTableTableManager get warehouses =>
      $$WarehousesTableTableManager(_db, _db.warehouses);
  $$StockBalancesTableTableManager get stockBalances =>
      $$StockBalancesTableTableManager(_db, _db.stockBalances);
  $$SerialNumbersTableTableManager get serialNumbers =>
      $$SerialNumbersTableTableManager(_db, _db.serialNumbers);
  $$ModifierGroupsTableTableManager get modifierGroups =>
      $$ModifierGroupsTableTableManager(_db, _db.modifierGroups);
  $$ModifiersTableTableManager get modifiers =>
      $$ModifiersTableTableManager(_db, _db.modifiers);
  $$ProductModifiersTableTableManager get productModifiers =>
      $$ProductModifiersTableTableManager(_db, _db.productModifiers);
  $$ZonesTableTableManager get zones =>
      $$ZonesTableTableManager(_db, _db.zones);
  $$DiningTablesTableTableManager get diningTables =>
      $$DiningTablesTableTableManager(_db, _db.diningTables);
  $$CustomerGroupsTableTableManager get customerGroups =>
      $$CustomerGroupsTableTableManager(_db, _db.customerGroups);
  $$CustomersTableTableManager get customers =>
      $$CustomersTableTableManager(_db, _db.customers);
  $$SuppliersTableTableManager get suppliers =>
      $$SuppliersTableTableManager(_db, _db.suppliers);
  $$SalesOrdersTableTableManager get salesOrders =>
      $$SalesOrdersTableTableManager(_db, _db.salesOrders);
  $$SalesOrderItemsTableTableManager get salesOrderItems =>
      $$SalesOrderItemsTableTableManager(_db, _db.salesOrderItems);
  $$OrderItemModifiersTableTableManager get orderItemModifiers =>
      $$OrderItemModifiersTableTableManager(_db, _db.orderItemModifiers);
  $$PurchaseOrdersTableTableManager get purchaseOrders =>
      $$PurchaseOrdersTableTableManager(_db, _db.purchaseOrders);
  $$PurchaseOrderItemsTableTableManager get purchaseOrderItems =>
      $$PurchaseOrderItemsTableTableManager(_db, _db.purchaseOrderItems);
  $$StockMovementsTableTableManager get stockMovements =>
      $$StockMovementsTableTableManager(_db, _db.stockMovements);
  $$PromotionsTableTableManager get promotions =>
      $$PromotionsTableTableManager(_db, _db.promotions);
  $$PromotionUsagesTableTableManager get promotionUsages =>
      $$PromotionUsagesTableTableManager(_db, _db.promotionUsages);
  $$CouponsTableTableManager get coupons =>
      $$CouponsTableTableManager(_db, _db.coupons);
  $$ArInvoicesTableTableManager get arInvoices =>
      $$ArInvoicesTableTableManager(_db, _db.arInvoices);
  $$ArReceiptsTableTableManager get arReceipts =>
      $$ArReceiptsTableTableManager(_db, _db.arReceipts);
  $$ArReceiptAllocationsTableTableManager get arReceiptAllocations =>
      $$ArReceiptAllocationsTableTableManager(_db, _db.arReceiptAllocations);
  $$ApInvoicesTableTableManager get apInvoices =>
      $$ApInvoicesTableTableManager(_db, _db.apInvoices);
  $$ApPaymentsTableTableManager get apPayments =>
      $$ApPaymentsTableTableManager(_db, _db.apPayments);
  $$ApPaymentAllocationsTableTableManager get apPaymentAllocations =>
      $$ApPaymentAllocationsTableTableManager(_db, _db.apPaymentAllocations);
  $$DevicesTableTableManager get devices =>
      $$DevicesTableTableManager(_db, _db.devices);
  $$ActiveSessionsTableTableManager get activeSessions =>
      $$ActiveSessionsTableTableManager(_db, _db.activeSessions);
  $$SyncQueuesTableTableManager get syncQueues =>
      $$SyncQueuesTableTableManager(_db, _db.syncQueues);
  $$AuditLogsTableTableManager get auditLogs =>
      $$AuditLogsTableTableManager(_db, _db.auditLogs);
}
